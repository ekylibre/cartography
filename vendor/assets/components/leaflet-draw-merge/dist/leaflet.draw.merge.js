/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 175);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (target, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) target[key] = source[key]
  }
});


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ArrayList;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__IndexOutOfBoundsException__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Iterator__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__List__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NoSuchElementException__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__OperationNotSupported__ = __webpack_require__(86);







/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
 *
 * @extends List
 * @private
 */
function ArrayList () {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Collection__["a" /* default */]) {
    this.addAll(arguments[0]);
  }
};
ArrayList.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_3__List__["a" /* default */].prototype)
ArrayList.prototype.constructor = ArrayList;

ArrayList.prototype.ensureCapacity = function () {}
ArrayList.prototype.interfaces_ = function () { return [__WEBPACK_IMPORTED_MODULE_3__List__["a" /* default */], __WEBPACK_IMPORTED_MODULE_0__Collection__["a" /* default */]] }

/**
 * @override
 */
ArrayList.prototype.add = function(e) {
  if (arguments.length === 1) {
    this.array_.push(e)
  } else {
    this.array_.splice(arguments[0], arguments[1])
  }
  return true
};

ArrayList.prototype.clear = function() {
  this.array_ = []
}

/**
 * @override
 */
ArrayList.prototype.addAll = function(c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};


/**
 * @override
 */
ArrayList.prototype.set = function(index, element) {
  var oldElement = this.array_[index];
  this.array_[index] = element;
  return oldElement;
};


/**
 * @override
 */
ArrayList.prototype.iterator = function() {
  return new Iterator_(this);
};


/**
 * @override
 */
ArrayList.prototype.get = function(index) {
  if (index < 0 || index >= this.size()) {
    throw new __WEBPACK_IMPORTED_MODULE_1__IndexOutOfBoundsException__["a" /* default */]();
  }

  return this.array_[index];
};


/**
 * @override
 */
ArrayList.prototype.isEmpty = function() {
  return this.array_.length === 0;
};


/**
 * @override
 */
ArrayList.prototype.size = function() {
  return this.array_.length;
};


/**
 * @override
 */
ArrayList.prototype.toArray = function() {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};


/**
 * @override
 */
ArrayList.prototype.remove = function(o) {
  var found = false;

  for (var i = 0, len = this.array_.length; i < len; i++) {
    if (this.array_[i] === o) {
      this.array_.splice(i, 1);
      found = true;
      break;
    }
  }

  return found;
};



/**
 * @extends {Iterator}
 * @param {ArrayList} arrayList
 * @constructor
 * @private
 */
var Iterator_ = function(arrayList) {
  /**
   * @type {ArrayList}
   * @private
  */
  this.arrayList_ = arrayList;
  /**
   * @type {number}
   * @private
  */
  this.position_ = 0;
};


/**
 * @override
 */
Iterator_.prototype.next = function() {
  if (this.position_ === this.arrayList_.size()) {
    throw new __WEBPACK_IMPORTED_MODULE_4__NoSuchElementException__["a" /* default */]();
  }
  return this.arrayList_.get(this.position_++);
};


/**
 * @override
 */
Iterator_.prototype.hasNext = function() {
  if (this.position_ < this.arrayList_.size()) {
    return true;
  } else {
    return false;
  }
};

/**
 * TODO: should be in ListIterator
 * @override
 */
Iterator_.prototype.set = function(element) {
  return this.arrayList_.set(this.position_ - 1, element);
};


/**
 * @override
 */
Iterator_.prototype.remove = function() {
  this.arrayList_.remove(this.arrayList_.get(this.position_));
};


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Coordinate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_NumberUtil__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_Cloneable__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_Comparator__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_Assert__ = __webpack_require__(4);









function Coordinate() {
	this.x = null;
	this.y = null;
	this.z = null;
	if (arguments.length === 0) {
		Coordinate.call(this, 0.0, 0.0);
	} else if (arguments.length === 1) {
		let c = arguments[0];
		Coordinate.call(this, c.x, c.y, c.z);
	} else if (arguments.length === 2) {
		let x = arguments[0], y = arguments[1];
		Coordinate.call(this, x, y, Coordinate.NULL_ORDINATE);
	} else if (arguments.length === 3) {
		let x = arguments[0], y = arguments[1], z = arguments[2];
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Coordinate.prototype, {
	setOrdinate: function (ordinateIndex, value) {
		switch (ordinateIndex) {
			case Coordinate.X:
				this.x = value;
				break;
			case Coordinate.Y:
				this.y = value;
				break;
			case Coordinate.Z:
				this.z = value;
				break;
			default:
				throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Invalid ordinate index: " + ordinateIndex);
		}
	},
	equals2D: function () {
		if (arguments.length === 1) {
			let other = arguments[0];
			if (this.x !== other.x) {
				return false;
			}
			if (this.y !== other.y) {
				return false;
			}
			return true;
		} else if (arguments.length === 2) {
			let c = arguments[0], tolerance = arguments[1];
			if (!__WEBPACK_IMPORTED_MODULE_0__util_NumberUtil__["a" /* default */].equalsWithTolerance(this.x, c.x, tolerance)) {
				return false;
			}
			if (!__WEBPACK_IMPORTED_MODULE_0__util_NumberUtil__["a" /* default */].equalsWithTolerance(this.y, c.y, tolerance)) {
				return false;
			}
			return true;
		}
	},
	getOrdinate: function (ordinateIndex) {
		switch (ordinateIndex) {
			case Coordinate.X:
				return this.x;
			case Coordinate.Y:
				return this.y;
			case Coordinate.Z:
				return this.z;
		}
		throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Invalid ordinate index: " + ordinateIndex);
	},
	equals3D: function (other) {
		return this.x === other.x && this.y === other.y && (this.z === other.z || __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(this.z) && __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(other.z));
	},
	equals: function (other) {
		if (!(other instanceof Coordinate)) {
			return false;
		}
		return this.equals2D(other);
	},
	equalInZ: function (c, tolerance) {
		return __WEBPACK_IMPORTED_MODULE_0__util_NumberUtil__["a" /* default */].equalsWithTolerance(this.z, c.z, tolerance);
	},
	compareTo: function (o) {
		var other = o;
		if (this.x < other.x) return -1;
		if (this.x > other.x) return 1;
		if (this.y < other.y) return -1;
		if (this.y > other.y) return 1;
		return 0;
	},
	clone: function () {
		try {
			var coord = null;
			return coord;
		} catch (e) {
			if (e instanceof CloneNotSupportedException) {
				__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].shouldNeverReachHere("this shouldn't happen because this class is Cloneable");
				return null;
			} else throw e;
		} finally {}
	},
	copy: function () {
		return new Coordinate(this);
	},
	toString: function () {
		return "(" + this.x + ", " + this.y + ", " + this.z + ")";
	},
	distance3D: function (c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		var dz = this.z - c.z;
		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	},
	distance: function (c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		return Math.sqrt(dx * dx + dy * dy);
	},
	hashCode: function () {
		var result = 17;
		result = 37 * result + Coordinate.hashCode(this.x);
		result = 37 * result + Coordinate.hashCode(this.y);
		return result;
	},
	setCoordinate: function (other) {
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__java_lang_Comparable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__java_lang_Cloneable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return Coordinate;
	}
});
Coordinate.hashCode = function () {
	if (arguments.length === 1) {
		let x = arguments[0];
		var f = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].doubleToLongBits(x);
		return Math.trunc(f ^ f >>> 32);
	}
};
function DimensionalComparator() {
	this._dimensionsToTest = 2;
	if (arguments.length === 0) {
		DimensionalComparator.call(this, 2);
	} else if (arguments.length === 1) {
		let dimensionsToTest = arguments[0];
		if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("only 2 or 3 dimensions may be specified");
		this._dimensionsToTest = dimensionsToTest;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(DimensionalComparator.prototype, {
	compare: function (o1, o2) {
		var c1 = o1;
		var c2 = o2;
		var compX = DimensionalComparator.compare(c1.x, c2.x);
		if (compX !== 0) return compX;
		var compY = DimensionalComparator.compare(c1.y, c2.y);
		if (compY !== 0) return compY;
		if (this._dimensionsToTest <= 2) return 0;
		var compZ = DimensionalComparator.compare(c1.z, c2.z);
		return compZ;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__java_util_Comparator__["a" /* default */]];
	},
	getClass: function () {
		return DimensionalComparator;
	}
});
DimensionalComparator.compare = function (a, b) {
	if (a < b) return -1;
	if (a > b) return 1;
	if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(a)) {
		if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(b)) return 0;
		return -1;
	}
	if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(b)) return 1;
	return 0;
};
Coordinate.DimensionalComparator = DimensionalComparator;
Coordinate.serialVersionUID = 6683108902428366910;
Coordinate.NULL_ORDINATE = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].NaN;
Coordinate.X = 0;
Coordinate.Y = 1;
Coordinate.Z = 2;


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (c, p) {
  c.prototype = Object.create(p.prototype)
  c.prototype.constructor = c
});


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Assert;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AssertionFailedException__ = __webpack_require__(207);


function Assert() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Assert.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Assert;
	}
});
Assert.shouldNeverReachHere = function () {
	if (arguments.length === 0) {
		Assert.shouldNeverReachHere(null);
	} else if (arguments.length === 1) {
		let message = arguments[0];
		throw new __WEBPACK_IMPORTED_MODULE_1__AssertionFailedException__["a" /* default */]("Should never reach here" + (message !== null ? ": " + message : ""));
	}
};
Assert.isTrue = function () {
	if (arguments.length === 1) {
		let assertion = arguments[0];
		Assert.isTrue(assertion, null);
	} else if (arguments.length === 2) {
		let assertion = arguments[0], message = arguments[1];
		if (!assertion) {
			if (message === null) {
				throw new __WEBPACK_IMPORTED_MODULE_1__AssertionFailedException__["a" /* default */]();
			} else {
				throw new __WEBPACK_IMPORTED_MODULE_1__AssertionFailedException__["a" /* default */](message);
			}
		}
	}
};
Assert.equals = function () {
	if (arguments.length === 2) {
		let expectedValue = arguments[0], actualValue = arguments[1];
		Assert.equals(expectedValue, actualValue, null);
	} else if (arguments.length === 3) {
		let expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];
		if (!actualValue.equals(expectedValue)) {
			throw new __WEBPACK_IMPORTED_MODULE_1__AssertionFailedException__["a" /* default */]("Expected " + expectedValue + " but encountered " + actualValue + (message !== null ? ": " + message : ""));
		}
	}
};


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (o, i) {
  return o.interfaces_ && o.interfaces_().indexOf(i) > -1
});


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IllegalArgumentException;
function IllegalArgumentException () {}


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Envelope;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_io_Serializable__ = __webpack_require__(21);




function Envelope() {
	this._minx = null;
	this._maxx = null;
	this._miny = null;
	this._maxy = null;
	if (arguments.length === 0) {
		this.init();
	} else if (arguments.length === 1) {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]) {
			let p = arguments[0];
			this.init(p.x, p.x, p.y, p.y);
		} else if (arguments[0] instanceof Envelope) {
			let env = arguments[0];
			this.init(env);
		}
	} else if (arguments.length === 2) {
		let p1 = arguments[0], p2 = arguments[1];
		this.init(p1.x, p2.x, p1.y, p2.y);
	} else if (arguments.length === 4) {
		let x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];
		this.init(x1, x2, y1, y2);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Envelope.prototype, {
	getArea: function () {
		return this.getWidth() * this.getHeight();
	},
	equals: function (other) {
		if (!(other instanceof Envelope)) {
			return false;
		}
		var otherEnvelope = other;
		if (this.isNull()) {
			return otherEnvelope.isNull();
		}
		return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
	},
	intersection: function (env) {
		if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();
		var intMinX = this._minx > env._minx ? this._minx : env._minx;
		var intMinY = this._miny > env._miny ? this._miny : env._miny;
		var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
		var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
		return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
	},
	isNull: function () {
		return this._maxx < this._minx;
	},
	getMaxX: function () {
		return this._maxx;
	},
	covers: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]) {
				let p = arguments[0];
				return this.covers(p.x, p.y);
			} else if (arguments[0] instanceof Envelope) {
				let other = arguments[0];
				if (this.isNull() || other.isNull()) {
					return false;
				}
				return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
			}
		} else if (arguments.length === 2) {
			let x = arguments[0], y = arguments[1];
			if (this.isNull()) return false;
			return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;
		}
	},
	intersects: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Envelope) {
				let other = arguments[0];
				if (this.isNull() || other.isNull()) {
					return false;
				}
				return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]) {
				let p = arguments[0];
				return this.intersects(p.x, p.y);
			}
		} else if (arguments.length === 2) {
			let x = arguments[0], y = arguments[1];
			if (this.isNull()) return false;
			return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);
		}
	},
	getMinY: function () {
		return this._miny;
	},
	getMinX: function () {
		return this._minx;
	},
	expandToInclude: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]) {
				let p = arguments[0];
				this.expandToInclude(p.x, p.y);
			} else if (arguments[0] instanceof Envelope) {
				let other = arguments[0];
				if (other.isNull()) {
					return null;
				}
				if (this.isNull()) {
					this._minx = other.getMinX();
					this._maxx = other.getMaxX();
					this._miny = other.getMinY();
					this._maxy = other.getMaxY();
				} else {
					if (other._minx < this._minx) {
						this._minx = other._minx;
					}
					if (other._maxx > this._maxx) {
						this._maxx = other._maxx;
					}
					if (other._miny < this._miny) {
						this._miny = other._miny;
					}
					if (other._maxy > this._maxy) {
						this._maxy = other._maxy;
					}
				}
			}
		} else if (arguments.length === 2) {
			let x = arguments[0], y = arguments[1];
			if (this.isNull()) {
				this._minx = x;
				this._maxx = x;
				this._miny = y;
				this._maxy = y;
			} else {
				if (x < this._minx) {
					this._minx = x;
				}
				if (x > this._maxx) {
					this._maxx = x;
				}
				if (y < this._miny) {
					this._miny = y;
				}
				if (y > this._maxy) {
					this._maxy = y;
				}
			}
		}
	},
	minExtent: function () {
		if (this.isNull()) return 0.0;
		var w = this.getWidth();
		var h = this.getHeight();
		if (w < h) return w;
		return h;
	},
	getWidth: function () {
		if (this.isNull()) {
			return 0;
		}
		return this._maxx - this._minx;
	},
	compareTo: function (o) {
		var env = o;
		if (this.isNull()) {
			if (env.isNull()) return 0;
			return -1;
		} else {
			if (env.isNull()) return 1;
		}
		if (this._minx < env._minx) return -1;
		if (this._minx > env._minx) return 1;
		if (this._miny < env._miny) return -1;
		if (this._miny > env._miny) return 1;
		if (this._maxx < env._maxx) return -1;
		if (this._maxx > env._maxx) return 1;
		if (this._maxy < env._maxy) return -1;
		if (this._maxy > env._maxy) return 1;
		return 0;
	},
	translate: function (transX, transY) {
		if (this.isNull()) {
			return null;
		}
		this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
	},
	toString: function () {
		return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
	},
	setToNull: function () {
		this._minx = 0;
		this._maxx = -1;
		this._miny = 0;
		this._maxy = -1;
	},
	getHeight: function () {
		if (this.isNull()) {
			return 0;
		}
		return this._maxy - this._miny;
	},
	maxExtent: function () {
		if (this.isNull()) return 0.0;
		var w = this.getWidth();
		var h = this.getHeight();
		if (w > h) return w;
		return h;
	},
	expandBy: function () {
		if (arguments.length === 1) {
			let distance = arguments[0];
			this.expandBy(distance, distance);
		} else if (arguments.length === 2) {
			let deltaX = arguments[0], deltaY = arguments[1];
			if (this.isNull()) return null;
			this._minx -= deltaX;
			this._maxx += deltaX;
			this._miny -= deltaY;
			this._maxy += deltaY;
			if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
		}
	},
	contains: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Envelope) {
				let other = arguments[0];
				return this.covers(other);
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]) {
				let p = arguments[0];
				return this.covers(p);
			}
		} else if (arguments.length === 2) {
			let x = arguments[0], y = arguments[1];
			return this.covers(x, y);
		}
	},
	centre: function () {
		if (this.isNull()) return null;
		return new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);
	},
	init: function () {
		if (arguments.length === 0) {
			this.setToNull();
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */]) {
				let p = arguments[0];
				this.init(p.x, p.x, p.y, p.y);
			} else if (arguments[0] instanceof Envelope) {
				let env = arguments[0];
				this._minx = env._minx;
				this._maxx = env._maxx;
				this._miny = env._miny;
				this._maxy = env._maxy;
			}
		} else if (arguments.length === 2) {
			let p1 = arguments[0], p2 = arguments[1];
			this.init(p1.x, p2.x, p1.y, p2.y);
		} else if (arguments.length === 4) {
			let x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];
			if (x1 < x2) {
				this._minx = x1;
				this._maxx = x2;
			} else {
				this._minx = x2;
				this._maxx = x1;
			}
			if (y1 < y2) {
				this._miny = y1;
				this._maxy = y2;
			} else {
				this._miny = y2;
				this._maxy = y1;
			}
		}
	},
	getMaxY: function () {
		return this._maxy;
	},
	distance: function (env) {
		if (this.intersects(env)) return 0;
		var dx = 0.0;
		if (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;
		var dy = 0.0;
		if (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;
		if (dx === 0.0) return dy;
		if (dy === 0.0) return dx;
		return Math.sqrt(dx * dx + dy * dy);
	},
	hashCode: function () {
		var result = 17;
		result = 37 * result + __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */].hashCode(this._minx);
		result = 37 * result + __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */].hashCode(this._maxx);
		result = 37 * result + __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */].hashCode(this._miny);
		result = 37 * result + __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */].hashCode(this._maxy);
		return result;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return Envelope;
	}
});
Envelope.intersects = function () {
	if (arguments.length === 3) {
		let p1 = arguments[0], p2 = arguments[1], q = arguments[2];
		if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
			return true;
		}
		return false;
	} else if (arguments.length === 4) {
		let p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];
		var minq = Math.min(q1.x, q2.x);
		var maxq = Math.max(q1.x, q2.x);
		var minp = Math.min(p1.x, p2.x);
		var maxp = Math.max(p1.x, p2.x);
		if (minp > maxq) return false;
		if (maxp < minq) return false;
		minq = Math.min(q1.y, q2.y);
		maxq = Math.max(q1.y, q2.y);
		minp = Math.min(p1.y, p2.y);
		maxp = Math.max(p1.y, p2.y);
		if (minp > maxq) return false;
		if (maxp < minq) return false;
		return true;
	}
};
Envelope.serialVersionUID = 5873921885273102420;


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CGAlgorithms;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_MathUtil__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__CGAlgorithmsDD__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_CoordinateSequence__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__RayCrossingCounter__ = __webpack_require__(123);











function CGAlgorithms() {}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(CGAlgorithms.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CGAlgorithms;
	}
});
CGAlgorithms.orientationIndex = function (p1, p2, q) {
	return __WEBPACK_IMPORTED_MODULE_6__CGAlgorithmsDD__["a" /* default */].orientationIndex(p1, p2, q);
};
CGAlgorithms.signedArea = function () {
	if (arguments[0] instanceof Array) {
		let ring = arguments[0];
		if (ring.length < 3) return 0.0;
		var sum = 0.0;
		var x0 = ring[0].x;
		for (var i = 1; i < ring.length - 1; i++) {
			var x = ring[i].x - x0;
			var y1 = ring[i + 1].y;
			var y2 = ring[i - 1].y;
			sum += x * (y2 - y1);
		}
		return sum / 2.0;
	} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_7__geom_CoordinateSequence__["a" /* default */])) {
		let ring = arguments[0];
		var n = ring.size();
		if (n < 3) return 0.0;
		var p0 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
		var p1 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
		var p2 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
		ring.getCoordinate(0, p1);
		ring.getCoordinate(1, p2);
		var x0 = p1.x;
		p2.x -= x0;
		var sum = 0.0;
		for (var i = 1; i < n - 1; i++) {
			p0.y = p1.y;
			p1.x = p2.x;
			p1.y = p2.y;
			ring.getCoordinate(i + 1, p2);
			p2.x -= x0;
			sum += p1.x * (p0.y - p2.y);
		}
		return sum / 2.0;
	}
};
CGAlgorithms.distanceLineLine = function (A, B, C, D) {
	if (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);
	if (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);
	var noIntersection = false;
	if (!__WEBPACK_IMPORTED_MODULE_9__geom_Envelope__["a" /* default */].intersects(A, B, C, D)) {
		noIntersection = true;
	} else {
		var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
		if (denom === 0) {
			noIntersection = true;
		} else {
			var r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
			var s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
			var s = s_num / denom;
			var r = r_num / denom;
			if (r < 0 || r > 1 || s < 0 || s > 1) {
				noIntersection = true;
			}
		}
	}
	if (noIntersection) {
		return __WEBPACK_IMPORTED_MODULE_5__math_MathUtil__["a" /* default */].min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));
	}
	return 0.0;
};
CGAlgorithms.isPointInRing = function (p, ring) {
	return CGAlgorithms.locatePointInRing(p, ring) !== __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
};
CGAlgorithms.computeLength = function (pts) {
	var n = pts.size();
	if (n <= 1) return 0.0;
	var len = 0.0;
	var p = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
	pts.getCoordinate(0, p);
	var x0 = p.x;
	var y0 = p.y;
	for (var i = 1; i < n; i++) {
		pts.getCoordinate(i, p);
		var x1 = p.x;
		var y1 = p.y;
		var dx = x1 - x0;
		var dy = y1 - y0;
		len += Math.sqrt(dx * dx + dy * dy);
		x0 = x1;
		y0 = y1;
	}
	return len;
};
CGAlgorithms.isCCW = function (ring) {
	var nPts = ring.length - 1;
	if (nPts < 3) throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__["a" /* default */]("Ring has fewer than 4 points, so orientation cannot be determined");
	var hiPt = ring[0];
	var hiIndex = 0;
	for (var i = 1; i <= nPts; i++) {
		var p = ring[i];
		if (p.y > hiPt.y) {
			hiPt = p;
			hiIndex = i;
		}
	}
	var iPrev = hiIndex;
	do {
		iPrev = iPrev - 1;
		if (iPrev < 0) iPrev = nPts;
	} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
	var iNext = hiIndex;
	do {
		iNext = (iNext + 1) % nPts;
	} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
	var prev = ring[iPrev];
	var next = ring[iNext];
	if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
	var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
	var isCCW = false;
	if (disc === 0) {
		isCCW = prev.x > next.x;
	} else {
		isCCW = disc > 0;
	}
	return isCCW;
};
CGAlgorithms.locatePointInRing = function (p, ring) {
	return __WEBPACK_IMPORTED_MODULE_10__RayCrossingCounter__["a" /* default */].locatePointInRing(p, ring);
};
CGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {
	var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
	var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
	return Math.abs(s) * Math.sqrt(len2);
};
CGAlgorithms.computeOrientation = function (p1, p2, q) {
	return CGAlgorithms.orientationIndex(p1, p2, q);
};
CGAlgorithms.distancePointLine = function () {
	if (arguments.length === 2) {
		let p = arguments[0], line = arguments[1];
		if (line.length === 0) throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__["a" /* default */]("Line array must contain at least one vertex");
		var minDistance = p.distance(line[0]);
		for (var i = 0; i < line.length - 1; i++) {
			var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
			if (dist < minDistance) {
				minDistance = dist;
			}
		}
		return minDistance;
	} else if (arguments.length === 3) {
		let p = arguments[0], A = arguments[1], B = arguments[2];
		if (A.x === B.x && A.y === B.y) return p.distance(A);
		var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
		var r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;
		if (r <= 0.0) return p.distance(A);
		if (r >= 1.0) return p.distance(B);
		var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
		return Math.abs(s) * Math.sqrt(len2);
	}
};
CGAlgorithms.isOnLine = function (p, pt) {
	var lineIntersector = new __WEBPACK_IMPORTED_MODULE_8__RobustLineIntersector__["a" /* default */]();
	for (var i = 1; i < pt.length; i++) {
		var p0 = pt[i - 1];
		var p1 = pt[i];
		lineIntersector.computeIntersection(p, p0, p1);
		if (lineIntersector.hasIntersection()) {
			return true;
		}
	}
	return false;
};
CGAlgorithms.CLOCKWISE = -1;
CGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;
CGAlgorithms.COUNTERCLOCKWISE = 1;
CGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;
CGAlgorithms.COLLINEAR = 0;
CGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CoordinateFilter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__operation_BoundaryOp__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Lineal__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__CoordinateSequences__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__GeometryFilter__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__CoordinateSequenceFilter__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__inherits__ = __webpack_require__(3);















function LineString() {
	this._points = null;
	let points = arguments[0], factory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].call(this, factory);
	this.init(points);
}
Object(__WEBPACK_IMPORTED_MODULE_14__inherits__["a" /* default */])(LineString, __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(LineString.prototype, {
	computeEnvelopeInternal: function () {
		if (this.isEmpty()) {
			return new __WEBPACK_IMPORTED_MODULE_13__Envelope__["a" /* default */]();
		}
		return this._points.expandEnvelope(new __WEBPACK_IMPORTED_MODULE_13__Envelope__["a" /* default */]());
	},
	isRing: function () {
		return this.isClosed() && this.isSimple();
	},
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].SORTINDEX_LINESTRING;
	},
	getCoordinates: function () {
		return this._points.toCoordinateArray();
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			var otherLineString = other;
			if (this._points.size() !== otherLineString._points.size()) {
				return false;
			}
			for (var i = 0; i < this._points.size(); i++) {
				if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
					return false;
				}
			}
			return true;
		} else return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	normalize: function () {
		for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
			var j = this._points.size() - 1 - i;
			if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
				if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
					__WEBPACK_IMPORTED_MODULE_8__CoordinateSequences__["a" /* default */].reverse(this._points);
				}
				return null;
			}
		}
	},
	getCoordinate: function () {
		if (this.isEmpty()) return null;
		return this._points.getCoordinate(0);
	},
	getBoundaryDimension: function () {
		if (this.isClosed()) {
			return __WEBPACK_IMPORTED_MODULE_10__Dimension__["a" /* default */].FALSE;
		}
		return 0;
	},
	isClosed: function () {
		if (this.isEmpty()) {
			return false;
		}
		return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
	},
	getEndPoint: function () {
		if (this.isEmpty()) {
			return null;
		}
		return this.getPointN(this.getNumPoints() - 1);
	},
	getDimension: function () {
		return 1;
	},
	getLength: function () {
		return __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeLength(this._points);
	},
	getNumPoints: function () {
		return this._points.size();
	},
	reverse: function () {
		var seq = this._points.copy();
		__WEBPACK_IMPORTED_MODULE_8__CoordinateSequences__["a" /* default */].reverse(seq);
		var revLine = this.getFactory().createLineString(seq);
		return revLine;
	},
	compareToSameClass: function () {
		if (arguments.length === 1) {
			let o = arguments[0];
			var line = o;
			var i = 0;
			var j = 0;
			while (i < this._points.size() && j < line._points.size()) {
				var comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
				if (comparison !== 0) {
					return comparison;
				}
				i++;
				j++;
			}
			if (i < this._points.size()) {
				return 1;
			}
			if (j < line._points.size()) {
				return -1;
			}
			return 0;
		} else if (arguments.length === 2) {
			let o = arguments[0], comp = arguments[1];
			var line = o;
			return comp.compare(this._points, line._points);
		}
	},
	apply: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_2__CoordinateFilter__["a" /* default */])) {
			let filter = arguments[0];
			for (var i = 0; i < this._points.size(); i++) {
				filter.filter(this._points.getCoordinate(i));
			}
		} else if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_12__CoordinateSequenceFilter__["a" /* default */])) {
			let filter = arguments[0];
			if (this._points.size() === 0) return null;
			for (var i = 0; i < this._points.size(); i++) {
				filter.filter(this._points, i);
				if (filter.isDone()) break;
			}
			if (filter.isGeometryChanged()) this.geometryChanged();
		} else if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_11__GeometryFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
		} else if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_9__GeometryComponentFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
		}
	},
	getBoundary: function () {
		return new __WEBPACK_IMPORTED_MODULE_4__operation_BoundaryOp__["a" /* default */](this).getBoundary();
	},
	isEquivalentClass: function (other) {
		return other instanceof LineString;
	},
	clone: function () {
		var ls = __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].prototype.clone.call(this);
		ls._points = this._points.clone();
		return ls;
	},
	getCoordinateN: function (n) {
		return this._points.getCoordinate(n);
	},
	getGeometryType: function () {
		return "LineString";
	},
	copy: function () {
		return new LineString(this._points.copy(), this._factory);
	},
	getCoordinateSequence: function () {
		return this._points;
	},
	isEmpty: function () {
		return this._points.size() === 0;
	},
	init: function (points) {
		if (points === null) {
			points = this.getFactory().getCoordinateSequenceFactory().create([]);
		}
		if (points.size() === 1) {
			throw new __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__["a" /* default */]("Invalid number of points in LineString (found " + points.size() + " - must be 0 or >= 2)");
		}
		this._points = points;
	},
	isCoordinate: function (pt) {
		for (var i = 0; i < this._points.size(); i++) {
			if (this._points.getCoordinate(i).equals(pt)) {
				return true;
			}
		}
		return false;
	},
	getStartPoint: function () {
		if (this.isEmpty()) {
			return null;
		}
		return this.getPointN(0);
	},
	getPointN: function (n) {
		return this.getFactory().createPoint(this._points.getCoordinate(n));
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_7__Lineal__["a" /* default */]];
	},
	getClass: function () {
		return LineString;
	}
});
LineString.serialVersionUID = 3110669828065365560;


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Location;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function Location() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Location.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Location;
	}
});
Location.toLocationSymbol = function (locationValue) {
	switch (locationValue) {
		case Location.EXTERIOR:
			return 'e';
		case Location.BOUNDARY:
			return 'b';
		case Location.INTERIOR:
			return 'i';
		case Location.NONE:
			return '-';
	}
	throw new __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__["a" /* default */]("Unknown location value: " + locationValue);
};
Location.INTERIOR = 0;
Location.BOUNDARY = 1;
Location.EXTERIOR = 2;
Location.NONE = -1;


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Double;
function Double () {}
Double.isNaN = n => Number.isNaN(n)
Double.doubleToLongBits = n => n
Double.longBitsToDouble = n => n
Double.isInfinite = n => !Number.isFinite(n)
Double.MAX_VALUE = Number.MAX_VALUE


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Geometry;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_Cloneable__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_Assert__ = __webpack_require__(4);








function Geometry() {
	this._envelope = null;
	this._factory = null;
	this._SRID = null;
	this._userData = null;
	let factory = arguments[0];
	this._factory = factory;
	this._SRID = factory.getSRID();
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Geometry.prototype, {
	isGeometryCollection: function () {
		return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;
	},
	getFactory: function () {
		return this._factory;
	},
	getGeometryN: function (n) {
		return this;
	},
	getArea: function () {
		return 0.0;
	},
	isRectangle: function () {
		return false;
	},
	equals: function () {
		if (arguments[0] instanceof Geometry) {
			let g = arguments[0];
			if (g === null) return false;
			return this.equalsTopo(g);
		} else if (arguments[0] instanceof Object) {
			let o = arguments[0];
			if (!(o instanceof Geometry)) return false;
			var g = o;
			return this.equalsExact(g);
		}
	},
	equalsExact: function (other) {
		return this === other || this.equalsExact(other, 0);
	},
	geometryChanged: function () {
		this.apply(Geometry.geometryChangedFilter);
	},
	geometryChangedAction: function () {
		this._envelope = null;
	},
	equalsNorm: function (g) {
		if (g === null) return false;
		return this.norm().equalsExact(g.norm());
	},
	getLength: function () {
		return 0.0;
	},
	getNumGeometries: function () {
		return 1;
	},
	compareTo: function () {
		if (arguments.length === 1) {
			let o = arguments[0];
			var other = o;
			if (this.getSortIndex() !== other.getSortIndex()) {
				return this.getSortIndex() - other.getSortIndex();
			}
			if (this.isEmpty() && other.isEmpty()) {
				return 0;
			}
			if (this.isEmpty()) {
				return -1;
			}
			if (other.isEmpty()) {
				return 1;
			}
			return this.compareToSameClass(o);
		} else if (arguments.length === 2) {
			let o = arguments[0], comp = arguments[1];
			var other = o;
			if (this.getSortIndex() !== other.getSortIndex()) {
				return this.getSortIndex() - other.getSortIndex();
			}
			if (this.isEmpty() && other.isEmpty()) {
				return 0;
			}
			if (this.isEmpty()) {
				return -1;
			}
			if (other.isEmpty()) {
				return 1;
			}
			return this.compareToSameClass(o, comp);
		}
	},
	getUserData: function () {
		return this._userData;
	},
	getSRID: function () {
		return this._SRID;
	},
	getEnvelope: function () {
		return this.getFactory().toGeometry(this.getEnvelopeInternal());
	},
	checkNotGeometryCollection: function (g) {
		if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
			throw new __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__["a" /* default */]("This method does not support GeometryCollection arguments");
		}
	},
	equal: function (a, b, tolerance) {
		if (tolerance === 0) {
			return a.equals(b);
		}
		return a.distance(b) <= tolerance;
	},
	norm: function () {
		var copy = this.copy();
		copy.normalize();
		return copy;
	},
	getPrecisionModel: function () {
		return this._factory.getPrecisionModel();
	},
	getEnvelopeInternal: function () {
		if (this._envelope === null) {
			this._envelope = this.computeEnvelopeInternal();
		}
		return new __WEBPACK_IMPORTED_MODULE_6__Envelope__["a" /* default */](this._envelope);
	},
	setSRID: function (SRID) {
		this._SRID = SRID;
	},
	setUserData: function (userData) {
		this._userData = userData;
	},
	compare: function (a, b) {
		var i = a.iterator();
		var j = b.iterator();
		while (i.hasNext() && j.hasNext()) {
			var aElement = i.next();
			var bElement = j.next();
			var comparison = aElement.compareTo(bElement);
			if (comparison !== 0) {
				return comparison;
			}
		}
		if (i.hasNext()) {
			return 1;
		}
		if (j.hasNext()) {
			return -1;
		}
		return 0;
	},
	hashCode: function () {
		return this.getEnvelopeInternal().hashCode();
	},
	isGeometryCollectionOrDerived: function () {
		if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
			return true;
		}
		return false;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__java_lang_Cloneable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return Geometry;
	}
});
Geometry.hasNonEmptyElements = function (geometries) {
	for (var i = 0; i < geometries.length; i++) {
		if (!geometries[i].isEmpty()) {
			return true;
		}
	}
	return false;
};
Geometry.hasNullElements = function (array) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === null) {
			return true;
		}
	}
	return false;
};
Geometry.serialVersionUID = 8763622679187376702;
Geometry.SORTINDEX_POINT = 0;
Geometry.SORTINDEX_MULTIPOINT = 1;
Geometry.SORTINDEX_LINESTRING = 2;
Geometry.SORTINDEX_LINEARRING = 3;
Geometry.SORTINDEX_MULTILINESTRING = 4;
Geometry.SORTINDEX_POLYGON = 5;
Geometry.SORTINDEX_MULTIPOLYGON = 6;
Geometry.SORTINDEX_GEOMETRYCOLLECTION = 7;
Geometry.geometryChangedFilter = {
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__GeometryComponentFilter__["a" /* default */]];
	},
	filter: function (geom) {
		geom.geometryChangedAction();
	}
};


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryCollection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CoordinateFilter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__GeometryFilter__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__CoordinateSequenceFilter__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__inherits__ = __webpack_require__(3);














function GeometryCollection() {
	this._geometries = null;
	let geometries = arguments[0], factory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].call(this, factory);
	if (geometries === null) {
		geometries = [];
	}
	if (__WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].hasNullElements(geometries)) {
		throw new __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__["a" /* default */]("geometries must not contain null elements");
	}
	this._geometries = geometries;
}
Object(__WEBPACK_IMPORTED_MODULE_13__inherits__["a" /* default */])(GeometryCollection, __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(GeometryCollection.prototype, {
	computeEnvelopeInternal: function () {
		var envelope = new __WEBPACK_IMPORTED_MODULE_11__Envelope__["a" /* default */]();
		for (var i = 0; i < this._geometries.length; i++) {
			envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
		}
		return envelope;
	},
	getGeometryN: function (n) {
		return this._geometries[n];
	},
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].SORTINDEX_GEOMETRYCOLLECTION;
	},
	getCoordinates: function () {
		var coordinates = new Array(this.getNumPoints()).fill(null);
		var k = -1;
		for (var i = 0; i < this._geometries.length; i++) {
			var childCoordinates = this._geometries[i].getCoordinates();
			for (var j = 0; j < childCoordinates.length; j++) {
				k++;
				coordinates[k] = childCoordinates[j];
			}
		}
		return coordinates;
	},
	getArea: function () {
		var area = 0.0;
		for (var i = 0; i < this._geometries.length; i++) {
			area += this._geometries[i].getArea();
		}
		return area;
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			var otherCollection = other;
			if (this._geometries.length !== otherCollection._geometries.length) {
				return false;
			}
			for (var i = 0; i < this._geometries.length; i++) {
				if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
					return false;
				}
			}
			return true;
		} else return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	normalize: function () {
		for (var i = 0; i < this._geometries.length; i++) {
			this._geometries[i].normalize();
		}
		__WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__["a" /* default */].sort(this._geometries);
	},
	getCoordinate: function () {
		if (this.isEmpty()) return null;
		return this._geometries[0].getCoordinate();
	},
	getBoundaryDimension: function () {
		var dimension = __WEBPACK_IMPORTED_MODULE_8__Dimension__["a" /* default */].FALSE;
		for (var i = 0; i < this._geometries.length; i++) {
			dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
		}
		return dimension;
	},
	getDimension: function () {
		var dimension = __WEBPACK_IMPORTED_MODULE_8__Dimension__["a" /* default */].FALSE;
		for (var i = 0; i < this._geometries.length; i++) {
			dimension = Math.max(dimension, this._geometries[i].getDimension());
		}
		return dimension;
	},
	getLength: function () {
		var sum = 0.0;
		for (var i = 0; i < this._geometries.length; i++) {
			sum += this._geometries[i].getLength();
		}
		return sum;
	},
	getNumPoints: function () {
		var numPoints = 0;
		for (var i = 0; i < this._geometries.length; i++) {
			numPoints += this._geometries[i].getNumPoints();
		}
		return numPoints;
	},
	getNumGeometries: function () {
		return this._geometries.length;
	},
	reverse: function () {
		var n = this._geometries.length;
		var revGeoms = new Array(n).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			revGeoms[i] = this._geometries[i].reverse();
		}
		return this.getFactory().createGeometryCollection(revGeoms);
	},
	compareToSameClass: function () {
		if (arguments.length === 1) {
			let o = arguments[0];
			var theseElements = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */](__WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__["a" /* default */].asList(this._geometries));
			var otherElements = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */](__WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__["a" /* default */].asList(o._geometries));
			return this.compare(theseElements, otherElements);
		} else if (arguments.length === 2) {
			let o = arguments[0], comp = arguments[1];
			var gc = o;
			var n1 = this.getNumGeometries();
			var n2 = gc.getNumGeometries();
			var i = 0;
			while (i < n1 && i < n2) {
				var thisGeom = this.getGeometryN(i);
				var otherGeom = gc.getGeometryN(i);
				var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
				if (holeComp !== 0) return holeComp;
				i++;
			}
			if (i < n1) return 1;
			if (i < n2) return -1;
			return 0;
		}
	},
	apply: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__CoordinateFilter__["a" /* default */])) {
			let filter = arguments[0];
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(filter);
			}
		} else if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_10__CoordinateSequenceFilter__["a" /* default */])) {
			let filter = arguments[0];
			if (this._geometries.length === 0) return null;
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(filter);
				if (filter.isDone()) {
					break;
				}
			}
			if (filter.isGeometryChanged()) this.geometryChanged();
		} else if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_9__GeometryFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(filter);
			}
		} else if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_7__GeometryComponentFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(filter);
			}
		}
	},
	getBoundary: function () {
		this.checkNotGeometryCollection(this);
		__WEBPACK_IMPORTED_MODULE_12__util_Assert__["a" /* default */].shouldNeverReachHere();
		return null;
	},
	clone: function () {
		var gc = __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].prototype.clone.call(this);
		gc._geometries = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			gc._geometries[i] = this._geometries[i].clone();
		}
		return gc;
	},
	getGeometryType: function () {
		return "GeometryCollection";
	},
	copy: function () {
		var geometries = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < geometries.length; i++) {
			geometries[i] = this._geometries[i].copy();
		}
		return new GeometryCollection(geometries, this._factory);
	},
	isEmpty: function () {
		for (var i = 0; i < this._geometries.length; i++) {
			if (!this._geometries[i].isEmpty()) {
				return false;
			}
		}
		return true;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryCollection;
	}
});
GeometryCollection.serialVersionUID = -5694727726395021467;


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineSegment;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_NotRepresentableException__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__algorithm_HCoordinate__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_io_Serializable__ = __webpack_require__(21);









function LineSegment() {
	this.p0 = null;
	this.p1 = null;
	if (arguments.length === 0) {
		LineSegment.call(this, new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */](), new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]());
	} else if (arguments.length === 1) {
		let ls = arguments[0];
		LineSegment.call(this, ls.p0, ls.p1);
	} else if (arguments.length === 2) {
		let p0 = arguments[0], p1 = arguments[1];
		this.p0 = p0;
		this.p1 = p1;
	} else if (arguments.length === 4) {
		let x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];
		LineSegment.call(this, new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */](x0, y0), new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */](x1, y1));
	}
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(LineSegment.prototype, {
	minX: function () {
		return Math.min(this.p0.x, this.p1.x);
	},
	orientationIndex: function () {
		if (arguments[0] instanceof LineSegment) {
			let seg = arguments[0];
			var orient0 = __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].orientationIndex(this.p0, this.p1, seg.p0);
			var orient1 = __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].orientationIndex(this.p0, this.p1, seg.p1);
			if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);
			if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);
			return 0;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]) {
			let p = arguments[0];
			return __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].orientationIndex(this.p0, this.p1, p);
		}
	},
	toGeometry: function (geomFactory) {
		return geomFactory.createLineString([this.p0, this.p1]);
	},
	isVertical: function () {
		return this.p0.x === this.p1.x;
	},
	equals: function (o) {
		if (!(o instanceof LineSegment)) {
			return false;
		}
		var other = o;
		return this.p0.equals(other.p0) && this.p1.equals(other.p1);
	},
	intersection: function (line) {
		var li = new __WEBPACK_IMPORTED_MODULE_6__algorithm_RobustLineIntersector__["a" /* default */]();
		li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
		if (li.hasIntersection()) return li.getIntersection(0);
		return null;
	},
	project: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]) {
			let p = arguments[0];
			if (p.equals(this.p0) || p.equals(this.p1)) return new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */](p);
			var r = this.projectionFactor(p);
			var coord = new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]();
			coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
			coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
			return coord;
		} else if (arguments[0] instanceof LineSegment) {
			let seg = arguments[0];
			var pf0 = this.projectionFactor(seg.p0);
			var pf1 = this.projectionFactor(seg.p1);
			if (pf0 >= 1.0 && pf1 >= 1.0) return null;
			if (pf0 <= 0.0 && pf1 <= 0.0) return null;
			var newp0 = this.project(seg.p0);
			if (pf0 < 0.0) newp0 = this.p0;
			if (pf0 > 1.0) newp0 = this.p1;
			var newp1 = this.project(seg.p1);
			if (pf1 < 0.0) newp1 = this.p0;
			if (pf1 > 1.0) newp1 = this.p1;
			return new LineSegment(newp0, newp1);
		}
	},
	normalize: function () {
		if (this.p1.compareTo(this.p0) < 0) this.reverse();
	},
	angle: function () {
		return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
	},
	getCoordinate: function (i) {
		if (i === 0) return this.p0;
		return this.p1;
	},
	distancePerpendicular: function (p) {
		return __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].distancePointLinePerpendicular(p, this.p0, this.p1);
	},
	minY: function () {
		return Math.min(this.p0.y, this.p1.y);
	},
	midPoint: function () {
		return LineSegment.midPoint(this.p0, this.p1);
	},
	projectionFactor: function (p) {
		if (p.equals(this.p0)) return 0.0;
		if (p.equals(this.p1)) return 1.0;
		var dx = this.p1.x - this.p0.x;
		var dy = this.p1.y - this.p0.y;
		var len = dx * dx + dy * dy;
		if (len <= 0.0) return __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].NaN;
		var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
		return r;
	},
	closestPoints: function (line) {
		var intPt = this.intersection(line);
		if (intPt !== null) {
			return [intPt, intPt];
		}
		var closestPt = new Array(2).fill(null);
		var minDistance = __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].MAX_VALUE;
		var dist = null;
		var close00 = this.closestPoint(line.p0);
		minDistance = close00.distance(line.p0);
		closestPt[0] = close00;
		closestPt[1] = line.p0;
		var close01 = this.closestPoint(line.p1);
		dist = close01.distance(line.p1);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = close01;
			closestPt[1] = line.p1;
		}
		var close10 = line.closestPoint(this.p0);
		dist = close10.distance(this.p0);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = this.p0;
			closestPt[1] = close10;
		}
		var close11 = line.closestPoint(this.p1);
		dist = close11.distance(this.p1);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = this.p1;
			closestPt[1] = close11;
		}
		return closestPt;
	},
	closestPoint: function (p) {
		var factor = this.projectionFactor(p);
		if (factor > 0 && factor < 1) {
			return this.project(p);
		}
		var dist0 = this.p0.distance(p);
		var dist1 = this.p1.distance(p);
		if (dist0 < dist1) return this.p0;
		return this.p1;
	},
	maxX: function () {
		return Math.max(this.p0.x, this.p1.x);
	},
	getLength: function () {
		return this.p0.distance(this.p1);
	},
	compareTo: function (o) {
		var other = o;
		var comp0 = this.p0.compareTo(other.p0);
		if (comp0 !== 0) return comp0;
		return this.p1.compareTo(other.p1);
	},
	reverse: function () {
		var temp = this.p0;
		this.p0 = this.p1;
		this.p1 = temp;
	},
	equalsTopo: function (other) {
		return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);
	},
	lineIntersection: function (line) {
		try {
			var intPt = __WEBPACK_IMPORTED_MODULE_7__algorithm_HCoordinate__["a" /* default */].intersection(this.p0, this.p1, line.p0, line.p1);
			return intPt;
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_0__algorithm_NotRepresentableException__["a" /* default */]) {} else throw ex;
		} finally {}
		return null;
	},
	maxY: function () {
		return Math.max(this.p0.y, this.p1.y);
	},
	pointAlongOffset: function (segmentLengthFraction, offsetDistance) {
		var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
		var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
		var dx = this.p1.x - this.p0.x;
		var dy = this.p1.y - this.p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = 0.0;
		var uy = 0.0;
		if (offsetDistance !== 0.0) {
			if (len <= 0.0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
			ux = offsetDistance * dx / len;
			uy = offsetDistance * dy / len;
		}
		var offsetx = segx - uy;
		var offsety = segy + ux;
		var coord = new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */](offsetx, offsety);
		return coord;
	},
	setCoordinates: function () {
		if (arguments.length === 1) {
			let ls = arguments[0];
			this.setCoordinates(ls.p0, ls.p1);
		} else if (arguments.length === 2) {
			let p0 = arguments[0], p1 = arguments[1];
			this.p0.x = p0.x;
			this.p0.y = p0.y;
			this.p1.x = p1.x;
			this.p1.y = p1.y;
		}
	},
	segmentFraction: function (inputPt) {
		var segFrac = this.projectionFactor(inputPt);
		if (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].isNaN(segFrac)) segFrac = 1.0;
		return segFrac;
	},
	toString: function () {
		return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
	},
	isHorizontal: function () {
		return this.p0.y === this.p1.y;
	},
	distance: function () {
		if (arguments[0] instanceof LineSegment) {
			let ls = arguments[0];
			return __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]) {
			let p = arguments[0];
			return __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].distancePointLine(p, this.p0, this.p1);
		}
	},
	pointAlong: function (segmentLengthFraction) {
		var coord = new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]();
		coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
		coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
		return coord;
	},
	hashCode: function () {
		var bits0 = java.lang.Double.doubleToLongBits(this.p0.x);
		bits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;
		var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
		var bits1 = java.lang.Double.doubleToLongBits(this.p1.x);
		bits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;
		var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
		return hash0 ^ hash1;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_5__java_lang_Comparable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_8__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return LineSegment;
	}
});
LineSegment.midPoint = function (p0, p1) {
	return new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
};
LineSegment.serialVersionUID = 3252005833466256227;


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CoordinateSequenceFactory__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_GeometryEditor__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__impl_CoordinateArraySequenceFactory__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__CoordinateSequences__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__CoordinateSequence__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__PrecisionModel__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__MultiLineString__ = __webpack_require__(28);



















function GeometryFactory() {
	this._precisionModel = null;
	this._coordinateSequenceFactory = null;
	this._SRID = null;
	if (arguments.length === 0) {
		GeometryFactory.call(this, new __WEBPACK_IMPORTED_MODULE_15__PrecisionModel__["a" /* default */](), 0);
	} else if (arguments.length === 1) {
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_0__CoordinateSequenceFactory__["a" /* default */])) {
			let coordinateSequenceFactory = arguments[0];
			GeometryFactory.call(this, new __WEBPACK_IMPORTED_MODULE_15__PrecisionModel__["a" /* default */](), 0, coordinateSequenceFactory);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_15__PrecisionModel__["a" /* default */]) {
			let precisionModel = arguments[0];
			GeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());
		}
	} else if (arguments.length === 2) {
		let precisionModel = arguments[0], SRID = arguments[1];
		GeometryFactory.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());
	} else if (arguments.length === 3) {
		let precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];
		this._precisionModel = precisionModel;
		this._coordinateSequenceFactory = coordinateSequenceFactory;
		this._SRID = SRID;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_9__extend__["a" /* default */])(GeometryFactory.prototype, {
	toGeometry: function (envelope) {
		if (envelope.isNull()) {
			return this.createPoint(null);
		}
		if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
			return this.createPoint(new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMinX(), envelope.getMinY()));
		}
		if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
			return this.createLineString([new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMinX(), envelope.getMinY()), new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMaxX(), envelope.getMaxY())]);
		}
		return this.createPolygon(this.createLinearRing([new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMinX(), envelope.getMinY()), new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMinX(), envelope.getMaxY()), new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMaxX(), envelope.getMaxY()), new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMaxX(), envelope.getMinY()), new __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */](envelope.getMinX(), envelope.getMinY())]), null);
	},
	createLineString: function () {
		if (arguments.length === 0) {
			return this.createLineString(this.getCoordinateSequenceFactory().create([]));
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				let coordinates = arguments[0];
				return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
			} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_13__CoordinateSequence__["a" /* default */])) {
				let coordinates = arguments[0];
				return new __WEBPACK_IMPORTED_MODULE_1__LineString__["a" /* default */](coordinates, this);
			}
		}
	},
	createMultiLineString: function () {
		if (arguments.length === 0) {
			return new __WEBPACK_IMPORTED_MODULE_18__MultiLineString__["a" /* default */](null, this);
		} else if (arguments.length === 1) {
			let lineStrings = arguments[0];
			return new __WEBPACK_IMPORTED_MODULE_18__MultiLineString__["a" /* default */](lineStrings, this);
		}
	},
	buildGeometry: function (geomList) {
		var geomClass = null;
		var isHeterogeneous = false;
		var hasGeometryCollection = false;
		for (var i = geomList.iterator(); i.hasNext(); ) {
			var geom = i.next();
			var partClass = geom.getClass();
			if (geomClass === null) {
				geomClass = partClass;
			}
			if (partClass !== geomClass) {
				isHeterogeneous = true;
			}
			if (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;
		}
		if (geomClass === null) {
			return this.createGeometryCollection();
		}
		if (isHeterogeneous || hasGeometryCollection) {
			return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
		}
		var geom0 = geomList.iterator().next();
		var isCollection = geomList.size() > 1;
		if (isCollection) {
			if (geom0 instanceof __WEBPACK_IMPORTED_MODULE_5__Polygon__["a" /* default */]) {
				return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
			} else if (geom0 instanceof __WEBPACK_IMPORTED_MODULE_1__LineString__["a" /* default */]) {
				return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
			} else if (geom0 instanceof __WEBPACK_IMPORTED_MODULE_4__Point__["a" /* default */]) {
				return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
			}
			__WEBPACK_IMPORTED_MODULE_17__util_Assert__["a" /* default */].shouldNeverReachHere("Unhandled class: " + geom0.getClass().getName());
		}
		return geom0;
	},
	createMultiPointFromCoords: function (coordinates) {
		return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
	},
	createPoint: function () {
		if (arguments.length === 0) {
			return this.createPoint(this.getCoordinateSequenceFactory().create([]));
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__Coordinate__["a" /* default */]) {
				let coordinate = arguments[0];
				return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);
			} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_13__CoordinateSequence__["a" /* default */])) {
				let coordinates = arguments[0];
				return new __WEBPACK_IMPORTED_MODULE_4__Point__["a" /* default */](coordinates, this);
			}
		}
	},
	getCoordinateSequenceFactory: function () {
		return this._coordinateSequenceFactory;
	},
	createPolygon: function () {
		if (arguments.length === 0) {
			return new __WEBPACK_IMPORTED_MODULE_5__Polygon__["a" /* default */](null, null, this);
		} else if (arguments.length === 1) {
			if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_13__CoordinateSequence__["a" /* default */])) {
				let coordinates = arguments[0];
				return this.createPolygon(this.createLinearRing(coordinates));
			} else if (arguments[0] instanceof Array) {
				let coordinates = arguments[0];
				return this.createPolygon(this.createLinearRing(coordinates));
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_8__LinearRing__["a" /* default */]) {
				let shell = arguments[0];
				return this.createPolygon(shell, null);
			}
		} else if (arguments.length === 2) {
			let shell = arguments[0], holes = arguments[1];
			return new __WEBPACK_IMPORTED_MODULE_5__Polygon__["a" /* default */](shell, holes, this);
		}
	},
	getSRID: function () {
		return this._SRID;
	},
	createGeometryCollection: function () {
		if (arguments.length === 0) {
			return new __WEBPACK_IMPORTED_MODULE_14__GeometryCollection__["a" /* default */](null, this);
		} else if (arguments.length === 1) {
			let geometries = arguments[0];
			return new __WEBPACK_IMPORTED_MODULE_14__GeometryCollection__["a" /* default */](geometries, this);
		}
	},
	createGeometry: function (g) {
		var editor = new __WEBPACK_IMPORTED_MODULE_7__util_GeometryEditor__["a" /* default */](this);
		return editor.edit(g, {
			edit: function () {
				if (arguments.length === 2) {
					let coordSeq = arguments[0], geometry = arguments[1];
					return this._coordinateSequenceFactory.create(coordSeq);
				}
			}
		});
	},
	getPrecisionModel: function () {
		return this._precisionModel;
	},
	createLinearRing: function () {
		if (arguments.length === 0) {
			return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				let coordinates = arguments[0];
				return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
			} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_13__CoordinateSequence__["a" /* default */])) {
				let coordinates = arguments[0];
				return new __WEBPACK_IMPORTED_MODULE_8__LinearRing__["a" /* default */](coordinates, this);
			}
		}
	},
	createMultiPolygon: function () {
		if (arguments.length === 0) {
			return new __WEBPACK_IMPORTED_MODULE_11__MultiPolygon__["a" /* default */](null, this);
		} else if (arguments.length === 1) {
			let polygons = arguments[0];
			return new __WEBPACK_IMPORTED_MODULE_11__MultiPolygon__["a" /* default */](polygons, this);
		}
	},
	createMultiPoint: function () {
		if (arguments.length === 0) {
			return new __WEBPACK_IMPORTED_MODULE_6__MultiPoint__["a" /* default */](null, this);
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				let point = arguments[0];
				return new __WEBPACK_IMPORTED_MODULE_6__MultiPoint__["a" /* default */](point, this);
			} else if (arguments[0] instanceof Array) {
				let coordinates = arguments[0];
				return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
			} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_13__CoordinateSequence__["a" /* default */])) {
				let coordinates = arguments[0];
				if (coordinates === null) {
					return this.createMultiPoint(new Array(0).fill(null));
				}
				var points = new Array(coordinates.size()).fill(null);
				for (var i = 0; i < coordinates.size(); i++) {
					var ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());
					__WEBPACK_IMPORTED_MODULE_12__CoordinateSequences__["a" /* default */].copy(coordinates, i, ptSeq, 0, 1);
					points[i] = this.createPoint(ptSeq);
				}
				return this.createMultiPoint(points);
			}
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_16__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return GeometryFactory;
	}
});
GeometryFactory.toMultiPolygonArray = function (multiPolygons) {
	var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
	return multiPolygons.toArray(multiPolygonArray);
};
GeometryFactory.toGeometryArray = function (geometries) {
	if (geometries === null) return null;
	var geometryArray = new Array(geometries.size()).fill(null);
	return geometries.toArray(geometryArray);
};
GeometryFactory.getDefaultCoordinateSequenceFactory = function () {
	return __WEBPACK_IMPORTED_MODULE_10__impl_CoordinateArraySequenceFactory__["a" /* default */].instance();
};
GeometryFactory.toMultiLineStringArray = function (multiLineStrings) {
	var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
	return multiLineStrings.toArray(multiLineStringArray);
};
GeometryFactory.toLineStringArray = function (lineStrings) {
	var lineStringArray = new Array(lineStrings.size()).fill(null);
	return lineStrings.toArray(lineStringArray);
};
GeometryFactory.toMultiPointArray = function (multiPoints) {
	var multiPointArray = new Array(multiPoints.size()).fill(null);
	return multiPoints.toArray(multiPointArray);
};
GeometryFactory.toLinearRingArray = function (linearRings) {
	var linearRingArray = new Array(linearRings.size()).fill(null);
	return linearRings.toArray(linearRingArray);
};
GeometryFactory.toPointArray = function (points) {
	var pointArray = new Array(points.size()).fill(null);
	return points.toArray(pointArray);
};
GeometryFactory.toPolygonArray = function (polygons) {
	var polygonArray = new Array(polygons.size()).fill(null);
	return polygons.toArray(polygonArray);
};
GeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {
	exemplar.getPrecisionModel().makePrecise(coord);
	return exemplar.getFactory().createPoint(coord);
};
GeometryFactory.serialVersionUID = -6820524753094095635;


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Polygon;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CoordinateFilter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__GeometryFilter__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__CoordinateSequenceFilter__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__inherits__ = __webpack_require__(3);














function Polygon() {
	this._shell = null;
	this._holes = null;
	let shell = arguments[0], holes = arguments[1], factory = arguments[2];
	__WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].call(this, factory);
	if (shell === null) {
		shell = this.getFactory().createLinearRing();
	}
	if (holes === null) {
		holes = [];
	}
	if (__WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].hasNullElements(holes)) {
		throw new __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__["a" /* default */]("holes must not contain null elements");
	}
	if (shell.isEmpty() && __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].hasNonEmptyElements(holes)) {
		throw new __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__["a" /* default */]("shell is empty but holes are not");
	}
	this._shell = shell;
	this._holes = holes;
}
Object(__WEBPACK_IMPORTED_MODULE_13__inherits__["a" /* default */])(Polygon, __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(Polygon.prototype, {
	computeEnvelopeInternal: function () {
		return this._shell.getEnvelopeInternal();
	},
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].SORTINDEX_POLYGON;
	},
	getCoordinates: function () {
		if (this.isEmpty()) {
			return [];
		}
		var coordinates = new Array(this.getNumPoints()).fill(null);
		var k = -1;
		var shellCoordinates = this._shell.getCoordinates();
		for (var x = 0; x < shellCoordinates.length; x++) {
			k++;
			coordinates[k] = shellCoordinates[x];
		}
		for (var i = 0; i < this._holes.length; i++) {
			var childCoordinates = this._holes[i].getCoordinates();
			for (var j = 0; j < childCoordinates.length; j++) {
				k++;
				coordinates[k] = childCoordinates[j];
			}
		}
		return coordinates;
	},
	getArea: function () {
		var area = 0.0;
		area += Math.abs(__WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].signedArea(this._shell.getCoordinateSequence()));
		for (var i = 0; i < this._holes.length; i++) {
			area -= Math.abs(__WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].signedArea(this._holes[i].getCoordinateSequence()));
		}
		return area;
	},
	isRectangle: function () {
		if (this.getNumInteriorRing() !== 0) return false;
		if (this._shell === null) return false;
		if (this._shell.getNumPoints() !== 5) return false;
		var seq = this._shell.getCoordinateSequence();
		var env = this.getEnvelopeInternal();
		for (var i = 0; i < 5; i++) {
			var x = seq.getX(i);
			if (!(x === env.getMinX() || x === env.getMaxX())) return false;
			var y = seq.getY(i);
			if (!(y === env.getMinY() || y === env.getMaxY())) return false;
		}
		var prevX = seq.getX(0);
		var prevY = seq.getY(0);
		for (var i = 1; i <= 4; i++) {
			var x = seq.getX(i);
			var y = seq.getY(i);
			var xChanged = x !== prevX;
			var yChanged = y !== prevY;
			if (xChanged === yChanged) return false;
			prevX = x;
			prevY = y;
		}
		return true;
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			var otherPolygon = other;
			var thisShell = this._shell;
			var otherPolygonShell = otherPolygon._shell;
			if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
				return false;
			}
			if (this._holes.length !== otherPolygon._holes.length) {
				return false;
			}
			for (var i = 0; i < this._holes.length; i++) {
				if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
					return false;
				}
			}
			return true;
		} else return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	normalize: function () {
		if (arguments.length === 0) {
			this.normalize(this._shell, true);
			for (var i = 0; i < this._holes.length; i++) {
				this.normalize(this._holes[i], false);
			}
			__WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__["a" /* default */].sort(this._holes);
		} else if (arguments.length === 2) {
			let ring = arguments[0], clockwise = arguments[1];
			if (ring.isEmpty()) {
				return null;
			}
			var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
			__WEBPACK_IMPORTED_MODULE_7__java_lang_System__["a" /* default */].arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
			var minCoordinate = __WEBPACK_IMPORTED_MODULE_9__CoordinateArrays__["a" /* default */].minCoordinate(ring.getCoordinates());
			__WEBPACK_IMPORTED_MODULE_9__CoordinateArrays__["a" /* default */].scroll(uniqueCoordinates, minCoordinate);
			__WEBPACK_IMPORTED_MODULE_7__java_lang_System__["a" /* default */].arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
			ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
			if (__WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].isCCW(ring.getCoordinates()) === clockwise) {
				__WEBPACK_IMPORTED_MODULE_9__CoordinateArrays__["a" /* default */].reverse(ring.getCoordinates());
			}
		}
	},
	getCoordinate: function () {
		return this._shell.getCoordinate();
	},
	getNumInteriorRing: function () {
		return this._holes.length;
	},
	getBoundaryDimension: function () {
		return 1;
	},
	getDimension: function () {
		return 2;
	},
	getLength: function () {
		var len = 0.0;
		len += this._shell.getLength();
		for (var i = 0; i < this._holes.length; i++) {
			len += this._holes[i].getLength();
		}
		return len;
	},
	getNumPoints: function () {
		var numPoints = this._shell.getNumPoints();
		for (var i = 0; i < this._holes.length; i++) {
			numPoints += this._holes[i].getNumPoints();
		}
		return numPoints;
	},
	reverse: function () {
		var poly = this.copy();
		poly._shell = this._shell.copy().reverse();
		poly._holes = new Array(this._holes.length).fill(null);
		for (var i = 0; i < this._holes.length; i++) {
			poly._holes[i] = this._holes[i].copy().reverse();
		}
		return poly;
	},
	convexHull: function () {
		return this.getExteriorRing().convexHull();
	},
	compareToSameClass: function () {
		if (arguments.length === 1) {
			let o = arguments[0];
			var thisShell = this._shell;
			var otherShell = o._shell;
			return thisShell.compareToSameClass(otherShell);
		} else if (arguments.length === 2) {
			let o = arguments[0], comp = arguments[1];
			var poly = o;
			var thisShell = this._shell;
			var otherShell = poly._shell;
			var shellComp = thisShell.compareToSameClass(otherShell, comp);
			if (shellComp !== 0) return shellComp;
			var nHole1 = this.getNumInteriorRing();
			var nHole2 = poly.getNumInteriorRing();
			var i = 0;
			while (i < nHole1 && i < nHole2) {
				var thisHole = this.getInteriorRingN(i);
				var otherHole = poly.getInteriorRingN(i);
				var holeComp = thisHole.compareToSameClass(otherHole, comp);
				if (holeComp !== 0) return holeComp;
				i++;
			}
			if (i < nHole1) return 1;
			if (i < nHole2) return -1;
			return 0;
		}
	},
	apply: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__CoordinateFilter__["a" /* default */])) {
			let filter = arguments[0];
			this._shell.apply(filter);
			for (var i = 0; i < this._holes.length; i++) {
				this._holes[i].apply(filter);
			}
		} else if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_12__CoordinateSequenceFilter__["a" /* default */])) {
			let filter = arguments[0];
			this._shell.apply(filter);
			if (!filter.isDone()) {
				for (var i = 0; i < this._holes.length; i++) {
					this._holes[i].apply(filter);
					if (filter.isDone()) break;
				}
			}
			if (filter.isGeometryChanged()) this.geometryChanged();
		} else if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_11__GeometryFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
		} else if (Object(__WEBPACK_IMPORTED_MODULE_4__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_8__GeometryComponentFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
			this._shell.apply(filter);
			for (var i = 0; i < this._holes.length; i++) {
				this._holes[i].apply(filter);
			}
		}
	},
	getBoundary: function () {
		if (this.isEmpty()) {
			return this.getFactory().createMultiLineString();
		}
		var rings = new Array(this._holes.length + 1).fill(null);
		rings[0] = this._shell;
		for (var i = 0; i < this._holes.length; i++) {
			rings[i + 1] = this._holes[i];
		}
		if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
		return this.getFactory().createMultiLineString(rings);
	},
	clone: function () {
		var poly = __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].prototype.clone.call(this);
		poly._shell = this._shell.clone();
		poly._holes = new Array(this._holes.length).fill(null);
		for (var i = 0; i < this._holes.length; i++) {
			poly._holes[i] = this._holes[i].clone();
		}
		return poly;
	},
	getGeometryType: function () {
		return "Polygon";
	},
	copy: function () {
		var shell = this._shell.copy();
		var holes = new Array(this._holes.length).fill(null);
		for (var i = 0; i < holes.length; i++) {
			holes[i] = this._holes[i].copy();
		}
		return new Polygon(shell, holes, this._factory);
	},
	getExteriorRing: function () {
		return this._shell;
	},
	isEmpty: function () {
		return this._shell.isEmpty();
	},
	getInteriorRingN: function (n) {
		return this._holes[n];
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_10__Polygonal__["a" /* default */]];
	},
	getClass: function () {
		return Polygon;
	}
});
Polygon.serialVersionUID = -3494792200821764533;


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Position;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Position() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Position.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Position;
	}
});
Position.opposite = function (position) {
	if (position === Position.LEFT) return Position.RIGHT;
	if (position === Position.RIGHT) return Position.LEFT;
	return position;
};
Position.ON = 0;
Position.LEFT = 1;
Position.RIGHT = 2;


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateList;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);




function CoordinateList() {
	__WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */].apply(this);
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let coord = arguments[0];
		this.ensureCapacity(coord.length);
		this.add(coord, true);
	} else if (arguments.length === 2) {
		let coord = arguments[0], allowRepeated = arguments[1];
		this.ensureCapacity(coord.length);
		this.add(coord, allowRepeated);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(CoordinateList, __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(CoordinateList.prototype, {
	getCoordinate: function (i) {
		return this.get(i);
	},
	addAll: function () {
		if (arguments.length === 2) {
			let coll = arguments[0], allowRepeated = arguments[1];
			var isChanged = false;
			for (var i = coll.iterator(); i.hasNext(); ) {
				this.add(i.next(), allowRepeated);
				isChanged = true;
			}
			return isChanged;
		} else return __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */].prototype.addAll.apply(this, arguments);
	},
	clone: function () {
		var clone = __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */].prototype.clone.call(this);
		for (var i = 0; i < this.size(); i++) {
			clone.add(i, this.get(i).copy());
		}
		return clone;
	},
	toCoordinateArray: function () {
		return this.toArray(CoordinateList.coordArrayType);
	},
	add: function () {
		if (arguments.length === 1) {
			let coord = arguments[0];
			__WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */].prototype.add.call(this, coord);
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof Array && typeof arguments[1] === "boolean") {
				let coord = arguments[0], allowRepeated = arguments[1];
				this.add(coord, allowRepeated, true);
				return true;
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */] && typeof arguments[1] === "boolean") {
				let coord = arguments[0], allowRepeated = arguments[1];
				if (!allowRepeated) {
					if (this.size() >= 1) {
						var last = this.get(this.size() - 1);
						if (last.equals2D(coord)) return null;
					}
				}
				__WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */].prototype.add.call(this, coord);
			} else if (arguments[0] instanceof Object && typeof arguments[1] === "boolean") {
				let obj = arguments[0], allowRepeated = arguments[1];
				this.add(obj, allowRepeated);
				return true;
			}
		} else if (arguments.length === 3) {
			if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Array && typeof arguments[1] === "boolean")) {
				let coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];
				if (direction) {
					for (var i = 0; i < coord.length; i++) {
						this.add(coord[i], allowRepeated);
					}
				} else {
					for (var i = coord.length - 1; i >= 0; i--) {
						this.add(coord[i], allowRepeated);
					}
				}
				return true;
			} else if (typeof arguments[2] === "boolean" && (Number.isInteger(arguments[0]) && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */])) {
				let i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];
				if (!allowRepeated) {
					var size = this.size();
					if (size > 0) {
						if (i > 0) {
							var prev = this.get(i - 1);
							if (prev.equals2D(coord)) return null;
						}
						if (i < size) {
							var next = this.get(i);
							if (next.equals2D(coord)) return null;
						}
					}
				}
				__WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */].prototype.add.call(this, i, coord);
			}
		} else if (arguments.length === 4) {
			let coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];
			var inc = 1;
			if (start > end) inc = -1;
			for (var i = start; i !== end; i += inc) {
				this.add(coord[i], allowRepeated);
			}
			return true;
		}
	},
	closeRing: function () {
		if (this.size() > 0) this.add(new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */](this.get(0)), false);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CoordinateList;
	}
});
CoordinateList.coordArrayType = new Array(0).fill(null);


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateArrays;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_MathUtil__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_Comparator__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Envelope__ = __webpack_require__(7);







function CoordinateArrays() {}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(CoordinateArrays.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CoordinateArrays;
	}
});
CoordinateArrays.isRing = function (pts) {
	if (pts.length < 4) return false;
	if (!pts[0].equals2D(pts[pts.length - 1])) return false;
	return true;
};
CoordinateArrays.ptNotInList = function (testPts, pts) {
	for (var i = 0; i < testPts.length; i++) {
		var testPt = testPts[i];
		if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;
	}
	return null;
};
CoordinateArrays.scroll = function (coordinates, firstCoordinate) {
	var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
	if (i < 0) return null;
	var newCoordinates = new Array(coordinates.length).fill(null);
	__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
	__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
	__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
};
CoordinateArrays.equals = function () {
	if (arguments.length === 2) {
		let coord1 = arguments[0], coord2 = arguments[1];
		if (coord1 === coord2) return true;
		if (coord1 === null || coord2 === null) return false;
		if (coord1.length !== coord2.length) return false;
		for (var i = 0; i < coord1.length; i++) {
			if (!coord1[i].equals(coord2[i])) return false;
		}
		return true;
	} else if (arguments.length === 3) {
		let coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];
		if (coord1 === coord2) return true;
		if (coord1 === null || coord2 === null) return false;
		if (coord1.length !== coord2.length) return false;
		for (var i = 0; i < coord1.length; i++) {
			if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;
		}
		return true;
	}
};
CoordinateArrays.intersection = function (coordinates, env) {
	var coordList = new __WEBPACK_IMPORTED_MODULE_0__CoordinateList__["a" /* default */]();
	for (var i = 0; i < coordinates.length; i++) {
		if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
	}
	return coordList.toCoordinateArray();
};
CoordinateArrays.hasRepeatedPoints = function (coord) {
	for (var i = 1; i < coord.length; i++) {
		if (coord[i - 1].equals(coord[i])) {
			return true;
		}
	}
	return false;
};
CoordinateArrays.removeRepeatedPoints = function (coord) {
	if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;
	var coordList = new __WEBPACK_IMPORTED_MODULE_0__CoordinateList__["a" /* default */](coord, false);
	return coordList.toCoordinateArray();
};
CoordinateArrays.reverse = function (coord) {
	var last = coord.length - 1;
	var mid = Math.trunc(last / 2);
	for (var i = 0; i <= mid; i++) {
		var tmp = coord[i];
		coord[i] = coord[last - i];
		coord[last - i] = tmp;
	}
};
CoordinateArrays.removeNull = function (coord) {
	var nonNull = 0;
	for (var i = 0; i < coord.length; i++) {
		if (coord[i] !== null) nonNull++;
	}
	var newCoord = new Array(nonNull).fill(null);
	if (nonNull === 0) return newCoord;
	var j = 0;
	for (var i = 0; i < coord.length; i++) {
		if (coord[i] !== null) newCoord[j++] = coord[i];
	}
	return newCoord;
};
CoordinateArrays.copyDeep = function () {
	if (arguments.length === 1) {
		let coordinates = arguments[0];
		var copy = new Array(coordinates.length).fill(null);
		for (var i = 0; i < coordinates.length; i++) {
			copy[i] = new __WEBPACK_IMPORTED_MODULE_1__Coordinate__["a" /* default */](coordinates[i]);
		}
		return copy;
	} else if (arguments.length === 5) {
		let src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];
		for (var i = 0; i < length; i++) {
			dest[destStart + i] = new __WEBPACK_IMPORTED_MODULE_1__Coordinate__["a" /* default */](src[srcStart + i]);
		}
	}
};
CoordinateArrays.isEqualReversed = function (pts1, pts2) {
	for (var i = 0; i < pts1.length; i++) {
		var p1 = pts1[i];
		var p2 = pts2[pts1.length - i - 1];
		if (p1.compareTo(p2) !== 0) return false;
	}
	return true;
};
CoordinateArrays.envelope = function (coordinates) {
	var env = new __WEBPACK_IMPORTED_MODULE_6__Envelope__["a" /* default */]();
	for (var i = 0; i < coordinates.length; i++) {
		env.expandToInclude(coordinates[i]);
	}
	return env;
};
CoordinateArrays.toCoordinateArray = function (coordList) {
	return coordList.toArray(CoordinateArrays.coordArrayType);
};
CoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {
	return c.length >= n ? c : [];
};
CoordinateArrays.indexOf = function (coordinate, coordinates) {
	for (var i = 0; i < coordinates.length; i++) {
		if (coordinate.equals(coordinates[i])) {
			return i;
		}
	}
	return -1;
};
CoordinateArrays.increasingDirection = function (pts) {
	for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
		var j = pts.length - 1 - i;
		var comp = pts[i].compareTo(pts[j]);
		if (comp !== 0) return comp;
	}
	return 1;
};
CoordinateArrays.compare = function (pts1, pts2) {
	var i = 0;
	while (i < pts1.length && i < pts2.length) {
		var compare = pts1[i].compareTo(pts2[i]);
		if (compare !== 0) return compare;
		i++;
	}
	if (i < pts2.length) return -1;
	if (i < pts1.length) return 1;
	return 0;
};
CoordinateArrays.minCoordinate = function (coordinates) {
	var minCoord = null;
	for (var i = 0; i < coordinates.length; i++) {
		if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
			minCoord = coordinates[i];
		}
	}
	return minCoord;
};
CoordinateArrays.extract = function (pts, start, end) {
	start = __WEBPACK_IMPORTED_MODULE_3__math_MathUtil__["a" /* default */].clamp(start, 0, pts.length);
	end = __WEBPACK_IMPORTED_MODULE_3__math_MathUtil__["a" /* default */].clamp(end, -1, pts.length);
	var npts = end - start + 1;
	if (end < 0) npts = 0;
	if (start >= pts.length) npts = 0;
	if (end < start) npts = 0;
	var extractPts = new Array(npts).fill(null);
	if (npts === 0) return extractPts;
	var iPts = 0;
	for (var i = start; i <= end; i++) {
		extractPts[iPts++] = pts[i];
	}
	return extractPts;
};
function ForwardComparator() {}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(ForwardComparator.prototype, {
	compare: function (o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		return CoordinateArrays.compare(pts1, pts2);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_5__java_util_Comparator__["a" /* default */]];
	},
	getClass: function () {
		return ForwardComparator;
	}
});
function BidirectionalComparator() {}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(BidirectionalComparator.prototype, {
	compare: function (o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		if (pts1.length < pts2.length) return -1;
		if (pts1.length > pts2.length) return 1;
		if (pts1.length === 0) return 0;
		var forwardComp = CoordinateArrays.compare(pts1, pts2);
		var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
		if (isEqualRev) return 0;
		return forwardComp;
	},
	OLDcompare: function (o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		if (pts1.length < pts2.length) return -1;
		if (pts1.length > pts2.length) return 1;
		if (pts1.length === 0) return 0;
		var dir1 = CoordinateArrays.increasingDirection(pts1);
		var dir2 = CoordinateArrays.increasingDirection(pts2);
		var i1 = dir1 > 0 ? 0 : pts1.length - 1;
		var i2 = dir2 > 0 ? 0 : pts1.length - 1;
		for (var i = 0; i < pts1.length; i++) {
			var comparePt = pts1[i1].compareTo(pts2[i2]);
			if (comparePt !== 0) return comparePt;
			i1 += dir1;
			i2 += dir2;
		}
		return 0;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_5__java_util_Comparator__["a" /* default */]];
	},
	getClass: function () {
		return BidirectionalComparator;
	}
});
CoordinateArrays.ForwardComparator = ForwardComparator;
CoordinateArrays.BidirectionalComparator = BidirectionalComparator;
CoordinateArrays.coordArrayType = new Array(0).fill(null);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Comparable;
function Comparable () {}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Serializable;
function Serializable () {}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RobustLineIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NotRepresentableException__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CGAlgorithmsDD__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__HCoordinate__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__LineIntersector__ = __webpack_require__(209);










function RobustLineIntersector() {
	__WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_8__inherits__["a" /* default */])(RobustLineIntersector, __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(RobustLineIntersector.prototype, {
	isInSegmentEnvelopes: function (intPt) {
		var env0 = new __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */](this._inputLines[0][0], this._inputLines[0][1]);
		var env1 = new __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */](this._inputLines[1][0], this._inputLines[1][1]);
		return env0.contains(intPt) && env1.contains(intPt);
	},
	computeIntersection: function () {
		if (arguments.length === 3) {
			let p = arguments[0], p1 = arguments[1], p2 = arguments[2];
			this._isProper = false;
			if (__WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */].intersects(p1, p2, p)) {
				if (__WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].orientationIndex(p1, p2, p) === 0 && __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].orientationIndex(p2, p1, p) === 0) {
					this._isProper = true;
					if (p.equals(p1) || p.equals(p2)) {
						this._isProper = false;
					}
					this._result = __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].POINT_INTERSECTION;
					return null;
				}
			}
			this._result = __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].NO_INTERSECTION;
		} else return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].prototype.computeIntersection.apply(this, arguments);
	},
	normalizeToMinimum: function (n1, n2, n3, n4, normPt) {
		normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
		normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
		n1.x -= normPt.x;
		n1.y -= normPt.y;
		n2.x -= normPt.x;
		n2.y -= normPt.y;
		n3.x -= normPt.x;
		n3.y -= normPt.y;
		n4.x -= normPt.x;
		n4.y -= normPt.y;
	},
	safeHCoordinateIntersection: function (p1, p2, q1, q2) {
		var intPt = null;
		try {
			intPt = __WEBPACK_IMPORTED_MODULE_6__HCoordinate__["a" /* default */].intersection(p1, p2, q1, q2);
		} catch (e) {
			if (e instanceof __WEBPACK_IMPORTED_MODULE_0__NotRepresentableException__["a" /* default */]) {
				intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
			} else throw e;
		} finally {}
		return intPt;
	},
	intersection: function (p1, p2, q1, q2) {
		var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
		if (!this.isInSegmentEnvelopes(intPt)) {
			intPt = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
		}
		if (this._precisionModel !== null) {
			this._precisionModel.makePrecise(intPt);
		}
		return intPt;
	},
	smallestInAbsValue: function (x1, x2, x3, x4) {
		var x = x1;
		var xabs = Math.abs(x);
		if (Math.abs(x2) < xabs) {
			x = x2;
			xabs = Math.abs(x2);
		}
		if (Math.abs(x3) < xabs) {
			x = x3;
			xabs = Math.abs(x3);
		}
		if (Math.abs(x4) < xabs) {
			x = x4;
		}
		return x;
	},
	checkDD: function (p1, p2, q1, q2, intPt) {
		var intPtDD = __WEBPACK_IMPORTED_MODULE_4__CGAlgorithmsDD__["a" /* default */].intersection(p1, p2, q1, q2);
		var isIn = this.isInSegmentEnvelopes(intPtDD);
		__WEBPACK_IMPORTED_MODULE_5__java_lang_System__["a" /* default */].out.println("DD in env = " + isIn + "  --------------------- " + intPtDD);
		if (intPt.distance(intPtDD) > 0.0001) {
			__WEBPACK_IMPORTED_MODULE_5__java_lang_System__["a" /* default */].out.println("Distance = " + intPt.distance(intPtDD));
		}
	},
	intersectionWithNormalization: function (p1, p2, q1, q2) {
		var n1 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](p1);
		var n2 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](p2);
		var n3 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](q1);
		var n4 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](q2);
		var normPt = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
		this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
		var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
		intPt.x += normPt.x;
		intPt.y += normPt.y;
		return intPt;
	},
	computeCollinearIntersection: function (p1, p2, q1, q2) {
		var p1q1p2 = __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */].intersects(p1, p2, q1);
		var p1q2p2 = __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */].intersects(p1, p2, q2);
		var q1p1q2 = __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */].intersects(q1, q2, p1);
		var q1p2q2 = __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */].intersects(q1, q2, p2);
		if (p1q1p2 && p1q2p2) {
			this._intPt[0] = q1;
			this._intPt[1] = q2;
			return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].COLLINEAR_INTERSECTION;
		}
		if (q1p1q2 && q1p2q2) {
			this._intPt[0] = p1;
			this._intPt[1] = p2;
			return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].COLLINEAR_INTERSECTION;
		}
		if (p1q1p2 && q1p1q2) {
			this._intPt[0] = q1;
			this._intPt[1] = p1;
			return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].POINT_INTERSECTION : __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].COLLINEAR_INTERSECTION;
		}
		if (p1q1p2 && q1p2q2) {
			this._intPt[0] = q1;
			this._intPt[1] = p2;
			return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].POINT_INTERSECTION : __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].COLLINEAR_INTERSECTION;
		}
		if (p1q2p2 && q1p1q2) {
			this._intPt[0] = q2;
			this._intPt[1] = p1;
			return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].POINT_INTERSECTION : __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].COLLINEAR_INTERSECTION;
		}
		if (p1q2p2 && q1p2q2) {
			this._intPt[0] = q2;
			this._intPt[1] = p2;
			return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].POINT_INTERSECTION : __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].COLLINEAR_INTERSECTION;
		}
		return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].NO_INTERSECTION;
	},
	normalizeToEnvCentre: function (n00, n01, n10, n11, normPt) {
		var minX0 = n00.x < n01.x ? n00.x : n01.x;
		var minY0 = n00.y < n01.y ? n00.y : n01.y;
		var maxX0 = n00.x > n01.x ? n00.x : n01.x;
		var maxY0 = n00.y > n01.y ? n00.y : n01.y;
		var minX1 = n10.x < n11.x ? n10.x : n11.x;
		var minY1 = n10.y < n11.y ? n10.y : n11.y;
		var maxX1 = n10.x > n11.x ? n10.x : n11.x;
		var maxY1 = n10.y > n11.y ? n10.y : n11.y;
		var intMinX = minX0 > minX1 ? minX0 : minX1;
		var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
		var intMinY = minY0 > minY1 ? minY0 : minY1;
		var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
		var intMidX = (intMinX + intMaxX) / 2.0;
		var intMidY = (intMinY + intMaxY) / 2.0;
		normPt.x = intMidX;
		normPt.y = intMidY;
		n00.x -= normPt.x;
		n00.y -= normPt.y;
		n01.x -= normPt.x;
		n01.y -= normPt.y;
		n10.x -= normPt.x;
		n10.y -= normPt.y;
		n11.x -= normPt.x;
		n11.y -= normPt.y;
	},
	computeIntersect: function (p1, p2, q1, q2) {
		this._isProper = false;
		if (!__WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */].intersects(p1, p2, q1, q2)) return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].NO_INTERSECTION;
		var Pq1 = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].orientationIndex(p1, p2, q1);
		var Pq2 = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].orientationIndex(p1, p2, q2);
		if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
			return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].NO_INTERSECTION;
		}
		var Qp1 = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].orientationIndex(q1, q2, p1);
		var Qp2 = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].orientationIndex(q1, q2, p2);
		if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
			return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].NO_INTERSECTION;
		}
		var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
		if (collinear) {
			return this.computeCollinearIntersection(p1, p2, q1, q2);
		}
		if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
			this._isProper = false;
			if (p1.equals2D(q1) || p1.equals2D(q2)) {
				this._intPt[0] = p1;
			} else if (p2.equals2D(q1) || p2.equals2D(q2)) {
				this._intPt[0] = p2;
			} else if (Pq1 === 0) {
				this._intPt[0] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](q1);
			} else if (Pq2 === 0) {
				this._intPt[0] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](q2);
			} else if (Qp1 === 0) {
				this._intPt[0] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](p1);
			} else if (Qp2 === 0) {
				this._intPt[0] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](p2);
			}
		} else {
			this._isProper = true;
			this._intPt[0] = this.intersection(p1, p2, q1, q2);
		}
		return __WEBPACK_IMPORTED_MODULE_9__LineIntersector__["a" /* default */].POINT_INTERSECTION;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RobustLineIntersector;
	}
});
RobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {
	var nearestPt = p1;
	var minDist = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].distancePointLine(p1, q1, q2);
	var dist = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].distancePointLine(p2, q1, q2);
	if (dist < minDist) {
		minDist = dist;
		nearestPt = p2;
	}
	dist = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].distancePointLine(q1, p1, p2);
	if (dist < minDist) {
		minDist = dist;
		nearestPt = q1;
	}
	dist = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].distancePointLine(q2, p1, p2);
	if (dist < minDist) {
		minDist = dist;
		nearestPt = q2;
	}
	return nearestPt;
};


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = System;
function System () { }

System.arraycopy = (src, srcPos, dest, destPos, len) => {
  let c = 0
  for (let i = srcPos; i < srcPos + len; i++) {
    dest[destPos + c] = src[i]
    c++
  }
}

System.getProperty = (name) => {
  return {
    'line.separator': '\n'
  }[name]
}


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Collection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Iterator__ = __webpack_require__(49);



/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 *
 * @constructor
 * @private
 */
function Collection() {};

/**
 * Ensures that this collection contains the specified element (optional
 * operation).
 * @param {Object} e
 * @return {boolean}
 */
Collection.prototype.add = function() {};


/**
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * iterator (optional operation).
 * @param {javascript.util.Collection} c
 * @return {boolean}
 */
Collection.prototype.addAll = function() {};


/**
 * Returns true if this collection contains no elements.
 * @return {boolean}
 */
Collection.prototype.isEmpty = function() {};


/**
 * Returns an iterator over the elements in this collection.
 * @return {javascript.util.Iterator}
 */
Collection.prototype.iterator = function() {};


/**
 * Returns an iterator over the elements in this collection.
 * @return {number}
 */
Collection.prototype.size = function() {};


/**
 * Returns an array containing all of the elements in this collection.
 * @return {Array}
 */
Collection.prototype.toArray = function() {};


/**
 * Removes a single instance of the specified element from this collection if it
 * is present. (optional)
 * @param {Object} e
 * @return {boolean}
 */
Collection.prototype.remove = function() {};


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Point;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CoordinateFilter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__GeometryFilter__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__CoordinateSequenceFilter__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Puntal__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__inherits__ = __webpack_require__(3);












function Point() {
	this._coordinates = null;
	let coordinates = arguments[0], factory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].call(this, factory);
	this.init(coordinates);
}
Object(__WEBPACK_IMPORTED_MODULE_11__inherits__["a" /* default */])(Point, __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Point.prototype, {
	computeEnvelopeInternal: function () {
		if (this.isEmpty()) {
			return new __WEBPACK_IMPORTED_MODULE_9__Envelope__["a" /* default */]();
		}
		var env = new __WEBPACK_IMPORTED_MODULE_9__Envelope__["a" /* default */]();
		env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
		return env;
	},
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].SORTINDEX_POINT;
	},
	getCoordinates: function () {
		return this.isEmpty() ? [] : [this.getCoordinate()];
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			if (this.isEmpty() && other.isEmpty()) {
				return true;
			}
			if (this.isEmpty() !== other.isEmpty()) {
				return false;
			}
			return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
		} else return __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	normalize: function () {},
	getCoordinate: function () {
		return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
	},
	getBoundaryDimension: function () {
		return __WEBPACK_IMPORTED_MODULE_5__Dimension__["a" /* default */].FALSE;
	},
	getDimension: function () {
		return 0;
	},
	getNumPoints: function () {
		return this.isEmpty() ? 0 : 1;
	},
	reverse: function () {
		return this.copy();
	},
	getX: function () {
		if (this.getCoordinate() === null) {
			throw new IllegalStateException("getX called on empty Point");
		}
		return this.getCoordinate().x;
	},
	compareToSameClass: function () {
		if (arguments.length === 1) {
			let other = arguments[0];
			var point = other;
			return this.getCoordinate().compareTo(point.getCoordinate());
		} else if (arguments.length === 2) {
			let other = arguments[0], comp = arguments[1];
			var point = other;
			return comp.compare(this._coordinates, point._coordinates);
		}
	},
	apply: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_1__CoordinateFilter__["a" /* default */])) {
			let filter = arguments[0];
			if (this.isEmpty()) {
				return null;
			}
			filter.filter(this.getCoordinate());
		} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_7__CoordinateSequenceFilter__["a" /* default */])) {
			let filter = arguments[0];
			if (this.isEmpty()) return null;
			filter.filter(this._coordinates, 0);
			if (filter.isGeometryChanged()) this.geometryChanged();
		} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_6__GeometryFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
		} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_4__GeometryComponentFilter__["a" /* default */])) {
			let filter = arguments[0];
			filter.filter(this);
		}
	},
	getBoundary: function () {
		return this.getFactory().createGeometryCollection(null);
	},
	clone: function () {
		var p = __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].prototype.clone.call(this);
		p._coordinates = this._coordinates.clone();
		return p;
	},
	getGeometryType: function () {
		return "Point";
	},
	copy: function () {
		return new Point(this._coordinates.copy(), this._factory);
	},
	getCoordinateSequence: function () {
		return this._coordinates;
	},
	getY: function () {
		if (this.getCoordinate() === null) {
			throw new IllegalStateException("getY called on empty Point");
		}
		return this.getCoordinate().y;
	},
	isEmpty: function () {
		return this._coordinates.size() === 0;
	},
	init: function (coordinates) {
		if (coordinates === null) {
			coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
		}
		__WEBPACK_IMPORTED_MODULE_10__util_Assert__["a" /* default */].isTrue(coordinates.size() <= 1);
		this._coordinates = coordinates;
	},
	isSimple: function () {
		return true;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_8__Puntal__["a" /* default */]];
	},
	getClass: function () {
		return Point;
	}
});
Point.serialVersionUID = 4902022702746614570;


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Label;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__ = __webpack_require__(248);





function Label() {
	this.elt = new Array(2).fill(null);
	if (arguments.length === 1) {
		if (Number.isInteger(arguments[0])) {
			let onLoc = arguments[0];
			this.elt[0] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](onLoc);
			this.elt[1] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](onLoc);
		} else if (arguments[0] instanceof Label) {
			let lbl = arguments[0];
			this.elt[0] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](lbl.elt[0]);
			this.elt[1] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](lbl.elt[1]);
		}
	} else if (arguments.length === 2) {
		let geomIndex = arguments[0], onLoc = arguments[1];
		this.elt[0] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE);
		this.elt[1] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE);
		this.elt[geomIndex].setLocation(onLoc);
	} else if (arguments.length === 3) {
		let onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];
		this.elt[0] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](onLoc, leftLoc, rightLoc);
		this.elt[1] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](onLoc, leftLoc, rightLoc);
	} else if (arguments.length === 4) {
		let geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];
		this.elt[0] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE);
		this.elt[1] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE);
		this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Label.prototype, {
	getGeometryCount: function () {
		var count = 0;
		if (!this.elt[0].isNull()) count++;
		if (!this.elt[1].isNull()) count++;
		return count;
	},
	setAllLocations: function (geomIndex, location) {
		this.elt[geomIndex].setAllLocations(location);
	},
	isNull: function (geomIndex) {
		return this.elt[geomIndex].isNull();
	},
	setAllLocationsIfNull: function () {
		if (arguments.length === 1) {
			let location = arguments[0];
			this.setAllLocationsIfNull(0, location);
			this.setAllLocationsIfNull(1, location);
		} else if (arguments.length === 2) {
			let geomIndex = arguments[0], location = arguments[1];
			this.elt[geomIndex].setAllLocationsIfNull(location);
		}
	},
	isLine: function (geomIndex) {
		return this.elt[geomIndex].isLine();
	},
	merge: function (lbl) {
		for (var i = 0; i < 2; i++) {
			if (this.elt[i] === null && lbl.elt[i] !== null) {
				this.elt[i] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](lbl.elt[i]);
			} else {
				this.elt[i].merge(lbl.elt[i]);
			}
		}
	},
	flip: function () {
		this.elt[0].flip();
		this.elt[1].flip();
	},
	getLocation: function () {
		if (arguments.length === 1) {
			let geomIndex = arguments[0];
			return this.elt[geomIndex].get(__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON);
		} else if (arguments.length === 2) {
			let geomIndex = arguments[0], posIndex = arguments[1];
			return this.elt[geomIndex].get(posIndex);
		}
	},
	toString: function () {
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		if (this.elt[0] !== null) {
			buf.append("A:");
			buf.append(this.elt[0].toString());
		}
		if (this.elt[1] !== null) {
			buf.append(" B:");
			buf.append(this.elt[1].toString());
		}
		return buf.toString();
	},
	isArea: function () {
		if (arguments.length === 0) {
			return this.elt[0].isArea() || this.elt[1].isArea();
		} else if (arguments.length === 1) {
			let geomIndex = arguments[0];
			return this.elt[geomIndex].isArea();
		}
	},
	isAnyNull: function (geomIndex) {
		return this.elt[geomIndex].isAnyNull();
	},
	setLocation: function () {
		if (arguments.length === 2) {
			let geomIndex = arguments[0], location = arguments[1];
			this.elt[geomIndex].setLocation(__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON, location);
		} else if (arguments.length === 3) {
			let geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];
			this.elt[geomIndex].setLocation(posIndex, location);
		}
	},
	isEqualOnSide: function (lbl, side) {
		return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
	},
	allPositionsEqual: function (geomIndex, loc) {
		return this.elt[geomIndex].allPositionsEqual(loc);
	},
	toLine: function (geomIndex) {
		if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new __WEBPACK_IMPORTED_MODULE_4__TopologyLocation__["a" /* default */](this.elt[geomIndex].location[0]);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Label;
	}
});
Label.toLineLabel = function (label) {
	var lineLabel = new Label(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE);
	for (var i = 0; i < 2; i++) {
		lineLabel.setLocation(i, label.getLocation(i));
	}
	return lineLabel;
};


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = WKTWriter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WKTParser__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);



/**
 * Writes the Well-Known Text representation of a {@link Geometry}. The
 * Well-Known Text format is defined in the <A
 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
 * Specification for SQL</A>.
 * <p>
 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
 * Under the spec, rings are output as <code>LINESTRING</code>s.
 */

/**
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function WKTWriter (geometryFactory) {
  this.parser = new __WEBPACK_IMPORTED_MODULE_0__WKTParser__["a" /* default */](geometryFactory)
}

Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(WKTWriter.prototype, {
  /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof WKTWriter
   */
  write (geometry) {
    return this.parser.write(geometry)
  }
})

Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(WKTWriter, {
  /**
   * Generates the WKT for a <tt>LINESTRING</tt> specified by two
   * {@link Coordinate}s.
   *
   * @param p0 the first coordinate.
   * @param p1 the second coordinate.
   *
   * @return the WKT.
   * @private
   */
  toLineString (p0, p1) {
    if (arguments.length !== 2) {
      throw new Error('Not implemented')
    }

    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'
  }
})


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MultiLineString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__operation_BoundaryOp__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Lineal__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__inherits__ = __webpack_require__(3);







function MultiLineString() {
	let lineStrings = arguments[0], factory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_4__GeometryCollection__["a" /* default */].call(this, lineStrings, factory);
}
Object(__WEBPACK_IMPORTED_MODULE_6__inherits__["a" /* default */])(MultiLineString, __WEBPACK_IMPORTED_MODULE_4__GeometryCollection__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(MultiLineString.prototype, {
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].SORTINDEX_MULTILINESTRING;
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			return __WEBPACK_IMPORTED_MODULE_4__GeometryCollection__["a" /* default */].prototype.equalsExact.call(this, other, tolerance);
		} else return __WEBPACK_IMPORTED_MODULE_4__GeometryCollection__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	getBoundaryDimension: function () {
		if (this.isClosed()) {
			return __WEBPACK_IMPORTED_MODULE_5__Dimension__["a" /* default */].FALSE;
		}
		return 0;
	},
	isClosed: function () {
		if (this.isEmpty()) {
			return false;
		}
		for (var i = 0; i < this._geometries.length; i++) {
			if (!this._geometries[i].isClosed()) {
				return false;
			}
		}
		return true;
	},
	getDimension: function () {
		return 1;
	},
	reverse: function () {
		var nLines = this._geometries.length;
		var revLines = new Array(nLines).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			revLines[nLines - 1 - i] = this._geometries[i].reverse();
		}
		return this.getFactory().createMultiLineString(revLines);
	},
	getBoundary: function () {
		return new __WEBPACK_IMPORTED_MODULE_1__operation_BoundaryOp__["a" /* default */](this).getBoundary();
	},
	getGeometryType: function () {
		return "MultiLineString";
	},
	copy: function () {
		var lineStrings = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < lineStrings.length; i++) {
			lineStrings[i] = this._geometries[i].copy();
		}
		return new MultiLineString(lineStrings, this._factory);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__Lineal__["a" /* default */]];
	},
	getClass: function () {
		return MultiLineString;
	}
});
MultiLineString.serialVersionUID = 8166665132445433741;


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LinearRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__CoordinateSequences__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__CoordinateSequence__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__inherits__ = __webpack_require__(3);











function LinearRing() {
	if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_4__Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_3__GeometryFactory__["a" /* default */]) {
		let points = arguments[0], factory = arguments[1];
		LinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);
	} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_8__CoordinateSequence__["a" /* default */]) && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_3__GeometryFactory__["a" /* default */]) {
		let points = arguments[0], factory = arguments[1];
		__WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */].call(this, points, factory);
		this.validateConstruction();
	}
}
Object(__WEBPACK_IMPORTED_MODULE_10__inherits__["a" /* default */])(LinearRing, __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(LinearRing.prototype, {
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */].SORTINDEX_LINEARRING;
	},
	getBoundaryDimension: function () {
		return __WEBPACK_IMPORTED_MODULE_9__Dimension__["a" /* default */].FALSE;
	},
	isClosed: function () {
		if (this.isEmpty()) {
			return true;
		}
		return __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */].prototype.isClosed.call(this);
	},
	reverse: function () {
		var seq = this._points.copy();
		__WEBPACK_IMPORTED_MODULE_7__CoordinateSequences__["a" /* default */].reverse(seq);
		var rev = this.getFactory().createLinearRing(seq);
		return rev;
	},
	validateConstruction: function () {
		if (!this.isEmpty() && !__WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */].prototype.isClosed.call(this)) {
			throw new __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__["a" /* default */]("Points of LinearRing do not form a closed linestring");
		}
		if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
			throw new __WEBPACK_IMPORTED_MODULE_5__java_lang_IllegalArgumentException__["a" /* default */]("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
		}
	},
	getGeometryType: function () {
		return "LinearRing";
	},
	copy: function () {
		return new LinearRing(this._points.copy(), this._factory);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LinearRing;
	}
});
LinearRing.MINIMUM_VALID_SIZE = 4;
LinearRing.serialVersionUID = -4261142084085851829;


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MultiPolygon;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__inherits__ = __webpack_require__(3);






function MultiPolygon() {
	let polygons = arguments[0], factory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].call(this, polygons, factory);
}
Object(__WEBPACK_IMPORTED_MODULE_5__inherits__["a" /* default */])(MultiPolygon, __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(MultiPolygon.prototype, {
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].SORTINDEX_MULTIPOLYGON;
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			return __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].prototype.equalsExact.call(this, other, tolerance);
		} else return __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	getBoundaryDimension: function () {
		return 1;
	},
	getDimension: function () {
		return 2;
	},
	reverse: function () {
		var n = this._geometries.length;
		var revGeoms = new Array(n).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			revGeoms[i] = this._geometries[i].reverse();
		}
		return this.getFactory().createMultiPolygon(revGeoms);
	},
	getBoundary: function () {
		if (this.isEmpty()) {
			return this.getFactory().createMultiLineString();
		}
		var allRings = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < this._geometries.length; i++) {
			var polygon = this._geometries[i];
			var rings = polygon.getBoundary();
			for (var j = 0; j < rings.getNumGeometries(); j++) {
				allRings.add(rings.getGeometryN(j));
			}
		}
		var allRingsArray = new Array(allRings.size()).fill(null);
		return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
	},
	getGeometryType: function () {
		return "MultiPolygon";
	},
	copy: function () {
		var polygons = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < polygons.length; i++) {
			polygons[i] = this._geometries[i].copy();
		}
		return new MultiPolygon(polygons, this._factory);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__Polygonal__["a" /* default */]];
	},
	getClass: function () {
		return MultiPolygon;
	}
});
MultiPolygon.serialVersionUID = -551033529766975875;


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryComponentFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function GeometryComponentFilter() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GeometryComponentFilter.prototype, {
	filter: function (geom) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryComponentFilter;
	}
});


/***/ }),
/* 32 */
/***/ (function(module, exports) {

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(obj) {
    if (!obj) throw new Error('obj is required');

    var coordinates = getCoords(obj);

    // getCoord() must contain at least two numbers (Point)
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return coordinates;
    } else {
        throw new Error('Coordinate is not a valid Point');
    }
}

/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers
 *
 * @name getCoords
 * @param {Array<number>|Geometry|Feature} obj Object
 * @returns {Array<number>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coord = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(obj) {
    if (!obj) throw new Error('obj is required');
    var coordinates;

    // Array of numbers
    if (obj.length) {
        coordinates = obj;

    // Geometry Object
    } else if (obj.coordinates) {
        coordinates = obj.coordinates;

    // Feature
    } else if (obj.geometry && obj.geometry.coordinates) {
        coordinates = obj.geometry.coordinates;
    }
    // Checks if coordinates contains a number
    if (coordinates) {
        containsNumber(coordinates);
        return coordinates;
    }
    throw new Error('No valid coordinates');
}

/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return true;
    }

    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error('coordinates must only contain numbers');
}

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) throw new Error('No feature passed');
    if (!name) throw new Error('.featureOf() requires a name');
    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) throw new Error('No featureCollection passed');
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < featureCollection.features.length; i++) {
        var feature = featureCollection.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (!geojson) throw new Error('geojson is required');
    if (geojson.geometry !== undefined) return geojson.geometry;
    if (geojson.coordinates || geojson.geometries) return geojson;
    throw new Error('geojson must be a valid Feature or Geometry Object');
}

/**
 * Get Geometry Type from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {string} GeoJSON Geometry Type
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeomType(point)
 * //="Point"
 */
function getGeomType(geojson) {
    if (!geojson) throw new Error('geojson is required');
    var geom = getGeom(geojson);
    if (geom) return geom.type;
}

module.exports = {
    geojsonType: geojsonType,
    collectionOf: collectionOf,
    featureOf: featureOf,
    getCoord: getCoord,
    getCoords: getCoords,
    containsNumber: containsNumber,
    getGeom: getGeom,
    getGeomType: getGeomType
};


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = List;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Collection__ = __webpack_require__(24);


/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
 *
 * @extends {javascript.util.Collection}
 * @constructor
 * @private
 */
function List() { };
List.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Collection__["a" /* default */].prototype);
List.prototype.constructor = List

/**
 * Returns the element at the specified position in this list.
 * @param {number} index
 * @return {Object}
 */
List.prototype.get = function() { };


/**
 * Replaces the element at the specified position in this list with the
 * specified element (optional operation).
 * @param {number} index
 * @param {Object} e
 * @return {Object}
 */
List.prototype.set = function() { };


/**
 * Returns true if this collection contains no elements.
 * @return {boolean}
 */
List.prototype.isEmpty = function() { };


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = StringBuffer;
function StringBuffer (str) {
  this.str = str
}

StringBuffer.prototype.append = function (e) {
  this.str += e
}

StringBuffer.prototype.setCharAt = function (i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)
}

StringBuffer.prototype.toString = function (e) {
  return this.str
}


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TreeMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SortedMap__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__HashSet__ = __webpack_require__(45);




const BLACK = 0
const RED = 1
function colorOf (p) { return (p == null ? BLACK : p.color) }
function parentOf (p) { return (p == null ? null : p.parent) }
function setColor (p, c) { if (p !== null) p.color = c }
function leftOf (p) { return (p == null ? null : p.left) }
function rightOf (p) { return (p == null ? null : p.right) }

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
 *
 * @extends {SortedMap}
 * @constructor
 * @private
 */
function TreeMap() {
  /**
   * @type {Object}
   * @private
   */
  this.root_ = null;
  /**
   * @type {number}
   * @private
  */
  this.size_ = 0;
};
TreeMap.prototype = new __WEBPACK_IMPORTED_MODULE_1__SortedMap__["a" /* default */]();


/**
 * @override
 */
TreeMap.prototype.get = function(key) {
  var p = this.root_;
  while (p !== null) {
    var cmp = key['compareTo'](p.key);
    if (cmp < 0) {
      p = p.left;
    } else if (cmp > 0) {
      p = p.right;
    } else {
      return p.value;
    }
  }
  return null;
};


/**
 * @override
 */
TreeMap.prototype.put = function(key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key: key,
      value: value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue() { return this.value },
      getKey() { return this.key }
    };
    this.size_ = 1;
    return null;
  }
  var t = this.root_, parent, cmp;
  do {
    parent = t;
    cmp = key['compareTo'](t.key);
    if (cmp < 0) {
      t = t.left;
    } else if (cmp > 0) {
      t = t.right;
    } else {
      var oldValue = t.value;
      t.value = value;
      return oldValue;
    }
  } while (t !== null);
  var e = {
    key: key,
    left: null,
    right: null,
    value: value,
    parent: parent,
    color: BLACK,
    getValue() { return this.value },
    getKey() { return this.key }
  };
  if (cmp < 0) {
    parent.left = e;
  } else {
    parent.right = e;
  }
  this.fixAfterInsertion(e);
  this.size_++;
  return null;
};


/**
 * @param {Object} x
 */
TreeMap.prototype.fixAfterInsertion = function(x) {
  x.color = RED;
  while (x != null && x != this.root_ && x.parent.color == RED) {
    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
      var y = rightOf(parentOf(parentOf(x)));
      if (colorOf(y) == RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x == rightOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateLeft(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateRight(parentOf(parentOf(x)));
      }
    } else {
      var y = leftOf(parentOf(parentOf(x)));
      if (colorOf(y) == RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x == leftOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateRight(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateLeft(parentOf(parentOf(x)));
      }
    }
  }
  this.root_.color = BLACK;
};


/**
 * @override
 */
TreeMap.prototype.values = function() {
  var arrayList = new __WEBPACK_IMPORTED_MODULE_0__ArrayList__["a" /* default */]();
  var p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList;
};


/**
 * @override
 */
TreeMap.prototype.entrySet = function() {
  var hashSet = new __WEBPACK_IMPORTED_MODULE_2__HashSet__["a" /* default */]();
  var p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet;
};


/**
 * @param {Object} p
 */
TreeMap.prototype.rotateLeft = function(p) {
  if (p != null) {
    var r = p.right;
    p.right = r.left;
    if (r.left != null)
      r.left.parent = p;
    r.parent = p.parent;
    if (p.parent == null)
      this.root_ = r;
    else if (p.parent.left == p)
      p.parent.left = r;
    else
      p.parent.right = r;
    r.left = p;
    p.parent = r;
  }
};


/**
 * @param {Object} p
 */
TreeMap.prototype.rotateRight = function(p) {
  if (p != null) {
    var l = p.left;
    p.left = l.right;
    if (l.right != null) l.right.parent = p;
    l.parent = p.parent;
    if (p.parent == null)
      this.root_ = l;
    else if (p.parent.right == p)
      p.parent.right = l;
    else p.parent.left = l;
    l.right = p;
    p.parent = l;
  }
};


/**
 * @return {Object}
 */
TreeMap.prototype.getFirstEntry = function() {
  var p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p;
};


/**
 * @param {Object} t
 * @return {Object}
 * @private
 */
TreeMap.successor = function(t) {
  if (t === null)
    return null;
  else if (t.right !== null) {
    var p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p;
  } else {
    var p = t.parent;
    var ch = t;
    while (p !== null && ch === p.right) {
      ch = p;
      p = p.parent;
    }
    return p;
  }
};


/**
 * @override
 */
TreeMap.prototype.size = function() {
  return this.size_;
};


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Arrays__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ArrayList__ = __webpack_require__(1);



const Collections = {
  reverseOrder: function () {
    return {
      compare (a, b) {
        return b.compareTo(a)
      }
    }
  },
  min: function (l) {
    Collections.sort(l)
    return l.get(0)
  },
  sort: function (l, c) {
    const a = l.toArray()
    if (c) {
      __WEBPACK_IMPORTED_MODULE_0__Arrays__["a" /* default */].sort(a, c)
    } else {
      __WEBPACK_IMPORTED_MODULE_0__Arrays__["a" /* default */].sort(a)
    }
    const i = l.iterator()
    for (let pos = 0, alen = a.length; pos < alen; pos++) {
      i.next()
      i.set(a[pos])
    }
  },
  singletonList: function (o) {
    const arrayList = new __WEBPACK_IMPORTED_MODULE_1__ArrayList__["a" /* default */]()
    arrayList.add(o)
    return arrayList
  }
}

/* harmony default export */ __webpack_exports__["a"] = (Collections);


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateSequence;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Cloneable__ = __webpack_require__(53);


function CoordinateSequence() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(CoordinateSequence.prototype, {
	setOrdinate: function (index, ordinateIndex, value) {},
	size: function () {},
	getOrdinate: function (index, ordinateIndex) {},
	getCoordinate: function () {
		if (arguments.length === 1) {
			let i = arguments[0];
		} else if (arguments.length === 2) {
			let index = arguments[0], coord = arguments[1];
		}
	},
	getCoordinateCopy: function (i) {},
	getDimension: function () {},
	getX: function (index) {},
	clone: function () {},
	expandEnvelope: function (env) {},
	copy: function () {},
	getY: function (index) {},
	toCoordinateArray: function () {},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__java_lang_Cloneable__["a" /* default */]];
	},
	getClass: function () {
		return CoordinateSequence;
	}
});
CoordinateSequence.X = 0;
CoordinateSequence.Y = 1;
CoordinateSequence.Z = 2;
CoordinateSequence.M = 3;


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Dimension;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Character__ = __webpack_require__(117);



function Dimension() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Dimension.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Dimension;
	}
});
Dimension.toDimensionSymbol = function (dimensionValue) {
	switch (dimensionValue) {
		case Dimension.FALSE:
			return Dimension.SYM_FALSE;
		case Dimension.TRUE:
			return Dimension.SYM_TRUE;
		case Dimension.DONTCARE:
			return Dimension.SYM_DONTCARE;
		case Dimension.P:
			return Dimension.SYM_P;
		case Dimension.L:
			return Dimension.SYM_L;
		case Dimension.A:
			return Dimension.SYM_A;
	}
	throw new __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__["a" /* default */]("Unknown dimension value: " + dimensionValue);
};
Dimension.toDimensionValue = function (dimensionSymbol) {
	switch (__WEBPACK_IMPORTED_MODULE_2__java_lang_Character__["a" /* default */].toUpperCase(dimensionSymbol)) {
		case Dimension.SYM_FALSE:
			return Dimension.FALSE;
		case Dimension.SYM_TRUE:
			return Dimension.TRUE;
		case Dimension.SYM_DONTCARE:
			return Dimension.DONTCARE;
		case Dimension.SYM_P:
			return Dimension.P;
		case Dimension.SYM_L:
			return Dimension.L;
		case Dimension.SYM_A:
			return Dimension.A;
	}
	throw new __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__["a" /* default */]("Unknown dimension symbol: " + dimensionSymbol);
};
Dimension.P = 0;
Dimension.L = 1;
Dimension.A = 2;
Dimension.FALSE = -1;
Dimension.TRUE = -2;
Dimension.DONTCARE = -3;
Dimension.SYM_FALSE = 'F';
Dimension.SYM_TRUE = 'T';
Dimension.SYM_DONTCARE = '*';
Dimension.SYM_P = '0';
Dimension.SYM_L = '1';
Dimension.SYM_A = '2';


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function GeometryFilter() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GeometryFilter.prototype, {
	filter: function (geom) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryFilter;
	}
});


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Polygonal;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Polygonal() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Polygonal.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Polygonal;
	}
});


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MultiPoint;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Puntal__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__inherits__ = __webpack_require__(3);






function MultiPoint() {
	let points = arguments[0], factory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].call(this, points, factory);
}
Object(__WEBPACK_IMPORTED_MODULE_5__inherits__["a" /* default */])(MultiPoint, __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(MultiPoint.prototype, {
	getSortIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_0__Geometry__["a" /* default */].SORTINDEX_MULTIPOINT;
	},
	isValid: function () {
		return true;
	},
	equalsExact: function () {
		if (arguments.length === 2) {
			let other = arguments[0], tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			return __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].prototype.equalsExact.call(this, other, tolerance);
		} else return __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].prototype.equalsExact.apply(this, arguments);
	},
	getCoordinate: function () {
		if (arguments.length === 1) {
			let n = arguments[0];
			return this._geometries[n].getCoordinate();
		} else return __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */].prototype.getCoordinate.apply(this, arguments);
	},
	getBoundaryDimension: function () {
		return __WEBPACK_IMPORTED_MODULE_3__Dimension__["a" /* default */].FALSE;
	},
	getDimension: function () {
		return 0;
	},
	getBoundary: function () {
		return this.getFactory().createGeometryCollection(null);
	},
	getGeometryType: function () {
		return "MultiPoint";
	},
	copy: function () {
		var points = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < points.length; i++) {
			points[i] = this._geometries[i].copy();
		}
		return new MultiPoint(points, this._factory);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__Puntal__["a" /* default */]];
	},
	getClass: function () {
		return MultiPoint;
	}
});
MultiPoint.serialVersionUID = -8048474874175355449;


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OverlayOp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_EdgeNodingValidator__ = __webpack_require__(231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_util_GeometryCollectionMapper__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PolygonBuilder__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__LineBuilder__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__PointBuilder__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__snap_SnapIfNeededOverlayOp__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__geomgraph_Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__OverlayNodeFactory__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__GeometryGraphOperation__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geomgraph_EdgeList__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__geomgraph_PlanarGraph__ = __webpack_require__(64);


















function OverlayOp() {
	this._ptLocator = new __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__["a" /* default */]();
	this._geomFact = null;
	this._resultGeom = null;
	this._graph = null;
	this._edgeList = new __WEBPACK_IMPORTED_MODULE_13__geomgraph_EdgeList__["a" /* default */]();
	this._resultPolyList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
	this._resultLineList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
	this._resultPointList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
	let g0 = arguments[0], g1 = arguments[1];
	__WEBPACK_IMPORTED_MODULE_12__GeometryGraphOperation__["a" /* default */].call(this, g0, g1);
	this._graph = new __WEBPACK_IMPORTED_MODULE_17__geomgraph_PlanarGraph__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_11__OverlayNodeFactory__["a" /* default */]());
	this._geomFact = g0.getFactory();
}
Object(__WEBPACK_IMPORTED_MODULE_16__inherits__["a" /* default */])(OverlayOp, __WEBPACK_IMPORTED_MODULE_12__GeometryGraphOperation__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_9__extend__["a" /* default */])(OverlayOp.prototype, {
	insertUniqueEdge: function (e) {
		var existingEdge = this._edgeList.findEqualEdge(e);
		if (existingEdge !== null) {
			var existingLabel = existingEdge.getLabel();
			var labelToMerge = e.getLabel();
			if (!existingEdge.isPointwiseEqual(e)) {
				labelToMerge = new __WEBPACK_IMPORTED_MODULE_10__geomgraph_Label__["a" /* default */](e.getLabel());
				labelToMerge.flip();
			}
			var depth = existingEdge.getDepth();
			if (depth.isNull()) {
				depth.add(existingLabel);
			}
			depth.add(labelToMerge);
			existingLabel.merge(labelToMerge);
		} else {
			this._edgeList.add(e);
		}
	},
	getGraph: function () {
		return this._graph;
	},
	cancelDuplicateResultEdges: function () {
		for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
			var de = it.next();
			var sym = de.getSym();
			if (de.isInResult() && sym.isInResult()) {
				de.setInResult(false);
				sym.setInResult(false);
			}
		}
	},
	isCoveredByLA: function (coord) {
		if (this.isCovered(coord, this._resultLineList)) return true;
		if (this.isCovered(coord, this._resultPolyList)) return true;
		return false;
	},
	computeGeometry: function (resultPointList, resultLineList, resultPolyList, opcode) {
		var geomList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		geomList.addAll(resultPointList);
		geomList.addAll(resultLineList);
		geomList.addAll(resultPolyList);
		if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
		return this._geomFact.buildGeometry(geomList);
	},
	mergeSymLabels: function () {
		for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
			var node = nodeit.next();
			node.getEdges().mergeSymLabels();
		}
	},
	isCovered: function (coord, geomList) {
		for (var it = geomList.iterator(); it.hasNext(); ) {
			var geom = it.next();
			var loc = this._ptLocator.locate(coord, geom);
			if (loc !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR) return true;
		}
		return false;
	},
	replaceCollapsedEdges: function () {
		var newEdges = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		for (var it = this._edgeList.iterator(); it.hasNext(); ) {
			var e = it.next();
			if (e.isCollapsed()) {
				it.remove();
				newEdges.add(e.getCollapsedEdge());
			}
		}
		this._edgeList.addAll(newEdges);
	},
	updateNodeLabelling: function () {
		for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
			var node = nodeit.next();
			var lbl = node.getEdges().getLabel();
			node.getLabel().merge(lbl);
		}
	},
	getResultGeometry: function (overlayOpCode) {
		this.computeOverlay(overlayOpCode);
		return this._resultGeom;
	},
	insertUniqueEdges: function (edges) {
		for (var i = edges.iterator(); i.hasNext(); ) {
			var e = i.next();
			this.insertUniqueEdge(e);
		}
	},
	computeOverlay: function (opCode) {
		this.copyPoints(0);
		this.copyPoints(1);
		this._arg[0].computeSelfNodes(this._li, false);
		this._arg[1].computeSelfNodes(this._li, false);
		this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
		var baseSplitEdges = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		this._arg[0].computeSplitEdges(baseSplitEdges);
		this._arg[1].computeSplitEdges(baseSplitEdges);
		var splitEdges = baseSplitEdges;
		this.insertUniqueEdges(baseSplitEdges);
		this.computeLabelsFromDepths();
		this.replaceCollapsedEdges();
		__WEBPACK_IMPORTED_MODULE_2__geomgraph_EdgeNodingValidator__["a" /* default */].checkValid(this._edgeList.getEdges());
		this._graph.addEdges(this._edgeList.getEdges());
		this.computeLabelling();
		this.labelIncompleteNodes();
		this.findResultAreaEdges(opCode);
		this.cancelDuplicateResultEdges();
		var polyBuilder = new __WEBPACK_IMPORTED_MODULE_4__PolygonBuilder__["a" /* default */](this._geomFact);
		polyBuilder.add(this._graph);
		this._resultPolyList = polyBuilder.getPolygons();
		var lineBuilder = new __WEBPACK_IMPORTED_MODULE_6__LineBuilder__["a" /* default */](this, this._geomFact, this._ptLocator);
		this._resultLineList = lineBuilder.build(opCode);
		var pointBuilder = new __WEBPACK_IMPORTED_MODULE_7__PointBuilder__["a" /* default */](this, this._geomFact, this._ptLocator);
		this._resultPointList = pointBuilder.build(opCode);
		this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
	},
	labelIncompleteNode: function (n, targetIndex) {
		var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
		n.getLabel().setLocation(targetIndex, loc);
	},
	copyPoints: function (argIndex) {
		for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {
			var graphNode = i.next();
			var newNode = this._graph.addNode(graphNode.getCoordinate());
			newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
		}
	},
	findResultAreaEdges: function (opCode) {
		for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
			var de = it.next();
			var label = de.getLabel();
			if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].RIGHT), label.getLocation(1, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].RIGHT), opCode)) {
				de.setInResult(true);
			}
		}
	},
	computeLabelsFromDepths: function () {
		for (var it = this._edgeList.iterator(); it.hasNext(); ) {
			var e = it.next();
			var lbl = e.getLabel();
			var depth = e.getDepth();
			if (!depth.isNull()) {
				depth.normalize();
				for (var i = 0; i < 2; i++) {
					if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
						if (depth.getDelta(i) === 0) {
							lbl.toLine(i);
						} else {
							__WEBPACK_IMPORTED_MODULE_15__util_Assert__["a" /* default */].isTrue(!depth.isNull(i, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].LEFT), "depth of LEFT side has not been initialized");
							lbl.setLocation(i, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].LEFT, depth.getLocation(i, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].LEFT));
							__WEBPACK_IMPORTED_MODULE_15__util_Assert__["a" /* default */].isTrue(!depth.isNull(i, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].RIGHT), "depth of RIGHT side has not been initialized");
							lbl.setLocation(i, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].RIGHT, depth.getLocation(i, __WEBPACK_IMPORTED_MODULE_5__geomgraph_Position__["a" /* default */].RIGHT));
						}
					}
				}
			}
		}
	},
	computeLabelling: function () {
		for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
			var node = nodeit.next();
			node.getEdges().computeLabelling(this._arg);
		}
		this.mergeSymLabels();
		this.updateNodeLabelling();
	},
	labelIncompleteNodes: function () {
		var nodeCount = 0;
		for (var ni = this._graph.getNodes().iterator(); ni.hasNext(); ) {
			var n = ni.next();
			var label = n.getLabel();
			if (n.isIsolated()) {
				nodeCount++;
				if (label.isNull(0)) this.labelIncompleteNode(n, 0); else this.labelIncompleteNode(n, 1);
			}
			n.getEdges().updateLabelling(label);
		}
	},
	isCoveredByA: function (coord) {
		if (this.isCovered(coord, this._resultPolyList)) return true;
		return false;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return OverlayOp;
	}
});
OverlayOp.overlayOp = function (geom0, geom1, opCode) {
	var gov = new OverlayOp(geom0, geom1);
	var geomOv = gov.getResultGeometry(opCode);
	return geomOv;
};
OverlayOp.intersection = function (g, other) {
	if (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());
	if (g.isGeometryCollection()) {
		var g2 = other;
		return __WEBPACK_IMPORTED_MODULE_3__geom_util_GeometryCollectionMapper__["a" /* default */].map(g, {
			interfaces_: function () {
				return [MapOp];
			},
			map: function (g) {
				return g.intersection(g2);
			}
		});
	}
	g.checkNotGeometryCollection(g);
	g.checkNotGeometryCollection(other);
	return __WEBPACK_IMPORTED_MODULE_8__snap_SnapIfNeededOverlayOp__["a" /* default */].overlayOp(g, other, OverlayOp.INTERSECTION);
};
OverlayOp.symDifference = function (g, other) {
	if (g.isEmpty() || other.isEmpty()) {
		if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());
		if (g.isEmpty()) return other.copy();
		if (other.isEmpty()) return g.copy();
	}
	g.checkNotGeometryCollection(g);
	g.checkNotGeometryCollection(other);
	return __WEBPACK_IMPORTED_MODULE_8__snap_SnapIfNeededOverlayOp__["a" /* default */].overlayOp(g, other, OverlayOp.SYMDIFFERENCE);
};
OverlayOp.resultDimension = function (opCode, g0, g1) {
	var dim0 = g0.getDimension();
	var dim1 = g1.getDimension();
	var resultDimension = -1;
	switch (opCode) {
		case OverlayOp.INTERSECTION:
			resultDimension = Math.min(dim0, dim1);
			break;
		case OverlayOp.UNION:
			resultDimension = Math.max(dim0, dim1);
			break;
		case OverlayOp.DIFFERENCE:
			resultDimension = dim0;
			break;
		case OverlayOp.SYMDIFFERENCE:
			resultDimension = Math.max(dim0, dim1);
			break;
	}
	return resultDimension;
};
OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {
	var result = null;
	switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
		case -1:
			result = geomFact.createGeometryCollection(new Array(0).fill(null));
			break;
		case 0:
			result = geomFact.createPoint();
			break;
		case 1:
			result = geomFact.createLineString();
			break;
		case 2:
			result = geomFact.createPolygon();
			break;
	}
	return result;
};
OverlayOp.difference = function (g, other) {
	if (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());
	if (other.isEmpty()) return g.copy();
	g.checkNotGeometryCollection(g);
	g.checkNotGeometryCollection(other);
	return __WEBPACK_IMPORTED_MODULE_8__snap_SnapIfNeededOverlayOp__["a" /* default */].overlayOp(g, other, OverlayOp.DIFFERENCE);
};
OverlayOp.isResultOfOp = function () {
	if (arguments.length === 2) {
		let label = arguments[0], opCode = arguments[1];
		var loc0 = label.getLocation(0);
		var loc1 = label.getLocation(1);
		return OverlayOp.isResultOfOp(loc0, loc1, opCode);
	} else if (arguments.length === 3) {
		let loc0 = arguments[0], loc1 = arguments[1], overlayOpCode = arguments[2];
		if (loc0 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY) loc0 = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
		if (loc1 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY) loc1 = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
		switch (overlayOpCode) {
			case OverlayOp.INTERSECTION:
				return loc0 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR && loc1 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
			case OverlayOp.UNION:
				return loc0 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR || loc1 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
			case OverlayOp.DIFFERENCE:
				return loc0 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR && loc1 !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
			case OverlayOp.SYMDIFFERENCE:
				return loc0 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR && loc1 !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR || loc0 !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR && loc1 === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
		}
		return false;
	}
};
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TopologyException;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);




function TopologyException() {
	this.pt = null;
	if (arguments.length === 1) {
		let msg = arguments[0];
		__WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */].call(this, msg);
	} else if (arguments.length === 2) {
		let msg = arguments[0], pt = arguments[1];
		__WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */].call(this, TopologyException.msgWithCoord(msg, pt));
		this.name = 'TopologyException';
		this.pt = new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */](pt);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(TopologyException, __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(TopologyException.prototype, {
	getCoordinate: function () {
		return this.pt;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TopologyException;
	}
});
TopologyException.msgWithCoord = function (msg, pt) {
	if (pt !== null) return msg + " [ " + pt + " ]";
	return msg;
};


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RuntimeException;
function RuntimeException (message) {
  this.name = 'RuntimeException'
  this.message = message
  this.stack = (new Error()).stack
  Error.call(this, message)
}

RuntimeException.prototype = Object.create(Error.prototype)
RuntimeException.prototype.constructor = Error


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = HashSet;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Iterator__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__NoSuchElementException__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__OperationNotSupported__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Set__ = __webpack_require__(121);






/**
 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
 *
 * @extends {javascript.util.Set}
 * @constructor
 * @private
 */
function HashSet() {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Collection__["a" /* default */]) {
    this.addAll(arguments[0]);
  }
};
HashSet.prototype = new __WEBPACK_IMPORTED_MODULE_4__Set__["a" /* default */]();


/**
 * @override
 */
HashSet.prototype.contains = function(o) {
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e === o) {
      return true;
    }
  }
  return false;
};


/**
 * @override
 */
HashSet.prototype.add = function(o) {
  if (this.contains(o)) {
    return false;
  }

  this.array_.push(o);

  return true;
};


/**
 * @override
 */
HashSet.prototype.addAll = function(c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};


/**
 * @override
 */
HashSet.prototype.remove = function(o) {
  throw new javascript.util.OperationNotSupported();
};


/**
 * @override
 */
HashSet.prototype.size = function() {
  return this.array_.length;
};


/**
 * @override
 */
HashSet.prototype.isEmpty = function() {
  return this.array_.length === 0;
};


/**
 * @override
 */
HashSet.prototype.toArray = function() {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};


/**
 * @override
 */
HashSet.prototype.iterator = function() {
  return new Iterator_(this);
};



/**
 * @extends {Iterator}
 * @param {HashSet} hashSet
 * @constructor
 * @private
 */
var Iterator_ = function(hashSet) {
  /**
   * @type {HashSet}
   * @private
   */
  this.hashSet_ = hashSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};


/**
 * @override
 */
Iterator_.prototype.next = function() {
  if (this.position_ === this.hashSet_.size()) {
    throw new __WEBPACK_IMPORTED_MODULE_2__NoSuchElementException__["a" /* default */]();
  }
  return this.hashSet_.array_[this.position_++];
};


/**
 * @override
 */
Iterator_.prototype.hasNext = function() {
  if (this.position_ < this.hashSet_.size()) {
    return true;
  } else {
    return false;
  }
};


/**
 * @override
 */
Iterator_.prototype.remove = function() {
  throw new __WEBPACK_IMPORTED_MODULE_3__OperationNotSupported__["a" /* default */]();
};


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TreeSet;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Iterator__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__NoSuchElementException__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__OperationNotSupported__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__SortedSet__ = __webpack_require__(211);






/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
 *
 * @extends {SortedSet}
 * @constructor
 * @private
 */
function TreeSet() {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Collection__["a" /* default */]) {
    this.addAll(arguments[0]);
  }
};
TreeSet.prototype = new __WEBPACK_IMPORTED_MODULE_4__SortedSet__["a" /* default */]();


/**
 * @override
 */
TreeSet.prototype.contains = function(o) {
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 0) {
      return true;
    }
  }
  return false;
};


/**
 * @override
 */
TreeSet.prototype.add = function(o) {
  if (this.contains(o)) {
    return false;
  }

  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 1) {
      this.array_.splice(i, 0, o);
      return true;
    }
  }

  this.array_.push(o);

  return true;
};


/**
 * @override
 */
TreeSet.prototype.addAll = function(c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};


/**
 * @override
 */
TreeSet.prototype.remove = function(e) {
  throw new __WEBPACK_IMPORTED_MODULE_3__OperationNotSupported__["a" /* default */]();
};


/**
 * @override
 */
TreeSet.prototype.size = function() {
  return this.array_.length;
};


/**
 * @override
 */
TreeSet.prototype.isEmpty = function() {
  return this.array_.length === 0;
};


/**
 * @override
 */
TreeSet.prototype.toArray = function() {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};


/**
 * @override
 */
TreeSet.prototype.iterator = function() {
  return new Iterator_(this);
};



/**
 * @extends {javascript.util.Iterator}
 * @param {javascript.util.TreeSet} treeSet
 * @constructor
 * @private
 */
var Iterator_ = function(treeSet) {
  /**
   * @type {javascript.util.TreeSet}
   * @private
   */
  this.treeSet_ = treeSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};


/**
 * @override
 */
Iterator_.prototype.next = function() {
  if (this.position_ === this.treeSet_.size()) {
    throw new __WEBPACK_IMPORTED_MODULE_2__NoSuchElementException__["a" /* default */]();
  }
  return this.treeSet_.array_[this.position_++];
};


/**
 * @override
 */
Iterator_.prototype.hasNext = function() {
  if (this.position_ < this.treeSet_.size()) {
    return true;
  } else {
    return false;
  }
};


/**
 * @override
 */
Iterator_.prototype.remove = function() {
  throw new __WEBPACK_IMPORTED_MODULE_3__OperationNotSupported__["a" /* default */]();
};


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Quadrant;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);



function Quadrant() {}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Quadrant.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Quadrant;
	}
});
Quadrant.isNorthern = function (quad) {
	return quad === Quadrant.NE || quad === Quadrant.NW;
};
Quadrant.isOpposite = function (quad1, quad2) {
	if (quad1 === quad2) return false;
	var diff = (quad1 - quad2 + 4) % 4;
	if (diff === 2) return true;
	return false;
};
Quadrant.commonHalfPlane = function (quad1, quad2) {
	if (quad1 === quad2) return quad1;
	var diff = (quad1 - quad2 + 4) % 4;
	if (diff === 2) return -1;
	var min = quad1 < quad2 ? quad1 : quad2;
	var max = quad1 > quad2 ? quad1 : quad2;
	if (min === 0 && max === 3) return 3;
	return min;
};
Quadrant.isInHalfPlane = function (quad, halfPlane) {
	if (halfPlane === Quadrant.SE) {
		return quad === Quadrant.SE || quad === Quadrant.SW;
	}
	return quad === halfPlane || quad === halfPlane + 1;
};
Quadrant.quadrant = function () {
	if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
		let dx = arguments[0], dy = arguments[1];
		if (dx === 0.0 && dy === 0.0) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Cannot compute the quadrant for point ( " + dx + ", " + dy + " )");
		if (dx >= 0.0) {
			if (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE;
		} else {
			if (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW;
		}
	} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]) {
		let p0 = arguments[0], p1 = arguments[1];
		if (p1.x === p0.x && p1.y === p0.y) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Cannot compute the quadrant for two identical points " + p0);
		if (p1.x >= p0.x) {
			if (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE;
		} else {
			if (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW;
		}
	}
};
Quadrant.NE = 0;
Quadrant.NW = 1;
Quadrant.SW = 2;
Quadrant.SE = 3;


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Comparator;
function Comparator () {}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Iterator;
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */
function Iterator() {};

/**
 * Returns true if the iteration has more elements.
 * @return {boolean}
 */
Iterator.prototype.hasNext = function() {};

/**
 * Returns the next element in the iteration.
 * @return {Object}
 */
Iterator.prototype.next = function() {};

/**
 * Removes from the underlying collection the last element returned by the
 * iterator (optional operation).
 */
Iterator.prototype.remove = function() {};


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function CoordinateFilter() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(CoordinateFilter.prototype, {
	filter: function (coord) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CoordinateFilter;
	}
});


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PrecisionModel;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_HashMap__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_Integer__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_io_Serializable__ = __webpack_require__(21);







function PrecisionModel() {
	this._modelType = null;
	this._scale = null;
	if (arguments.length === 0) {
		this._modelType = PrecisionModel.FLOATING;
	} else if (arguments.length === 1) {
		if (arguments[0] instanceof Type) {
			let modelType = arguments[0];
			this._modelType = modelType;
			if (modelType === PrecisionModel.FIXED) {
				this.setScale(1.0);
			}
		} else if (typeof arguments[0] === "number") {
			let scale = arguments[0];
			this._modelType = PrecisionModel.FIXED;
			this.setScale(scale);
		} else if (arguments[0] instanceof PrecisionModel) {
			let pm = arguments[0];
			this._modelType = pm._modelType;
			this._scale = pm._scale;
		}
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(PrecisionModel.prototype, {
	equals: function (other) {
		if (!(other instanceof PrecisionModel)) {
			return false;
		}
		var otherPrecisionModel = other;
		return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
	},
	compareTo: function (o) {
		var other = o;
		var sigDigits = this.getMaximumSignificantDigits();
		var otherSigDigits = other.getMaximumSignificantDigits();
		return new __WEBPACK_IMPORTED_MODULE_4__java_lang_Integer__["a" /* default */](sigDigits).compareTo(new __WEBPACK_IMPORTED_MODULE_4__java_lang_Integer__["a" /* default */](otherSigDigits));
	},
	getScale: function () {
		return this._scale;
	},
	isFloating: function () {
		return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
	},
	getType: function () {
		return this._modelType;
	},
	toString: function () {
		var description = "UNKNOWN";
		if (this._modelType === PrecisionModel.FLOATING) {
			description = "Floating";
		} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
			description = "Floating-Single";
		} else if (this._modelType === PrecisionModel.FIXED) {
			description = "Fixed (Scale=" + this.getScale() + ")";
		}
		return description;
	},
	makePrecise: function () {
		if (typeof arguments[0] === "number") {
			let val = arguments[0];
			if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(val)) return val;
			if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
				var floatSingleVal = val;
				return floatSingleVal;
			}
			if (this._modelType === PrecisionModel.FIXED) {
				return Math.round(val * this._scale) / this._scale;
			}
			return val;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Coordinate__["a" /* default */]) {
			let coord = arguments[0];
			if (this._modelType === PrecisionModel.FLOATING) return null;
			coord.x = this.makePrecise(coord.x);
			coord.y = this.makePrecise(coord.y);
		}
	},
	getMaximumSignificantDigits: function () {
		var maxSigDigits = 16;
		if (this._modelType === PrecisionModel.FLOATING) {
			maxSigDigits = 16;
		} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
			maxSigDigits = 6;
		} else if (this._modelType === PrecisionModel.FIXED) {
			maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
		}
		return maxSigDigits;
	},
	setScale: function (scale) {
		this._scale = Math.abs(scale);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__java_io_Serializable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return PrecisionModel;
	}
});
PrecisionModel.mostPrecise = function (pm1, pm2) {
	if (pm1.compareTo(pm2) >= 0) return pm1;
	return pm2;
};
function Type() {
	this._name = null;
	let name = arguments[0];
	this._name = name;
	Type.nameToTypeMap.put(name, this);
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Type.prototype, {
	readResolve: function () {
		return Type.nameToTypeMap.get(this._name);
	},
	toString: function () {
		return this._name;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return Type;
	}
});
Type.serialVersionUID = -5528602631731589822;
Type.nameToTypeMap = new __WEBPACK_IMPORTED_MODULE_0__java_util_HashMap__["a" /* default */]();
PrecisionModel.Type = Type;
PrecisionModel.serialVersionUID = 7777263578777803835;
PrecisionModel.FIXED = new Type("FIXED");
PrecisionModel.FLOATING = new Type("FLOATING");
PrecisionModel.FLOATING_SINGLE = new Type("FLOATING SINGLE");
PrecisionModel.maximumPreciseValue = 9007199254740992.0;


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ItemVisitor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function ItemVisitor() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(ItemVisitor.prototype, {
	visitItem: function (item) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ItemVisitor;
	}
});


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Clonable;
function Clonable () {}


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NotRepresentableException;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Exception__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function NotRepresentableException() {
	__WEBPACK_IMPORTED_MODULE_1__java_lang_Exception__["a" /* default */].call(this, "Projective point not representable on the Cartesian plane.");
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(NotRepresentableException, __WEBPACK_IMPORTED_MODULE_1__java_lang_Exception__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NotRepresentableException.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NotRepresentableException;
	}
});


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Integer;
function Integer (value) {
  this.value = value
}

Integer.prototype.intValue = function () {
  return this.value
}
Integer.prototype.compareTo = function (o) {
  if (this.value < o) return -1
  if (this.value > o) return 1
  return 0
}

Integer.isNaN = n => Number.isNaN(n)


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = HCoordinate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NotRepresentableException__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);




function HCoordinate() {
	this.x = null;
	this.y = null;
	this.w = null;
	if (arguments.length === 0) {
		this.x = 0.0;
		this.y = 0.0;
		this.w = 1.0;
	} else if (arguments.length === 1) {
		let p = arguments[0];
		this.x = p.x;
		this.y = p.y;
		this.w = 1.0;
	} else if (arguments.length === 2) {
		if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
			let _x = arguments[0], _y = arguments[1];
			this.x = _x;
			this.y = _y;
			this.w = 1.0;
		} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
			let p1 = arguments[0], p2 = arguments[1];
			this.x = p1.y * p2.w - p2.y * p1.w;
			this.y = p2.x * p1.w - p1.x * p2.w;
			this.w = p1.x * p2.y - p2.x * p1.y;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]) {
			let p1 = arguments[0], p2 = arguments[1];
			this.x = p1.y - p2.y;
			this.y = p2.x - p1.x;
			this.w = p1.x * p2.y - p2.x * p1.y;
		}
	} else if (arguments.length === 3) {
		let _x = arguments[0], _y = arguments[1], _w = arguments[2];
		this.x = _x;
		this.y = _y;
		this.w = _w;
	} else if (arguments.length === 4) {
		let p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];
		var px = p1.y - p2.y;
		var py = p2.x - p1.x;
		var pw = p1.x * p2.y - p2.x * p1.y;
		var qx = q1.y - q2.y;
		var qy = q2.x - q1.x;
		var qw = q1.x * q2.y - q2.x * q1.y;
		this.x = py * qw - qy * pw;
		this.y = qx * pw - px * qw;
		this.w = px * qy - qx * py;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(HCoordinate.prototype, {
	getY: function () {
		var a = this.y / this.w;
		if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(a) || __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isInfinite(a)) {
			throw new __WEBPACK_IMPORTED_MODULE_0__NotRepresentableException__["a" /* default */]();
		}
		return a;
	},
	getX: function () {
		var a = this.x / this.w;
		if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(a) || __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isInfinite(a)) {
			throw new __WEBPACK_IMPORTED_MODULE_0__NotRepresentableException__["a" /* default */]();
		}
		return a;
	},
	getCoordinate: function () {
		var p = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]();
		p.x = this.getX();
		p.y = this.getY();
		return p;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return HCoordinate;
	}
});
HCoordinate.intersection = function (p1, p2, q1, q2) {
	var px = p1.y - p2.y;
	var py = p2.x - p1.x;
	var pw = p1.x * p2.y - p2.x * p1.y;
	var qx = q1.y - q2.y;
	var qy = q2.x - q1.x;
	var qw = q1.x * q2.y - q2.x * q1.y;
	var x = py * qw - qy * pw;
	var y = qx * pw - px * qw;
	var w = px * qy - qx * py;
	var xInt = x / w;
	var yInt = y / w;
	if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(xInt) || (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isInfinite(xInt) || __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(yInt)) || __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isInfinite(yInt)) {
		throw new __WEBPACK_IMPORTED_MODULE_0__NotRepresentableException__["a" /* default */]();
	}
	return new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](xInt, yInt);
};


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BoundaryNodeRule;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function BoundaryNodeRule() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(BoundaryNodeRule.prototype, {
	isInBoundary: function (boundaryCount) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return BoundaryNodeRule;
	}
});
function Mod2BoundaryNodeRule() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Mod2BoundaryNodeRule.prototype, {
	isInBoundary: function (boundaryCount) {
		return boundaryCount % 2 === 1;
	},
	interfaces_: function () {
		return [BoundaryNodeRule];
	},
	getClass: function () {
		return Mod2BoundaryNodeRule;
	}
});
function EndPointBoundaryNodeRule() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(EndPointBoundaryNodeRule.prototype, {
	isInBoundary: function (boundaryCount) {
		return boundaryCount > 0;
	},
	interfaces_: function () {
		return [BoundaryNodeRule];
	},
	getClass: function () {
		return EndPointBoundaryNodeRule;
	}
});
function MultiValentEndPointBoundaryNodeRule() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MultiValentEndPointBoundaryNodeRule.prototype, {
	isInBoundary: function (boundaryCount) {
		return boundaryCount > 1;
	},
	interfaces_: function () {
		return [BoundaryNodeRule];
	},
	getClass: function () {
		return MultiValentEndPointBoundaryNodeRule;
	}
});
function MonoValentEndPointBoundaryNodeRule() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonoValentEndPointBoundaryNodeRule.prototype, {
	isInBoundary: function (boundaryCount) {
		return boundaryCount === 1;
	},
	interfaces_: function () {
		return [BoundaryNodeRule];
	},
	getClass: function () {
		return MonoValentEndPointBoundaryNodeRule;
	}
});
BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;
BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;
BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();
BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();
BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();
BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();
BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Arrays;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ArrayList__ = __webpack_require__(1);


/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
 *
 * @constructor
 * @private
 */
function Arrays() {};

/**
 */
Arrays.sort = function() {
  var a = arguments[0], i, t, comparator, compare;
  if (arguments.length === 1) {
    compare = function(a, b) {
      return a.compareTo(b);
    }
    a.sort(compare);
    return;
  } else if (arguments.length === 2) {
    comparator = arguments[1];
    compare = function(a, b) {
      return comparator['compare'](a, b);
    };
    a.sort(compare);
  } else if (arguments.length === 3) {
    t = a.slice(arguments[1], arguments[2]);
    t.sort();
    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
    return;
  } else if (arguments.length === 4) {
    t = a.slice(arguments[1], arguments[2]);
    comparator = arguments[3];
    compare = function(a, b) {
      return comparator['compare'](a, b);
    };
    t.sort(compare);
    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
    return;
  }
};


/**
 * @param {Array} array
 * @return {ArrayList}
 */
Arrays.asList = function(array) {
  var arrayList = new __WEBPACK_IMPORTED_MODULE_0__ArrayList__["a" /* default */]();
  for (var i = 0, len = array.length; i < len; i++) {
    arrayList.add(array[i]);
  }
  return arrayList;
};


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateSequenceFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function CoordinateSequenceFilter() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(CoordinateSequenceFilter.prototype, {
	filter: function (seq, i) {},
	isDone: function () {},
	isGeometryChanged: function () {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CoordinateSequenceFilter;
	}
});


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateArraySequence;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__ = __webpack_require__(21);








function CoordinateArraySequence() {
	this._dimension = 3;
	this._coordinates = null;
	if (arguments.length === 1) {
		if (arguments[0] instanceof Array) {
			let coordinates = arguments[0];
			CoordinateArraySequence.call(this, coordinates, 3);
		} else if (Number.isInteger(arguments[0])) {
			let size = arguments[0];
			this._coordinates = new Array(size).fill(null);
			for (var i = 0; i < size; i++) {
				this._coordinates[i] = new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]();
			}
		} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */])) {
			let coordSeq = arguments[0];
			if (coordSeq === null) {
				this._coordinates = new Array(0).fill(null);
				return null;
			}
			this._dimension = coordSeq.getDimension();
			this._coordinates = new Array(coordSeq.size()).fill(null);
			for (var i = 0; i < this._coordinates.length; i++) {
				this._coordinates[i] = coordSeq.getCoordinateCopy(i);
			}
		}
	} else if (arguments.length === 2) {
		if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
			let coordinates = arguments[0], dimension = arguments[1];
			this._coordinates = coordinates;
			this._dimension = dimension;
			if (coordinates === null) this._coordinates = new Array(0).fill(null);
		} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
			let size = arguments[0], dimension = arguments[1];
			this._coordinates = new Array(size).fill(null);
			this._dimension = dimension;
			for (var i = 0; i < size; i++) {
				this._coordinates[i] = new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */]();
			}
		}
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(CoordinateArraySequence.prototype, {
	setOrdinate: function (index, ordinateIndex, value) {
		switch (ordinateIndex) {
			case __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */].X:
				this._coordinates[index].x = value;
				break;
			case __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */].Y:
				this._coordinates[index].y = value;
				break;
			case __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */].Z:
				this._coordinates[index].z = value;
				break;
			default:
				throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__["a" /* default */]("invalid ordinateIndex");
		}
	},
	size: function () {
		return this._coordinates.length;
	},
	getOrdinate: function (index, ordinateIndex) {
		switch (ordinateIndex) {
			case __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */].X:
				return this._coordinates[index].x;
			case __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */].Y:
				return this._coordinates[index].y;
			case __WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */].Z:
				return this._coordinates[index].z;
		}
		return __WEBPACK_IMPORTED_MODULE_4__java_lang_Double__["a" /* default */].NaN;
	},
	getCoordinate: function () {
		if (arguments.length === 1) {
			let i = arguments[0];
			return this._coordinates[i];
		} else if (arguments.length === 2) {
			let index = arguments[0], coord = arguments[1];
			coord.x = this._coordinates[index].x;
			coord.y = this._coordinates[index].y;
			coord.z = this._coordinates[index].z;
		}
	},
	getCoordinateCopy: function (i) {
		return new __WEBPACK_IMPORTED_MODULE_2__Coordinate__["a" /* default */](this._coordinates[i]);
	},
	getDimension: function () {
		return this._dimension;
	},
	getX: function (index) {
		return this._coordinates[index].x;
	},
	clone: function () {
		var cloneCoordinates = new Array(this.size()).fill(null);
		for (var i = 0; i < this._coordinates.length; i++) {
			cloneCoordinates[i] = this._coordinates[i].clone();
		}
		return new CoordinateArraySequence(cloneCoordinates, this._dimension);
	},
	expandEnvelope: function (env) {
		for (var i = 0; i < this._coordinates.length; i++) {
			env.expandToInclude(this._coordinates[i]);
		}
		return env;
	},
	copy: function () {
		var cloneCoordinates = new Array(this.size()).fill(null);
		for (var i = 0; i < this._coordinates.length; i++) {
			cloneCoordinates[i] = this._coordinates[i].copy();
		}
		return new CoordinateArraySequence(cloneCoordinates, this._dimension);
	},
	toString: function () {
		if (this._coordinates.length > 0) {
			var strBuf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */](17 * this._coordinates.length);
			strBuf.append('(');
			strBuf.append(this._coordinates[0]);
			for (var i = 1; i < this._coordinates.length; i++) {
				strBuf.append(", ");
				strBuf.append(this._coordinates[i]);
			}
			strBuf.append(')');
			return strBuf.toString();
		} else {
			return "()";
		}
	},
	getY: function (index) {
		return this._coordinates[index].y;
	},
	toCoordinateArray: function () {
		return this._coordinates;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__CoordinateSequence__["a" /* default */], __WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return CoordinateArraySequence;
	}
});
CoordinateArraySequence.serialVersionUID = -915438501601840650;


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Stack;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__EmptyStackException__ = __webpack_require__(223);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__List__ = __webpack_require__(33);



/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
 *
 * @extends {List}
 * @constructor
 * @private
 */
function Stack() {
  /**
   * @type {Array}
   * @private
   */
  this.array_ = [];
};
Stack.prototype = new __WEBPACK_IMPORTED_MODULE_1__List__["a" /* default */]();


/**
 * @override
 */
Stack.prototype.add = function(e) {
  this.array_.push(e);
  return true;
};


/**
 * @override
 */
Stack.prototype.get = function(index) {
  if (index < 0 || index >= this.size()) {
    throw new IndexOutOfBoundsException();
  }

  return this.array_[index];
};


/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.push = function(e) {
  this.array_.push(e);
  return e;
};


/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.pop = function(e) {
  if (this.array_.length === 0) {
    throw new __WEBPACK_IMPORTED_MODULE_0__EmptyStackException__["a" /* default */]();
  }

  return this.array_.pop();
};


/**
 * Looks at the object at the top of this stack without removing it from the
 * stack.
 * @return {Object}
 */
Stack.prototype.peek = function() {
  if (this.array_.length === 0) {
    throw new __WEBPACK_IMPORTED_MODULE_0__EmptyStackException__["a" /* default */]();
  }

  return this.array_[this.array_.length - 1];
};


/**
 * Tests if this stack is empty.
 * @return {boolean} true if and only if this stack contains no items; false
 *         otherwise.
 */
Stack.prototype.empty = function() {
  if (this.array_.length === 0) {
    return true;
  } else {
    return false;
  }
};


/**
 * @return {boolean}
 */
Stack.prototype.isEmpty = function() {
  return this.empty();
};


/**
 * Returns the 1-based position where an object is on this stack. If the object
 * o occurs as an item in this stack, this method returns the distance from the
 * top of the stack of the occurrence nearest the top of the stack; the topmost
 * item on the stack is considered to be at distance 1. The equals method is
 * used to compare o to the items in this stack.
 *
 * NOTE: does not currently actually use equals. (=== is used)
 *
 * @param {Object} o
 * @return {number} the 1-based position from the top of the stack where the
 *         object is located; the return value -1 indicates that the object is
 *         not on the stack.
 */
Stack.prototype.search = function(o) {
  return this.array_.indexOf(o);
};


/**
 * @return {number}
 * @export
 */
Stack.prototype.size = function() {
  return this.array_.length;
};


/**
 * @return {Array}
 */
Stack.prototype.toArray = function() {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PointLocator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__BoundaryNodeRule__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__geom_GeometryCollectionIterator__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__geom_MultiLineString__ = __webpack_require__(28);













function PointLocator() {
	this._boundaryRule = __WEBPACK_IMPORTED_MODULE_7__BoundaryNodeRule__["a" /* default */].OGC_SFS_BOUNDARY_RULE;
	this._isIn = null;
	this._numBoundaries = null;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let boundaryRule = arguments[0];
		if (boundaryRule === null) throw new __WEBPACK_IMPORTED_MODULE_4__java_lang_IllegalArgumentException__["a" /* default */]("Rule must be non-null");
		this._boundaryRule = boundaryRule;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_8__extend__["a" /* default */])(PointLocator.prototype, {
	locateInternal: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_6__geom_Polygon__["a" /* default */]) {
			let p = arguments[0], poly = arguments[1];
			if (poly.isEmpty()) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
			var shell = poly.getExteriorRing();
			var shellLoc = this.locateInPolygonRing(p, shell);
			if (shellLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
			if (shellLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
			for (var i = 0; i < poly.getNumInteriorRing(); i++) {
				var hole = poly.getInteriorRingN(i);
				var holeLoc = this.locateInPolygonRing(p, hole);
				if (holeLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
				if (holeLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
			}
			return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) {
			let p = arguments[0], l = arguments[1];
			if (!l.getEnvelopeInternal().intersects(p)) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
			var pt = l.getCoordinates();
			if (!l.isClosed()) {
				if (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {
					return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
				}
			}
			if (__WEBPACK_IMPORTED_MODULE_2__CGAlgorithms__["a" /* default */].isOnLine(p, pt)) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
			return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Point__["a" /* default */]) {
			let p = arguments[0], pt = arguments[1];
			var ptCoord = pt.getCoordinate();
			if (ptCoord.equals2D(p)) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
			return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
		}
	},
	locateInPolygonRing: function (p, ring) {
		if (!ring.getEnvelopeInternal().intersects(p)) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
		return __WEBPACK_IMPORTED_MODULE_2__CGAlgorithms__["a" /* default */].locatePointInRing(p, ring.getCoordinates());
	},
	intersects: function (p, geom) {
		return this.locate(p, geom) !== __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
	},
	updateLocationInfo: function (loc) {
		if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) this._isIn = true;
		if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) this._numBoundaries++;
	},
	computeLocation: function (p, geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Point__["a" /* default */]) {
			this.updateLocationInfo(this.locateInternal(p, geom));
		}
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) {
			this.updateLocationInfo(this.locateInternal(p, geom));
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_6__geom_Polygon__["a" /* default */]) {
			this.updateLocationInfo(this.locateInternal(p, geom));
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_12__geom_MultiLineString__["a" /* default */]) {
			var ml = geom;
			for (var i = 0; i < ml.getNumGeometries(); i++) {
				var l = ml.getGeometryN(i);
				this.updateLocationInfo(this.locateInternal(p, l));
			}
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_9__geom_MultiPolygon__["a" /* default */]) {
			var mpoly = geom;
			for (var i = 0; i < mpoly.getNumGeometries(); i++) {
				var poly = mpoly.getGeometryN(i);
				this.updateLocationInfo(this.locateInternal(p, poly));
			}
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_11__geom_GeometryCollection__["a" /* default */]) {
			var geomi = new __WEBPACK_IMPORTED_MODULE_10__geom_GeometryCollectionIterator__["a" /* default */](geom);
			while (geomi.hasNext()) {
				var g2 = geomi.next();
				if (g2 !== geom) this.computeLocation(p, g2);
			}
		}
	},
	locate: function (p, geom) {
		if (geom.isEmpty()) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) {
			return this.locateInternal(p, geom);
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_6__geom_Polygon__["a" /* default */]) {
			return this.locateInternal(p, geom);
		}
		this._isIn = false;
		this._numBoundaries = 0;
		this.computeLocation(p, geom);
		if (this._boundaryRule.isInBoundary(this._numBoundaries)) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
		if (this._numBoundaries > 0 || this._isIn) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
		return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PointLocator;
	}
});


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodedSegmentString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SegmentNodeList__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_impl_CoordinateArraySequence__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Octant__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__NodableSegmentString__ = __webpack_require__(241);








function NodedSegmentString() {
	this._nodeList = new __WEBPACK_IMPORTED_MODULE_0__SegmentNodeList__["a" /* default */](this);
	this._pts = null;
	this._data = null;
	let pts = arguments[0], data = arguments[1];
	this._pts = pts;
	this._data = data;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(NodedSegmentString.prototype, {
	getCoordinates: function () {
		return this._pts;
	},
	size: function () {
		return this._pts.length;
	},
	getCoordinate: function (i) {
		return this._pts[i];
	},
	isClosed: function () {
		return this._pts[0].equals(this._pts[this._pts.length - 1]);
	},
	getSegmentOctant: function (index) {
		if (index === this._pts.length - 1) return -1;
		return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
	},
	setData: function (data) {
		this._data = data;
	},
	safeOctant: function (p0, p1) {
		if (p0.equals2D(p1)) return 0;
		return __WEBPACK_IMPORTED_MODULE_4__Octant__["a" /* default */].octant(p0, p1);
	},
	getData: function () {
		return this._data;
	},
	addIntersection: function () {
		if (arguments.length === 2) {
			let intPt = arguments[0], segmentIndex = arguments[1];
			this.addIntersectionNode(intPt, segmentIndex);
		} else if (arguments.length === 4) {
			let li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3];
			var intPt = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](li.getIntersection(intIndex));
			this.addIntersection(intPt, segmentIndex);
		}
	},
	toString: function () {
		return __WEBPACK_IMPORTED_MODULE_1__io_WKTWriter__["a" /* default */].toLineString(new __WEBPACK_IMPORTED_MODULE_2__geom_impl_CoordinateArraySequence__["a" /* default */](this._pts));
	},
	getNodeList: function () {
		return this._nodeList;
	},
	addIntersectionNode: function (intPt, segmentIndex) {
		var normalizedSegmentIndex = segmentIndex;
		var nextSegIndex = normalizedSegmentIndex + 1;
		if (nextSegIndex < this._pts.length) {
			var nextPt = this._pts[nextSegIndex];
			if (intPt.equals2D(nextPt)) {
				normalizedSegmentIndex = nextSegIndex;
			}
		}
		var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
		return ei;
	},
	addIntersections: function (li, segmentIndex, geomIndex) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			this.addIntersection(li, segmentIndex, geomIndex, i);
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_7__NodableSegmentString__["a" /* default */]];
	},
	getClass: function () {
		return NodedSegmentString;
	}
});
NodedSegmentString.getNodedSubstrings = function () {
	if (arguments.length === 1) {
		let segStrings = arguments[0];
		var resultEdgelist = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
		NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
		return resultEdgelist;
	} else if (arguments.length === 2) {
		let segStrings = arguments[0], resultEdgelist = arguments[1];
		for (var i = segStrings.iterator(); i.hasNext(); ) {
			var ss = i.next();
			ss.getNodeList().addSplitEdges(resultEdgelist);
		}
	}
};


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PlanarGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__NodeMap__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__DirectedEdge__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Quadrant__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__NodeFactory__ = __webpack_require__(100);











function PlanarGraph() {
	this._edges = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
	this._nodes = null;
	this._edgeEndList = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
	if (arguments.length === 0) {
		this._nodes = new __WEBPACK_IMPORTED_MODULE_5__NodeMap__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_10__NodeFactory__["a" /* default */]());
	} else if (arguments.length === 1) {
		let nodeFact = arguments[0];
		this._nodes = new __WEBPACK_IMPORTED_MODULE_5__NodeMap__["a" /* default */](nodeFact);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(PlanarGraph.prototype, {
	printEdges: function (out) {
		out.println("Edges:");
		for (var i = 0; i < this._edges.size(); i++) {
			out.println("edge " + i + ":");
			var e = this._edges.get(i);
			e.print(out);
			e.eiList.print(out);
		}
	},
	find: function (coord) {
		return this._nodes.find(coord);
	},
	addNode: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* default */]) {
			let node = arguments[0];
			return this._nodes.addNode(node);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]) {
			let coord = arguments[0];
			return this._nodes.addNode(coord);
		}
	},
	getNodeIterator: function () {
		return this._nodes.iterator();
	},
	linkResultDirectedEdges: function () {
		for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
			var node = nodeit.next();
			node.getEdges().linkResultDirectedEdges();
		}
	},
	debugPrintln: function (o) {
		__WEBPACK_IMPORTED_MODULE_7__java_lang_System__["a" /* default */].out.println(o);
	},
	isBoundaryNode: function (geomIndex, coord) {
		var node = this._nodes.find(coord);
		if (node === null) return false;
		var label = node.getLabel();
		if (label !== null && label.getLocation(geomIndex) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) return true;
		return false;
	},
	linkAllDirectedEdges: function () {
		for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
			var node = nodeit.next();
			node.getEdges().linkAllDirectedEdges();
		}
	},
	matchInSameDirection: function (p0, p1, ep0, ep1) {
		if (!p0.equals(ep0)) return false;
		if (__WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(p0, p1, ep1) === __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].COLLINEAR && __WEBPACK_IMPORTED_MODULE_9__Quadrant__["a" /* default */].quadrant(p0, p1) === __WEBPACK_IMPORTED_MODULE_9__Quadrant__["a" /* default */].quadrant(ep0, ep1)) return true;
		return false;
	},
	getEdgeEnds: function () {
		return this._edgeEndList;
	},
	debugPrint: function (o) {
		__WEBPACK_IMPORTED_MODULE_7__java_lang_System__["a" /* default */].out.print(o);
	},
	getEdgeIterator: function () {
		return this._edges.iterator();
	},
	findEdgeInSameDirection: function (p0, p1) {
		for (var i = 0; i < this._edges.size(); i++) {
			var e = this._edges.get(i);
			var eCoord = e.getCoordinates();
			if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;
			if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;
		}
		return null;
	},
	insertEdge: function (e) {
		this._edges.add(e);
	},
	findEdgeEnd: function (e) {
		for (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {
			var ee = i.next();
			if (ee.getEdge() === e) return ee;
		}
		return null;
	},
	addEdges: function (edgesToAdd) {
		for (var it = edgesToAdd.iterator(); it.hasNext(); ) {
			var e = it.next();
			this._edges.add(e);
			var de1 = new __WEBPACK_IMPORTED_MODULE_6__DirectedEdge__["a" /* default */](e, true);
			var de2 = new __WEBPACK_IMPORTED_MODULE_6__DirectedEdge__["a" /* default */](e, false);
			de1.setSym(de2);
			de2.setSym(de1);
			this.add(de1);
			this.add(de2);
		}
	},
	add: function (e) {
		this._nodes.add(e);
		this._edgeEndList.add(e);
	},
	getNodes: function () {
		return this._nodes.values();
	},
	findEdge: function (p0, p1) {
		for (var i = 0; i < this._edges.size(); i++) {
			var e = this._edges.get(i);
			var eCoord = e.getCoordinates();
			if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;
		}
		return null;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PlanarGraph;
	}
});
PlanarGraph.linkResultDirectedEdges = function (nodes) {
	for (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {
		var node = nodeit.next();
		node.getEdges().linkResultDirectedEdges();
	}
};


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__GraphComponent__ = __webpack_require__(135);





function Node() {
	__WEBPACK_IMPORTED_MODULE_4__GraphComponent__["a" /* default */].apply(this);
	this._coord = null;
	this._edges = null;
	let coord = arguments[0], edges = arguments[1];
	this._coord = coord;
	this._edges = edges;
	this._label = new __WEBPACK_IMPORTED_MODULE_2__Label__["a" /* default */](0, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE);
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(Node, __WEBPACK_IMPORTED_MODULE_4__GraphComponent__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Node.prototype, {
	isIncidentEdgeInResult: function () {
		for (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {
			var de = it.next();
			if (de.getEdge().isInResult()) return true;
		}
		return false;
	},
	isIsolated: function () {
		return this._label.getGeometryCount() === 1;
	},
	getCoordinate: function () {
		return this._coord;
	},
	print: function (out) {
		out.println("node " + this._coord + " lbl: " + this._label);
	},
	computeIM: function (im) {},
	computeMergedLocation: function (label2, eltIndex) {
		var loc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE;
		loc = this._label.getLocation(eltIndex);
		if (!label2.isNull(eltIndex)) {
			var nLoc = label2.getLocation(eltIndex);
			if (loc !== __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) loc = nLoc;
		}
		return loc;
	},
	setLabel: function () {
		if (arguments.length === 2) {
			let argIndex = arguments[0], onLocation = arguments[1];
			if (this._label === null) {
				this._label = new __WEBPACK_IMPORTED_MODULE_2__Label__["a" /* default */](argIndex, onLocation);
			} else this._label.setLocation(argIndex, onLocation);
		} else return __WEBPACK_IMPORTED_MODULE_4__GraphComponent__["a" /* default */].prototype.setLabel.apply(this, arguments);
	},
	getEdges: function () {
		return this._edges;
	},
	mergeLabel: function () {
		if (arguments[0] instanceof Node) {
			let n = arguments[0];
			this.mergeLabel(n._label);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__Label__["a" /* default */]) {
			let label2 = arguments[0];
			for (var i = 0; i < 2; i++) {
				var loc = this.computeMergedLocation(label2, i);
				var thisLoc = this._label.getLocation(i);
				if (thisLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE) this._label.setLocation(i, loc);
			}
		}
	},
	add: function (e) {
		this._edges.insert(e);
		e.setNode(this);
	},
	setLabelBoundary: function (argIndex) {
		if (this._label === null) return null;
		var loc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE;
		if (this._label !== null) loc = this._label.getLocation(argIndex);
		var newLoc = null;
		switch (loc) {
			case __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY:
				newLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
				break;
			case __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR:
				newLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
				break;
			default:
				newLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
				break;
		}
		this._label.setLocation(argIndex, newLoc);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Node;
	}
});


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_HashMap__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__geom_MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__index_SimpleMCSweepLineIntersector__ = __webpack_require__(252);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__algorithm_BoundaryNodeRule__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__index_SegmentIntersector__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__geom_Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__algorithm_locate_IndexedPointInAreaLocator__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__Edge__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__geom_MultiLineString__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__PlanarGraph__ = __webpack_require__(64);



























function GeometryGraph() {
	__WEBPACK_IMPORTED_MODULE_26__PlanarGraph__["a" /* default */].apply(this);
	this._parentGeom = null;
	this._lineEdgeMap = new __WEBPACK_IMPORTED_MODULE_3__java_util_HashMap__["a" /* default */]();
	this._boundaryNodeRule = null;
	this._useBoundaryDeterminationRule = true;
	this._argIndex = null;
	this._boundaryNodes = null;
	this._hasTooFewPoints = false;
	this._invalidPoint = null;
	this._areaPtLocator = null;
	this._ptLocator = new __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__["a" /* default */]();
	if (arguments.length === 2) {
		let argIndex = arguments[0], parentGeom = arguments[1];
		GeometryGraph.call(this, argIndex, parentGeom, __WEBPACK_IMPORTED_MODULE_13__algorithm_BoundaryNodeRule__["a" /* default */].OGC_SFS_BOUNDARY_RULE);
	} else if (arguments.length === 3) {
		let argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];
		this._argIndex = argIndex;
		this._parentGeom = parentGeom;
		this._boundaryNodeRule = boundaryNodeRule;
		if (parentGeom !== null) {
			this.add(parentGeom);
		}
	}
}
Object(__WEBPACK_IMPORTED_MODULE_24__inherits__["a" /* default */])(GeometryGraph, __WEBPACK_IMPORTED_MODULE_26__PlanarGraph__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_14__extend__["a" /* default */])(GeometryGraph.prototype, {
	insertBoundaryPoint: function (argIndex, coord) {
		var n = this._nodes.addNode(coord);
		var lbl = n.getLabel();
		var boundaryCount = 1;
		var loc = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE;
		loc = lbl.getLocation(argIndex, __WEBPACK_IMPORTED_MODULE_6__Position__["a" /* default */].ON);
		if (loc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY) boundaryCount++;
		var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
		lbl.setLocation(argIndex, newLoc);
	},
	computeSelfNodes: function () {
		if (arguments.length === 2) {
			let li = arguments[0], computeRingSelfNodes = arguments[1];
			return this.computeSelfNodes(li, computeRingSelfNodes, false);
		} else if (arguments.length === 3) {
			let li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];
			var si = new __WEBPACK_IMPORTED_MODULE_15__index_SegmentIntersector__["a" /* default */](li, true, false);
			si.setIsDoneIfProperInt(isDoneIfProperInt);
			var esi = this.createEdgeSetIntersector();
			var isRings = this._parentGeom instanceof __WEBPACK_IMPORTED_MODULE_12__geom_LinearRing__["a" /* default */] || this._parentGeom instanceof __WEBPACK_IMPORTED_MODULE_9__geom_Polygon__["a" /* default */] || this._parentGeom instanceof __WEBPACK_IMPORTED_MODULE_16__geom_MultiPolygon__["a" /* default */];
			var computeAllSegments = computeRingSelfNodes || !isRings;
			esi.computeIntersections(this._edges, si, computeAllSegments);
			this.addSelfIntersectionNodes(this._argIndex);
			return si;
		}
	},
	computeSplitEdges: function (edgelist) {
		for (var i = this._edges.iterator(); i.hasNext(); ) {
			var e = i.next();
			e.eiList.addSplitEdges(edgelist);
		}
	},
	computeEdgeIntersections: function (g, li, includeProper) {
		var si = new __WEBPACK_IMPORTED_MODULE_15__index_SegmentIntersector__["a" /* default */](li, includeProper, true);
		si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
		var esi = this.createEdgeSetIntersector();
		esi.computeIntersections(this._edges, g._edges, si);
		return si;
	},
	getGeometry: function () {
		return this._parentGeom;
	},
	getBoundaryNodeRule: function () {
		return this._boundaryNodeRule;
	},
	hasTooFewPoints: function () {
		return this._hasTooFewPoints;
	},
	addPoint: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_8__geom_Point__["a" /* default */]) {
			let p = arguments[0];
			var coord = p.getCoordinate();
			this.insertPoint(this._argIndex, coord, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_7__geom_Coordinate__["a" /* default */]) {
			let pt = arguments[0];
			this.insertPoint(this._argIndex, pt, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR);
		}
	},
	addPolygon: function (p) {
		this.addPolygonRing(p.getExteriorRing(), __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			this.addPolygonRing(hole, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR);
		}
	},
	addEdge: function (e) {
		this.insertEdge(e);
		var coord = e.getCoordinates();
		this.insertPoint(this._argIndex, coord[0], __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY);
		this.insertPoint(this._argIndex, coord[coord.length - 1], __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY);
	},
	addLineString: function (line) {
		var coord = __WEBPACK_IMPORTED_MODULE_19__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(line.getCoordinates());
		if (coord.length < 2) {
			this._hasTooFewPoints = true;
			this._invalidPoint = coord[0];
			return null;
		}
		var e = new __WEBPACK_IMPORTED_MODULE_23__Edge__["a" /* default */](coord, new __WEBPACK_IMPORTED_MODULE_17__Label__["a" /* default */](this._argIndex, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR));
		this._lineEdgeMap.put(line, e);
		this.insertEdge(e);
		__WEBPACK_IMPORTED_MODULE_22__util_Assert__["a" /* default */].isTrue(coord.length >= 2, "found LineString with single point");
		this.insertBoundaryPoint(this._argIndex, coord[0]);
		this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
	},
	getInvalidPoint: function () {
		return this._invalidPoint;
	},
	getBoundaryPoints: function () {
		var coll = this.getBoundaryNodes();
		var pts = new Array(coll.size()).fill(null);
		var i = 0;
		for (var it = coll.iterator(); it.hasNext(); ) {
			var node = it.next();
			pts[i++] = node.getCoordinate().copy();
		}
		return pts;
	},
	getBoundaryNodes: function () {
		if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
		return this._boundaryNodes;
	},
	addSelfIntersectionNode: function (argIndex, coord, loc) {
		if (this.isBoundaryNode(argIndex, coord)) return null;
		if (loc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);
	},
	addPolygonRing: function (lr, cwLeft, cwRight) {
		if (lr.isEmpty()) return null;
		var coord = __WEBPACK_IMPORTED_MODULE_19__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(lr.getCoordinates());
		if (coord.length < 4) {
			this._hasTooFewPoints = true;
			this._invalidPoint = coord[0];
			return null;
		}
		var left = cwLeft;
		var right = cwRight;
		if (__WEBPACK_IMPORTED_MODULE_4__algorithm_CGAlgorithms__["a" /* default */].isCCW(coord)) {
			left = cwRight;
			right = cwLeft;
		}
		var e = new __WEBPACK_IMPORTED_MODULE_23__Edge__["a" /* default */](coord, new __WEBPACK_IMPORTED_MODULE_17__Label__["a" /* default */](this._argIndex, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY, left, right));
		this._lineEdgeMap.put(lr, e);
		this.insertEdge(e);
		this.insertPoint(this._argIndex, coord[0], __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY);
	},
	insertPoint: function (argIndex, coord, onLocation) {
		var n = this._nodes.addNode(coord);
		var lbl = n.getLabel();
		if (lbl === null) {
			n._label = new __WEBPACK_IMPORTED_MODULE_17__Label__["a" /* default */](argIndex, onLocation);
		} else lbl.setLocation(argIndex, onLocation);
	},
	createEdgeSetIntersector: function () {
		return new __WEBPACK_IMPORTED_MODULE_11__index_SimpleMCSweepLineIntersector__["a" /* default */]();
	},
	addSelfIntersectionNodes: function (argIndex) {
		for (var i = this._edges.iterator(); i.hasNext(); ) {
			var e = i.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {
				var ei = eiIt.next();
				this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
			}
		}
	},
	add: function () {
		if (arguments.length === 1) {
			let g = arguments[0];
			if (g.isEmpty()) return null;
			if (g instanceof __WEBPACK_IMPORTED_MODULE_16__geom_MultiPolygon__["a" /* default */]) this._useBoundaryDeterminationRule = false;
			if (g instanceof __WEBPACK_IMPORTED_MODULE_9__geom_Polygon__["a" /* default */]) this.addPolygon(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_2__geom_LineString__["a" /* default */]) this.addLineString(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_8__geom_Point__["a" /* default */]) this.addPoint(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_10__geom_MultiPoint__["a" /* default */]) this.addCollection(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_25__geom_MultiLineString__["a" /* default */]) this.addCollection(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_16__geom_MultiPolygon__["a" /* default */]) this.addCollection(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_18__geom_GeometryCollection__["a" /* default */]) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());
		} else return __WEBPACK_IMPORTED_MODULE_26__PlanarGraph__["a" /* default */].prototype.add.apply(this, arguments);
	},
	addCollection: function (gc) {
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = gc.getGeometryN(i);
			this.add(g);
		}
	},
	locate: function (pt) {
		if (Object(__WEBPACK_IMPORTED_MODULE_5__hasInterface__["a" /* default */])(this._parentGeom, __WEBPACK_IMPORTED_MODULE_20__geom_Polygonal__["a" /* default */]) && this._parentGeom.getNumGeometries() > 50) {
			if (this._areaPtLocator === null) {
				this._areaPtLocator = new __WEBPACK_IMPORTED_MODULE_21__algorithm_locate_IndexedPointInAreaLocator__["a" /* default */](this._parentGeom);
			}
			return this._areaPtLocator.locate(pt);
		}
		return this._ptLocator.locate(pt, this._parentGeom);
	},
	findEdge: function () {
		if (arguments.length === 1) {
			let line = arguments[0];
			return this._lineEdgeMap.get(line);
		} else return __WEBPACK_IMPORTED_MODULE_26__PlanarGraph__["a" /* default */].prototype.findEdge.apply(this, arguments);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryGraph;
	}
});
GeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {
	return boundaryNodeRule.isInBoundary(boundaryCount) ? __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY : __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR;
};


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LinearComponentExtracter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);








function LinearComponentExtracter() {
	this._lines = null;
	this._isForcedToLineString = false;
	if (arguments.length === 1) {
		let lines = arguments[0];
		this._lines = lines;
	} else if (arguments.length === 2) {
		let lines = arguments[0], isForcedToLineString = arguments[1];
		this._lines = lines;
		this._isForcedToLineString = isForcedToLineString;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(LinearComponentExtracter.prototype, {
	filter: function (geom) {
		if (this._isForcedToLineString && geom instanceof __WEBPACK_IMPORTED_MODULE_4__LinearRing__["a" /* default */]) {
			var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
			this._lines.add(line);
			return null;
		}
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]) this._lines.add(geom);
	},
	setForceToLineString: function (isForcedToLineString) {
		this._isForcedToLineString = isForcedToLineString;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__GeometryComponentFilter__["a" /* default */]];
	},
	getClass: function () {
		return LinearComponentExtracter;
	}
});
LinearComponentExtracter.getGeometry = function () {
	if (arguments.length === 1) {
		let geom = arguments[0];
		return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
	} else if (arguments.length === 2) {
		let geom = arguments[0], forceToLineString = arguments[1];
		return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));
	}
};
LinearComponentExtracter.getLines = function () {
	if (arguments.length === 1) {
		let geom = arguments[0];
		return LinearComponentExtracter.getLines(geom, false);
	} else if (arguments.length === 2) {
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */]) && Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let geoms = arguments[0], lines = arguments[1];
			for (var i = geoms.iterator(); i.hasNext(); ) {
				var g = i.next();
				LinearComponentExtracter.getLines(g, lines);
			}
			return lines;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */] && typeof arguments[1] === "boolean") {
			let geom = arguments[0], forceToLineString = arguments[1];
			var lines = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */]();
			geom.apply(new LinearComponentExtracter(lines, forceToLineString));
			return lines;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */] && Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let geom = arguments[0], lines = arguments[1];
			if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]) {
				lines.add(geom);
			} else {
				geom.apply(new LinearComponentExtracter(lines));
			}
			return lines;
		}
	} else if (arguments.length === 3) {
		if (typeof arguments[2] === "boolean" && (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */]) && Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */]))) {
			let geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];
			for (var i = geoms.iterator(); i.hasNext(); ) {
				var g = i.next();
				LinearComponentExtracter.getLines(g, lines, forceToLineString);
			}
			return lines;
		} else if (typeof arguments[2] === "boolean" && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Geometry__["a" /* default */] && Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */]))) {
			let geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];
			geom.apply(new LinearComponentExtracter(lines, forceToLineString));
			return lines;
		}
	}
};


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DirectedEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geomgraph_Quadrant__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__GraphComponent__ = __webpack_require__(81);







function DirectedEdge() {
	__WEBPACK_IMPORTED_MODULE_6__GraphComponent__["a" /* default */].apply(this);
	this._parentEdge = null;
	this._from = null;
	this._to = null;
	this._p0 = null;
	this._p1 = null;
	this._sym = null;
	this._edgeDirection = null;
	this._quadrant = null;
	this._angle = null;
	let from = arguments[0], to = arguments[1], directionPt = arguments[2], edgeDirection = arguments[3];
	this._from = from;
	this._to = to;
	this._edgeDirection = edgeDirection;
	this._p0 = from.getCoordinate();
	this._p1 = directionPt;
	var dx = this._p1.x - this._p0.x;
	var dy = this._p1.y - this._p0.y;
	this._quadrant = __WEBPACK_IMPORTED_MODULE_4__geomgraph_Quadrant__["a" /* default */].quadrant(dx, dy);
	this._angle = Math.atan2(dy, dx);
}
Object(__WEBPACK_IMPORTED_MODULE_5__inherits__["a" /* default */])(DirectedEdge, __WEBPACK_IMPORTED_MODULE_6__GraphComponent__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(DirectedEdge.prototype, {
	isRemoved: function () {
		return this._parentEdge === null;
	},
	compareDirection: function (e) {
		if (this._quadrant > e._quadrant) return 1;
		if (this._quadrant < e._quadrant) return -1;
		return __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(e._p0, e._p1, this._p1);
	},
	getCoordinate: function () {
		return this._from.getCoordinate();
	},
	print: function (out) {
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		out.print("  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + this._angle);
	},
	getDirectionPt: function () {
		return this._p1;
	},
	getAngle: function () {
		return this._angle;
	},
	compareTo: function (obj) {
		var de = obj;
		return this.compareDirection(de);
	},
	getFromNode: function () {
		return this._from;
	},
	getSym: function () {
		return this._sym;
	},
	setEdge: function (parentEdge) {
		this._parentEdge = parentEdge;
	},
	remove: function () {
		this._sym = null;
		this._parentEdge = null;
	},
	getEdge: function () {
		return this._parentEdge;
	},
	getQuadrant: function () {
		return this._quadrant;
	},
	setSym: function (sym) {
		this._sym = sym;
	},
	getToNode: function () {
		return this._to;
	},
	getEdgeDirection: function () {
		return this._edgeDirection;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return DirectedEdge;
	}
});
DirectedEdge.toEdges = function (dirEdges) {
	var edges = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
	for (var i = dirEdges.iterator(); i.hasNext(); ) {
		edges.add(i.next()._parentEdge);
	}
	return edges;
};


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LinearIterator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Lineal__ = __webpack_require__(90);




function LinearIterator() {
	this._linearGeom = null;
	this._numLines = null;
	this._currentLine = null;
	this._componentIndex = 0;
	this._vertexIndex = 0;
	if (arguments.length === 1) {
		let linear = arguments[0];
		LinearIterator.call(this, linear, 0, 0);
	} else if (arguments.length === 2) {
		let linear = arguments[0], start = arguments[1];
		LinearIterator.call(this, linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));
	} else if (arguments.length === 3) {
		let linearGeom = arguments[0], componentIndex = arguments[1], vertexIndex = arguments[2];
		if (!Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(linearGeom, __WEBPACK_IMPORTED_MODULE_3__geom_Lineal__["a" /* default */])) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Lineal geometry is required");
		this._linearGeom = linearGeom;
		this._numLines = linearGeom.getNumGeometries();
		this._componentIndex = componentIndex;
		this._vertexIndex = vertexIndex;
		this.loadCurrentLine();
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LinearIterator.prototype, {
	getComponentIndex: function () {
		return this._componentIndex;
	},
	getLine: function () {
		return this._currentLine;
	},
	getVertexIndex: function () {
		return this._vertexIndex;
	},
	getSegmentEnd: function () {
		if (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);
		return null;
	},
	next: function () {
		if (!this.hasNext()) return null;
		this._vertexIndex++;
		if (this._vertexIndex >= this._currentLine.getNumPoints()) {
			this._componentIndex++;
			this.loadCurrentLine();
			this._vertexIndex = 0;
		}
	},
	loadCurrentLine: function () {
		if (this._componentIndex >= this._numLines) {
			this._currentLine = null;
			return null;
		}
		this._currentLine = this._linearGeom.getGeometryN(this._componentIndex);
	},
	getSegmentStart: function () {
		return this._currentLine.getCoordinateN(this._vertexIndex);
	},
	isEndOfLine: function () {
		if (this._componentIndex >= this._numLines) return false;
		if (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;
		return true;
	},
	hasNext: function () {
		if (this._componentIndex >= this._numLines) return false;
		if (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;
		return true;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LinearIterator;
	}
});
LinearIterator.segmentEndVertexIndex = function (loc) {
	if (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;
	return loc.getSegmentIndex();
};


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "earthRadius", function() { return earthRadius; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factors", function() { return factors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unitsFactors", function() { return unitsFactors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaFactors", function() { return areaFactors; });
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["geometry"] = geometry;
/* harmony export (immutable) */ __webpack_exports__["point"] = point;
/* harmony export (immutable) */ __webpack_exports__["polygon"] = polygon;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["featureCollection"] = featureCollection;
/* harmony export (immutable) */ __webpack_exports__["multiLineString"] = multiLineString;
/* harmony export (immutable) */ __webpack_exports__["multiPoint"] = multiPoint;
/* harmony export (immutable) */ __webpack_exports__["multiPolygon"] = multiPolygon;
/* harmony export (immutable) */ __webpack_exports__["geometryCollection"] = geometryCollection;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["radiansToDistance"] = radiansToDistance;
/* harmony export (immutable) */ __webpack_exports__["distanceToRadians"] = distanceToRadians;
/* harmony export (immutable) */ __webpack_exports__["distanceToDegrees"] = distanceToDegrees;
/* harmony export (immutable) */ __webpack_exports__["bearingToAngle"] = bearingToAngle;
/* harmony export (immutable) */ __webpack_exports__["radians2degrees"] = radians2degrees;
/* harmony export (immutable) */ __webpack_exports__["degrees2radians"] = degrees2radians;
/* harmony export (immutable) */ __webpack_exports__["convertDistance"] = convertDistance;
/* harmony export (immutable) */ __webpack_exports__["convertArea"] = convertArea;
/* harmony export (immutable) */ __webpack_exports__["isNumber"] = isNumber;
/* harmony export (immutable) */ __webpack_exports__["isObject"] = isObject;
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 */
var earthRadius = 6371008.8;

/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 */
var factors = {
    meters: earthRadius,
    metres: earthRadius,
    millimeters: earthRadius * 1000,
    millimetres: earthRadius * 1000,
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    kilometers: earthRadius / 1000,
    kilometres: earthRadius / 1000,
    miles: earthRadius / 1609.344,
    nauticalmiles: earthRadius / 1852,
    inches: earthRadius * 39.370,
    yards: earthRadius / 1.0936,
    feet: earthRadius * 3.28084,
    radians: 1,
    degrees: earthRadius / 111325,
};

/**
 * Units of measurement factors based on 1 meter.
 */
var unitsFactors = {
    meters: 1,
    metres: 1,
    millimeters: 1000,
    millimetres: 1000,
    centimeters: 100,
    centimetres: 100,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    miles: 1 / 1609.344,
    nauticalmiles: 1 / 1852,
    inches: 39.370,
    yards: 1 / 1.0936,
    feet: 3.28084,
    radians: 1 / earthRadius,
    degrees: 1 / 111325,
};

/**
 * Area of measurement factors based on 1 square meter.
 */
var areaFactors = {
    meters: 1,
    metres: 1,
    millimeters: 1000000,
    millimetres: 1000000,
    centimeters: 10000,
    centimetres: 10000,
    kilometers: 0.000001,
    kilometres: 0.000001,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    if (units && typeof units !== 'string') throw new Error('units must be a string');
    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error(units + ' units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    if (units && typeof units !== 'string') throw new Error('units must be a string');
    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error(units + ' units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}

/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit='kilometers'] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit='meters'] of the distance
 * @param {string} [finalUnit='kilometers'] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return (!!input) && (input.constructor === Object);
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NoSuchElementException;
/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function NoSuchElementException(message) {
  this.message = message || '';
};
NoSuchElementException.prototype = new Error();


/**
 * @type {string}
 */
NoSuchElementException.prototype.name = 'NoSuchElementException';


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = HashMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Map__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__HashSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Map__ = __webpack_require__(220);





let MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? __WEBPACK_IMPORTED_MODULE_3__Map__["a" /* default */] : Map

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
 *
 * @extends {javascript.util.Map}
 * @constructor
 * @private
 */
function HashMap () {
  /**
   * @type {Object}
   * @private
  */
  this.map_ = new MapImpl()
}
HashMap.prototype = new __WEBPACK_IMPORTED_MODULE_1__Map__["a" /* default */]()

/**
 * @override
 */
HashMap.prototype.get = function (key) {
  return this.map_.get(key) || null
}

/**
 * @override
 */
HashMap.prototype.put = function (key, value) {
  this.map_.set(key, value)
  return value
}

/**
 * @override
 */
HashMap.prototype.values = function () {
  const arrayList = new __WEBPACK_IMPORTED_MODULE_0__ArrayList__["a" /* default */]()
  const it = this.map_.values()
  let o = it.next()
  while (!o.done) {
    arrayList.add(o.value)
    o = it.next()
  }
  return arrayList
}

/**
 * @override
 */
HashMap.prototype.entrySet = function () {
  const hashSet = new __WEBPACK_IMPORTED_MODULE_2__HashSet__["a" /* default */]()
  this.map_.entries().forEach(entry => hashSet.add(entry))
  return hashSet
}

/**
 * @override
 */
HashMap.prototype.size = function () {
  return this.map_.size()
}


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SnapIfNeededOverlayOp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SnapOverlayOp__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__OverlayOp__ = __webpack_require__(42);




function SnapIfNeededOverlayOp() {
	this._geom = new Array(2).fill(null);
	let g1 = arguments[0], g2 = arguments[1];
	this._geom[0] = g1;
	this._geom[1] = g2;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(SnapIfNeededOverlayOp.prototype, {
	getResultGeometry: function (opCode) {
		var result = null;
		var isSuccess = false;
		var savedException = null;
		try {
			result = __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].overlayOp(this._geom[0], this._geom[1], opCode);
			var isValid = true;
			if (isValid) isSuccess = true;
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */]) {
				savedException = ex;
			} else throw ex;
		} finally {}
		if (!isSuccess) {
			try {
				result = __WEBPACK_IMPORTED_MODULE_0__SnapOverlayOp__["a" /* default */].overlayOp(this._geom[0], this._geom[1], opCode);
			} catch (ex) {
				if (ex instanceof __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */]) {
					throw savedException;
				} else throw ex;
			} finally {}
		}
		return result;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SnapIfNeededOverlayOp;
	}
});
SnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {
	var op = new SnapIfNeededOverlayOp(g0, g1);
	return op.getResultGeometry(opCode);
};
SnapIfNeededOverlayOp.union = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].UNION);
};
SnapIfNeededOverlayOp.intersection = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].INTERSECTION);
};
SnapIfNeededOverlayOp.symDifference = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].SYMDIFFERENCE);
};
SnapIfNeededOverlayOp.difference = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].DIFFERENCE);
};


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryTransformer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__MultiLineString__ = __webpack_require__(28);












function GeometryTransformer() {
	this._inputGeom = null;
	this._factory = null;
	this._pruneEmptyGeometry = true;
	this._preserveGeometryCollectionType = true;
	this._preserveCollections = false;
	this._preserveType = false;
}
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(GeometryTransformer.prototype, {
	transformPoint: function (geom, parent) {
		return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
	},
	transformPolygon: function (geom, parent) {
		var isAllValidLinearRings = true;
		var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
		if (shell === null || !(shell instanceof __WEBPACK_IMPORTED_MODULE_6__LinearRing__["a" /* default */]) || shell.isEmpty()) isAllValidLinearRings = false;
		var holes = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumInteriorRing(); i++) {
			var hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
			if (hole === null || hole.isEmpty()) {
				continue;
			}
			if (!(hole instanceof __WEBPACK_IMPORTED_MODULE_6__LinearRing__["a" /* default */])) isAllValidLinearRings = false;
			holes.add(hole);
		}
		if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([])); else {
			var components = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
			if (shell !== null) components.add(shell);
			components.addAll(holes);
			return this._factory.buildGeometry(components);
		}
	},
	createCoordinateSequence: function (coords) {
		return this._factory.getCoordinateSequenceFactory().create(coords);
	},
	getInputGeometry: function () {
		return this._inputGeom;
	},
	transformMultiLineString: function (geom, parent) {
		var transGeomList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
			if (transformGeom === null) continue;
			if (transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList);
	},
	transformCoordinates: function (coords, parent) {
		return this.copy(coords);
	},
	transformLineString: function (geom, parent) {
		return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
	},
	transformMultiPoint: function (geom, parent) {
		var transGeomList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
			if (transformGeom === null) continue;
			if (transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList);
	},
	transformMultiPolygon: function (geom, parent) {
		var transGeomList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
			if (transformGeom === null) continue;
			if (transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList);
	},
	copy: function (seq) {
		return seq.copy();
	},
	transformGeometryCollection: function (geom, parent) {
		var transGeomList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transform(geom.getGeometryN(i));
			if (transformGeom === null) continue;
			if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(__WEBPACK_IMPORTED_MODULE_1__GeometryFactory__["a" /* default */].toGeometryArray(transGeomList));
		return this._factory.buildGeometry(transGeomList);
	},
	transform: function (inputGeom) {
		this._inputGeom = inputGeom;
		this._factory = inputGeom.getFactory();
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_3__Point__["a" /* default */]) return this.transformPoint(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_5__MultiPoint__["a" /* default */]) return this.transformMultiPoint(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_6__LinearRing__["a" /* default */]) return this.transformLinearRing(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]) return this.transformLineString(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_11__MultiLineString__["a" /* default */]) return this.transformMultiLineString(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_4__Polygon__["a" /* default */]) return this.transformPolygon(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_8__MultiPolygon__["a" /* default */]) return this.transformMultiPolygon(inputGeom, null);
		if (inputGeom instanceof __WEBPACK_IMPORTED_MODULE_9__GeometryCollection__["a" /* default */]) return this.transformGeometryCollection(inputGeom, null);
		throw new __WEBPACK_IMPORTED_MODULE_2__java_lang_IllegalArgumentException__["a" /* default */]("Unknown Geometry subtype: " + inputGeom.getClass().getName());
	},
	transformLinearRing: function (geom, parent) {
		var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
		if (seq === null) return this._factory.createLinearRing(null);
		var seqSize = seq.size();
		if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);
		return this._factory.createLinearRing(seq);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryTransformer;
	}
});


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MCIndexNoder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_strtree_STRtree__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__NodedSegmentString__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_chain_MonotoneChainOverlapAction__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__index_chain_MonotoneChainBuilder__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__SinglePassNoder__ = __webpack_require__(244);








function MCIndexNoder() {
	this._monoChains = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
	this._index = new __WEBPACK_IMPORTED_MODULE_0__index_strtree_STRtree__["a" /* default */]();
	this._idCounter = 0;
	this._nodedSegStrings = null;
	this._nOverlaps = 0;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let si = arguments[0];
		__WEBPACK_IMPORTED_MODULE_7__SinglePassNoder__["a" /* default */].call(this, si);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_6__inherits__["a" /* default */])(MCIndexNoder, __WEBPACK_IMPORTED_MODULE_7__SinglePassNoder__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(MCIndexNoder.prototype, {
	getMonotoneChains: function () {
		return this._monoChains;
	},
	getNodedSubstrings: function () {
		return __WEBPACK_IMPORTED_MODULE_1__NodedSegmentString__["a" /* default */].getNodedSubstrings(this._nodedSegStrings);
	},
	getIndex: function () {
		return this._index;
	},
	add: function (segStr) {
		var segChains = __WEBPACK_IMPORTED_MODULE_4__index_chain_MonotoneChainBuilder__["a" /* default */].getChains(segStr.getCoordinates(), segStr);
		for (var i = segChains.iterator(); i.hasNext(); ) {
			var mc = i.next();
			mc.setId(this._idCounter++);
			this._index.insert(mc.getEnvelope(), mc);
			this._monoChains.add(mc);
		}
	},
	computeNodes: function (inputSegStrings) {
		this._nodedSegStrings = inputSegStrings;
		for (var i = inputSegStrings.iterator(); i.hasNext(); ) {
			this.add(i.next());
		}
		this.intersectChains();
	},
	intersectChains: function () {
		var overlapAction = new SegmentOverlapAction(this._segInt);
		for (var i = this._monoChains.iterator(); i.hasNext(); ) {
			var queryChain = i.next();
			var overlapChains = this._index.query(queryChain.getEnvelope());
			for (var j = overlapChains.iterator(); j.hasNext(); ) {
				var testChain = j.next();
				if (testChain.getId() > queryChain.getId()) {
					queryChain.computeOverlaps(testChain, overlapAction);
					this._nOverlaps++;
				}
				if (this._segInt.isDone()) return null;
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MCIndexNoder;
	}
});
function SegmentOverlapAction() {
	__WEBPACK_IMPORTED_MODULE_2__index_chain_MonotoneChainOverlapAction__["a" /* default */].apply(this);
	this._si = null;
	let si = arguments[0];
	this._si = si;
}
Object(__WEBPACK_IMPORTED_MODULE_6__inherits__["a" /* default */])(SegmentOverlapAction, __WEBPACK_IMPORTED_MODULE_2__index_chain_MonotoneChainOverlapAction__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(SegmentOverlapAction.prototype, {
	overlap: function () {
		if (arguments.length === 4) {
			let mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];
			var ss1 = mc1.getContext();
			var ss2 = mc2.getContext();
			this._si.processIntersections(ss1, start1, ss2, start2);
		} else return __WEBPACK_IMPORTED_MODULE_2__index_chain_MonotoneChainOverlapAction__["a" /* default */].prototype.overlap.apply(this, arguments);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SegmentOverlapAction;
	}
});
MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = STRtree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_PriorityQueue__ = __webpack_require__(234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ItemVisitor__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__SpatialIndex__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__AbstractNode__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__BoundablePair__ = __webpack_require__(235);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__java_util_Comparator__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__java_util_List__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__ItemDistance__ = __webpack_require__(237);



















function STRtree() {
	if (arguments.length === 0) {
		STRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);
	} else if (arguments.length === 1) {
		let nodeCapacity = arguments[0];
		__WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].call(this, nodeCapacity);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_15__inherits__["a" /* default */])(STRtree, __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(STRtree.prototype, {
	createParentBoundablesFromVerticalSlices: function (verticalSlices, newLevel) {
		__WEBPACK_IMPORTED_MODULE_14__util_Assert__["a" /* default */].isTrue(verticalSlices.length > 0);
		var parentBoundables = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < verticalSlices.length; i++) {
			parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
		}
		return parentBoundables;
	},
	createNode: function (level) {
		return new STRtreeNode(level);
	},
	size: function () {
		if (arguments.length === 0) {
			return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.size.call(this);
		} else return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.size.apply(this, arguments);
	},
	insert: function () {
		if (arguments.length === 2) {
			let itemEnv = arguments[0], item = arguments[1];
			if (itemEnv.isNull()) {
				return null;
			}
			__WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.insert.call(this, itemEnv, item);
		} else return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.insert.apply(this, arguments);
	},
	getIntersectsOp: function () {
		return STRtree.intersectsOp;
	},
	verticalSlices: function (childBoundables, sliceCount) {
		var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
		var slices = new Array(sliceCount).fill(null);
		var i = childBoundables.iterator();
		for (var j = 0; j < sliceCount; j++) {
			slices[j] = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
			var boundablesAddedToSlice = 0;
			while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
				var childBoundable = i.next();
				slices[j].add(childBoundable);
				boundablesAddedToSlice++;
			}
		}
		return slices;
	},
	query: function () {
		if (arguments.length === 1) {
			let searchEnv = arguments[0];
			return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.query.call(this, searchEnv);
		} else if (arguments.length === 2) {
			let searchEnv = arguments[0], visitor = arguments[1];
			__WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.query.call(this, searchEnv, visitor);
		} else if (arguments.length === 3) {
			if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_3__ItemVisitor__["a" /* default */]) && (arguments[0] instanceof Object && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_5__AbstractNode__["a" /* default */])) {
				let searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];
				__WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.query.call(this, searchBounds, node, visitor);
			} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_16__java_util_List__["a" /* default */]) && (arguments[0] instanceof Object && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_5__AbstractNode__["a" /* default */])) {
				let searchBounds = arguments[0], node = arguments[1], matches = arguments[2];
				__WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.query.call(this, searchBounds, node, matches);
			}
		}
	},
	getComparator: function () {
		return STRtree.yComparator;
	},
	createParentBoundablesFromVerticalSlice: function (childBoundables, newLevel) {
		return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.createParentBoundables.call(this, childBoundables, newLevel);
	},
	remove: function () {
		if (arguments.length === 2) {
			let itemEnv = arguments[0], item = arguments[1];
			return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.remove.call(this, itemEnv, item);
		} else return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.remove.apply(this, arguments);
	},
	depth: function () {
		if (arguments.length === 0) {
			return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.depth.call(this);
		} else return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].prototype.depth.apply(this, arguments);
	},
	createParentBoundables: function (childBoundables, newLevel) {
		__WEBPACK_IMPORTED_MODULE_14__util_Assert__["a" /* default */].isTrue(!childBoundables.isEmpty());
		var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
		var sortedChildBoundables = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */](childBoundables);
		__WEBPACK_IMPORTED_MODULE_8__java_util_Collections__["a" /* default */].sort(sortedChildBoundables, STRtree.xComparator);
		var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
		return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
	},
	nearestNeighbour: function () {
		if (arguments.length === 1) {
			if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_18__ItemDistance__["a" /* default */])) {
				let itemDist = arguments[0];
				var bp = new __WEBPACK_IMPORTED_MODULE_9__BoundablePair__["a" /* default */](this.getRoot(), this.getRoot(), itemDist);
				return this.nearestNeighbour(bp);
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_9__BoundablePair__["a" /* default */]) {
				let initBndPair = arguments[0];
				return this.nearestNeighbour(initBndPair, __WEBPACK_IMPORTED_MODULE_6__java_lang_Double__["a" /* default */].POSITIVE_INFINITY);
			}
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof STRtree && Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_18__ItemDistance__["a" /* default */])) {
				let tree = arguments[0], itemDist = arguments[1];
				var bp = new __WEBPACK_IMPORTED_MODULE_9__BoundablePair__["a" /* default */](this.getRoot(), tree.getRoot(), itemDist);
				return this.nearestNeighbour(bp);
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_9__BoundablePair__["a" /* default */] && typeof arguments[1] === "number") {
				let initBndPair = arguments[0], maxDistance = arguments[1];
				var distanceLowerBound = maxDistance;
				var minPair = null;
				var priQ = new __WEBPACK_IMPORTED_MODULE_1__util_PriorityQueue__["a" /* default */]();
				priQ.add(initBndPair);
				while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
					var bndPair = priQ.poll();
					var currentDistance = bndPair.getDistance();
					if (currentDistance >= distanceLowerBound) break;
					if (bndPair.isLeaves()) {
						distanceLowerBound = currentDistance;
						minPair = bndPair;
					} else {
						bndPair.expandToQueue(priQ, distanceLowerBound);
					}
				}
				return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
			}
		} else if (arguments.length === 3) {
			let env = arguments[0], item = arguments[1], itemDist = arguments[2];
			var bnd = new __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */](env, item);
			var bp = new __WEBPACK_IMPORTED_MODULE_9__BoundablePair__["a" /* default */](this.getRoot(), bnd, itemDist);
			return this.nearestNeighbour(bp)[0];
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__SpatialIndex__["a" /* default */], __WEBPACK_IMPORTED_MODULE_12__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return STRtree;
	}
});
STRtree.centreX = function (e) {
	return STRtree.avg(e.getMinX(), e.getMaxX());
};
STRtree.avg = function (a, b) {
	return (a + b) / 2;
};
STRtree.centreY = function (e) {
	return STRtree.avg(e.getMinY(), e.getMaxY());
};
function STRtreeNode() {
	let level = arguments[0];
	__WEBPACK_IMPORTED_MODULE_5__AbstractNode__["a" /* default */].call(this, level);
}
Object(__WEBPACK_IMPORTED_MODULE_15__inherits__["a" /* default */])(STRtreeNode, __WEBPACK_IMPORTED_MODULE_5__AbstractNode__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(STRtreeNode.prototype, {
	computeBounds: function () {
		var bounds = null;
		for (var i = this.getChildBoundables().iterator(); i.hasNext(); ) {
			var childBoundable = i.next();
			if (bounds === null) {
				bounds = new __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__["a" /* default */](childBoundable.getBounds());
			} else {
				bounds.expandToInclude(childBoundable.getBounds());
			}
		}
		return bounds;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return STRtreeNode;
	}
});
STRtree.STRtreeNode = STRtreeNode;
STRtree.serialVersionUID = 259274702368956900;
STRtree.xComparator = {
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_11__java_util_Comparator__["a" /* default */]];
	},
	compare: function (o1, o2) {
		return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));
	}
};
STRtree.yComparator = {
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_11__java_util_Comparator__["a" /* default */]];
	},
	compare: function (o1, o2) {
		return __WEBPACK_IMPORTED_MODULE_17__AbstractSTRtree__["a" /* default */].compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));
	}
};
STRtree.intersectsOp = {
	interfaces_: function () {
		return [IntersectsOp];
	},
	intersects: function (aBounds, bBounds) {
		return aBounds.intersects(bBounds);
	}
};
STRtree.DEFAULT_NODE_CAPACITY = 10;


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Edge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EdgeIntersectionList__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_MonotoneChainEdge__ = __webpack_require__(262);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Depth__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__GraphComponent__ = __webpack_require__(135);











function Edge() {
	__WEBPACK_IMPORTED_MODULE_10__GraphComponent__["a" /* default */].apply(this);
	this.pts = null;
	this._env = null;
	this.eiList = new __WEBPACK_IMPORTED_MODULE_1__EdgeIntersectionList__["a" /* default */](this);
	this._name = null;
	this._mce = null;
	this._isIsolated = true;
	this._depth = new __WEBPACK_IMPORTED_MODULE_9__Depth__["a" /* default */]();
	this._depthDelta = 0;
	if (arguments.length === 1) {
		let pts = arguments[0];
		Edge.call(this, pts, null);
	} else if (arguments.length === 2) {
		let pts = arguments[0], label = arguments[1];
		this.pts = pts;
		this._label = label;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_8__inherits__["a" /* default */])(Edge, __WEBPACK_IMPORTED_MODULE_10__GraphComponent__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(Edge.prototype, {
	getDepth: function () {
		return this._depth;
	},
	getCollapsedEdge: function () {
		var newPts = new Array(2).fill(null);
		newPts[0] = this.pts[0];
		newPts[1] = this.pts[1];
		var newe = new Edge(newPts, __WEBPACK_IMPORTED_MODULE_6__Label__["a" /* default */].toLineLabel(this._label));
		return newe;
	},
	isIsolated: function () {
		return this._isIsolated;
	},
	getCoordinates: function () {
		return this.pts;
	},
	setIsolated: function (isIsolated) {
		this._isIsolated = isIsolated;
	},
	setName: function (name) {
		this._name = name;
	},
	equals: function (o) {
		if (!(o instanceof Edge)) return false;
		var e = o;
		if (this.pts.length !== e.pts.length) return false;
		var isEqualForward = true;
		var isEqualReverse = true;
		var iRev = this.pts.length;
		for (var i = 0; i < this.pts.length; i++) {
			if (!this.pts[i].equals2D(e.pts[i])) {
				isEqualForward = false;
			}
			if (!this.pts[i].equals2D(e.pts[-- iRev])) {
				isEqualReverse = false;
			}
			if (!isEqualForward && !isEqualReverse) return false;
		}
		return true;
	},
	getCoordinate: function () {
		if (arguments.length === 0) {
			if (this.pts.length > 0) return this.pts[0];
			return null;
		} else if (arguments.length === 1) {
			let i = arguments[0];
			return this.pts[i];
		}
	},
	print: function (out) {
		out.print("edge " + this._name + ": ");
		out.print("LINESTRING (");
		for (var i = 0; i < this.pts.length; i++) {
			if (i > 0) out.print(",");
			out.print(this.pts[i].x + " " + this.pts[i].y);
		}
		out.print(")  " + this._label + " " + this._depthDelta);
	},
	computeIM: function (im) {
		Edge.updateIM(this._label, im);
	},
	isCollapsed: function () {
		if (!this._label.isArea()) return false;
		if (this.pts.length !== 3) return false;
		if (this.pts[0].equals(this.pts[2])) return true;
		return false;
	},
	isClosed: function () {
		return this.pts[0].equals(this.pts[this.pts.length - 1]);
	},
	getMaximumSegmentIndex: function () {
		return this.pts.length - 1;
	},
	getDepthDelta: function () {
		return this._depthDelta;
	},
	getNumPoints: function () {
		return this.pts.length;
	},
	printReverse: function (out) {
		out.print("edge " + this._name + ": ");
		for (var i = this.pts.length - 1; i >= 0; i--) {
			out.print(this.pts[i] + " ");
		}
		out.println("");
	},
	getMonotoneChainEdge: function () {
		if (this._mce === null) this._mce = new __WEBPACK_IMPORTED_MODULE_2__index_MonotoneChainEdge__["a" /* default */](this);
		return this._mce;
	},
	getEnvelope: function () {
		if (this._env === null) {
			this._env = new __WEBPACK_IMPORTED_MODULE_7__geom_Envelope__["a" /* default */]();
			for (var i = 0; i < this.pts.length; i++) {
				this._env.expandToInclude(this.pts[i]);
			}
		}
		return this._env;
	},
	addIntersection: function (li, segmentIndex, geomIndex, intIndex) {
		var intPt = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](li.getIntersection(intIndex));
		var normalizedSegmentIndex = segmentIndex;
		var dist = li.getEdgeDistance(geomIndex, intIndex);
		var nextSegIndex = normalizedSegmentIndex + 1;
		if (nextSegIndex < this.pts.length) {
			var nextPt = this.pts[nextSegIndex];
			if (intPt.equals2D(nextPt)) {
				normalizedSegmentIndex = nextSegIndex;
				dist = 0.0;
			}
		}
		var ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);
	},
	toString: function () {
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		buf.append("edge " + this._name + ": ");
		buf.append("LINESTRING (");
		for (var i = 0; i < this.pts.length; i++) {
			if (i > 0) buf.append(",");
			buf.append(this.pts[i].x + " " + this.pts[i].y);
		}
		buf.append(")  " + this._label + " " + this._depthDelta);
		return buf.toString();
	},
	isPointwiseEqual: function (e) {
		if (this.pts.length !== e.pts.length) return false;
		for (var i = 0; i < this.pts.length; i++) {
			if (!this.pts[i].equals2D(e.pts[i])) {
				return false;
			}
		}
		return true;
	},
	setDepthDelta: function (depthDelta) {
		this._depthDelta = depthDelta;
	},
	getEdgeIntersectionList: function () {
		return this.eiList;
	},
	addIntersections: function (li, segmentIndex, geomIndex) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			this.addIntersection(li, segmentIndex, geomIndex, i);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Edge;
	}
});
Edge.updateIM = function () {
	if (arguments.length === 2) {
		let label = arguments[0], im = arguments[1];
		im.setAtLeastIfValid(label.getLocation(0, __WEBPACK_IMPORTED_MODULE_3__Position__["a" /* default */].ON), label.getLocation(1, __WEBPACK_IMPORTED_MODULE_3__Position__["a" /* default */].ON), 1);
		if (label.isArea()) {
			im.setAtLeastIfValid(label.getLocation(0, __WEBPACK_IMPORTED_MODULE_3__Position__["a" /* default */].LEFT), label.getLocation(1, __WEBPACK_IMPORTED_MODULE_3__Position__["a" /* default */].LEFT), 2);
			im.setAtLeastIfValid(label.getLocation(0, __WEBPACK_IMPORTED_MODULE_3__Position__["a" /* default */].RIGHT), label.getLocation(1, __WEBPACK_IMPORTED_MODULE_3__Position__["a" /* default */].RIGHT), 2);
		}
	} else return __WEBPACK_IMPORTED_MODULE_10__GraphComponent__["a" /* default */].prototype.updateIM.apply(this, arguments);
};


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Interval;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Interval() {
	this.min = null;
	this.max = null;
	if (arguments.length === 0) {
		this.min = 0.0;
		this.max = 0.0;
	} else if (arguments.length === 1) {
		let interval = arguments[0];
		this.init(interval.min, interval.max);
	} else if (arguments.length === 2) {
		let min = arguments[0], max = arguments[1];
		this.init(min, max);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Interval.prototype, {
	expandToInclude: function (interval) {
		if (interval.max > this.max) this.max = interval.max;
		if (interval.min < this.min) this.min = interval.min;
	},
	getWidth: function () {
		return this.max - this.min;
	},
	overlaps: function () {
		if (arguments.length === 1) {
			let interval = arguments[0];
			return this.overlaps(interval.min, interval.max);
		} else if (arguments.length === 2) {
			let min = arguments[0], max = arguments[1];
			if (this.min > max || this.max < min) return false;
			return true;
		}
	},
	getMin: function () {
		return this.min;
	},
	toString: function () {
		return "[" + this.min + ", " + this.max + "]";
	},
	contains: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Interval) {
				let interval = arguments[0];
				return this.contains(interval.min, interval.max);
			} else if (typeof arguments[0] === "number") {
				let p = arguments[0];
				return p >= this.min && p <= this.max;
			}
		} else if (arguments.length === 2) {
			let min = arguments[0], max = arguments[1];
			return min >= this.min && max <= this.max;
		}
	},
	init: function (min, max) {
		this.min = min;
		this.max = max;
		if (min > max) {
			this.min = max;
			this.max = min;
		}
	},
	getMax: function () {
		return this.max;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Interval;
	}
});


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Triangle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__algorithm_Angle__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__algorithm_HCoordinate__ = __webpack_require__(56);





function Triangle() {
	this.p0 = null;
	this.p1 = null;
	this.p2 = null;
	let p0 = arguments[0], p1 = arguments[1], p2 = arguments[2];
	this.p0 = p0;
	this.p1 = p1;
	this.p2 = p2;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Triangle.prototype, {
	area: function () {
		return Triangle.area(this.p0, this.p1, this.p2);
	},
	signedArea: function () {
		return Triangle.signedArea(this.p0, this.p1, this.p2);
	},
	interpolateZ: function (p) {
		if (p === null) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Supplied point is null.");
		return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);
	},
	longestSideLength: function () {
		return Triangle.longestSideLength(this.p0, this.p1, this.p2);
	},
	isAcute: function () {
		return Triangle.isAcute(this.p0, this.p1, this.p2);
	},
	circumcentre: function () {
		return Triangle.circumcentre(this.p0, this.p1, this.p2);
	},
	area3D: function () {
		return Triangle.area3D(this.p0, this.p1, this.p2);
	},
	centroid: function () {
		return Triangle.centroid(this.p0, this.p1, this.p2);
	},
	inCentre: function () {
		return Triangle.inCentre(this.p0, this.p1, this.p2);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Triangle;
	}
});
Triangle.area = function (a, b, c) {
	return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
};
Triangle.signedArea = function (a, b, c) {
	return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
};
Triangle.det = function (m00, m01, m10, m11) {
	return m00 * m11 - m01 * m10;
};
Triangle.interpolateZ = function (p, v0, v1, v2) {
	var x0 = v0.x;
	var y0 = v0.y;
	var a = v1.x - x0;
	var b = v2.x - x0;
	var c = v1.y - y0;
	var d = v2.y - y0;
	var det = a * d - b * c;
	var dx = p.x - x0;
	var dy = p.y - y0;
	var t = (d * dx - b * dy) / det;
	var u = (-c * dx + a * dy) / det;
	var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
	return z;
};
Triangle.longestSideLength = function (a, b, c) {
	var lenAB = a.distance(b);
	var lenBC = b.distance(c);
	var lenCA = c.distance(a);
	var maxLen = lenAB;
	if (lenBC > maxLen) maxLen = lenBC;
	if (lenCA > maxLen) maxLen = lenCA;
	return maxLen;
};
Triangle.isAcute = function (a, b, c) {
	if (!__WEBPACK_IMPORTED_MODULE_3__algorithm_Angle__["a" /* default */].isAcute(a, b, c)) return false;
	if (!__WEBPACK_IMPORTED_MODULE_3__algorithm_Angle__["a" /* default */].isAcute(b, c, a)) return false;
	if (!__WEBPACK_IMPORTED_MODULE_3__algorithm_Angle__["a" /* default */].isAcute(c, a, b)) return false;
	return true;
};
Triangle.circumcentre = function (a, b, c) {
	var cx = c.x;
	var cy = c.y;
	var ax = a.x - cx;
	var ay = a.y - cy;
	var bx = b.x - cx;
	var by = b.y - cy;
	var denom = 2 * Triangle.det(ax, ay, bx, by);
	var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
	var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
	var ccx = cx - numx / denom;
	var ccy = cy + numy / denom;
	return new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */](ccx, ccy);
};
Triangle.perpendicularBisector = function (a, b) {
	var dx = b.x - a.x;
	var dy = b.y - a.y;
	var l1 = new __WEBPACK_IMPORTED_MODULE_4__algorithm_HCoordinate__["a" /* default */](a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
	var l2 = new __WEBPACK_IMPORTED_MODULE_4__algorithm_HCoordinate__["a" /* default */](a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
	return new __WEBPACK_IMPORTED_MODULE_4__algorithm_HCoordinate__["a" /* default */](l1, l2);
};
Triangle.angleBisector = function (a, b, c) {
	var len0 = b.distance(a);
	var len2 = b.distance(c);
	var frac = len0 / (len0 + len2);
	var dx = c.x - a.x;
	var dy = c.y - a.y;
	var splitPt = new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */](a.x + frac * dx, a.y + frac * dy);
	return splitPt;
};
Triangle.area3D = function (a, b, c) {
	var ux = b.x - a.x;
	var uy = b.y - a.y;
	var uz = b.z - a.z;
	var vx = c.x - a.x;
	var vy = c.y - a.y;
	var vz = c.z - a.z;
	var crossx = uy * vz - uz * vy;
	var crossy = uz * vx - ux * vz;
	var crossz = ux * vy - uy * vx;
	var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
	var area3D = Math.sqrt(absSq) / 2;
	return area3D;
};
Triangle.centroid = function (a, b, c) {
	var x = (a.x + b.x + c.x) / 3;
	var y = (a.y + b.y + c.y) / 3;
	return new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */](x, y);
};
Triangle.inCentre = function (a, b, c) {
	var len0 = b.distance(c);
	var len1 = a.distance(c);
	var len2 = a.distance(b);
	var circum = len0 + len1 + len2;
	var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
	var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
	return new __WEBPACK_IMPORTED_MODULE_0__Coordinate__["a" /* default */](inCentreX, inCentreY);
};


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferParameters;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function BufferParameters() {
	this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
	this._endCapStyle = BufferParameters.CAP_ROUND;
	this._joinStyle = BufferParameters.JOIN_ROUND;
	this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
	this._isSingleSided = false;
	this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let quadrantSegments = arguments[0];
		this.setQuadrantSegments(quadrantSegments);
	} else if (arguments.length === 2) {
		let quadrantSegments = arguments[0], endCapStyle = arguments[1];
		this.setQuadrantSegments(quadrantSegments);
		this.setEndCapStyle(endCapStyle);
	} else if (arguments.length === 4) {
		let quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3];
		this.setQuadrantSegments(quadrantSegments);
		this.setEndCapStyle(endCapStyle);
		this.setJoinStyle(joinStyle);
		this.setMitreLimit(mitreLimit);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(BufferParameters.prototype, {
	getEndCapStyle: function () {
		return this._endCapStyle;
	},
	isSingleSided: function () {
		return this._isSingleSided;
	},
	setQuadrantSegments: function (quadSegs) {
		this._quadrantSegments = quadSegs;
		if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
		if (this._quadrantSegments < 0) {
			this._joinStyle = BufferParameters.JOIN_MITRE;
			this._mitreLimit = Math.abs(this._quadrantSegments);
		}
		if (quadSegs <= 0) {
			this._quadrantSegments = 1;
		}
		if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
			this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
		}
	},
	getJoinStyle: function () {
		return this._joinStyle;
	},
	setJoinStyle: function (joinStyle) {
		this._joinStyle = joinStyle;
	},
	setSimplifyFactor: function (simplifyFactor) {
		this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
	},
	getSimplifyFactor: function () {
		return this._simplifyFactor;
	},
	getQuadrantSegments: function () {
		return this._quadrantSegments;
	},
	setEndCapStyle: function (endCapStyle) {
		this._endCapStyle = endCapStyle;
	},
	getMitreLimit: function () {
		return this._mitreLimit;
	},
	setMitreLimit: function (mitreLimit) {
		this._mitreLimit = mitreLimit;
	},
	setSingleSided: function (isSingleSided) {
		this._isSingleSided = isSingleSided;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return BufferParameters;
	}
});
BufferParameters.bufferDistanceError = function (quadSegs) {
	var alpha = Math.PI / 2.0 / quadSegs;
	return 1 - Math.cos(alpha / 2.0);
};
BufferParameters.CAP_ROUND = 1;
BufferParameters.CAP_FLAT = 2;
BufferParameters.CAP_SQUARE = 3;
BufferParameters.JOIN_ROUND = 1;
BufferParameters.JOIN_MITRE = 2;
BufferParameters.JOIN_BEVEL = 3;
BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;
BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;
BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GraphComponent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function GraphComponent() {
	this._isMarked = false;
	this._isVisited = false;
	this._data = null;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GraphComponent.prototype, {
	setVisited: function (isVisited) {
		this._isVisited = isVisited;
	},
	isMarked: function () {
		return this._isMarked;
	},
	setData: function (data) {
		this._data = data;
	},
	getData: function () {
		return this._data;
	},
	setMarked: function (isMarked) {
		this._isMarked = isMarked;
	},
	getContext: function () {
		return this._data;
	},
	isVisited: function () {
		return this._isVisited;
	},
	setContext: function (data) {
		this._data = data;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GraphComponent;
	}
});
GraphComponent.getComponentWithVisitedState = function (i, visitedState) {
	while (i.hasNext()) {
		var comp = i.next();
		if (comp.isVisited() === visitedState) return comp;
	}
	return null;
};
GraphComponent.setVisited = function (i, visited) {
	while (i.hasNext()) {
		var comp = i.next();
		comp.setVisited(visited);
	}
};
GraphComponent.setMarked = function (i, marked) {
	while (i.hasNext()) {
		var comp = i.next();
		comp.setMarked(marked);
	}
};


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__DirectedEdgeStar__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_HashSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__DirectedEdge__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__GraphComponent__ = __webpack_require__(81);






function Node() {
	__WEBPACK_IMPORTED_MODULE_5__GraphComponent__["a" /* default */].apply(this);
	this._pt = null;
	this._deStar = null;
	if (arguments.length === 1) {
		let pt = arguments[0];
		Node.call(this, pt, new __WEBPACK_IMPORTED_MODULE_0__DirectedEdgeStar__["a" /* default */]());
	} else if (arguments.length === 2) {
		let pt = arguments[0], deStar = arguments[1];
		this._pt = pt;
		this._deStar = deStar;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_4__inherits__["a" /* default */])(Node, __WEBPACK_IMPORTED_MODULE_5__GraphComponent__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Node.prototype, {
	isRemoved: function () {
		return this._pt === null;
	},
	addOutEdge: function (de) {
		this._deStar.add(de);
	},
	getCoordinate: function () {
		return this._pt;
	},
	getOutEdges: function () {
		return this._deStar;
	},
	remove: function () {
		if (arguments.length === 0) {
			this._pt = null;
		} else if (arguments.length === 1) {
			let de = arguments[0];
			this._deStar.remove(de);
		}
	},
	getIndex: function (edge) {
		return this._deStar.getIndex(edge);
	},
	getDegree: function () {
		return this._deStar.getDegree();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Node;
	}
});
Node.getEdgesBetween = function (node0, node1) {
	var edges0 = __WEBPACK_IMPORTED_MODULE_3__DirectedEdge__["a" /* default */].toEdges(node0.getOutEdges().getEdges());
	var commonEdges = new __WEBPACK_IMPORTED_MODULE_1__java_util_HashSet__["a" /* default */](edges0);
	var edges1 = __WEBPACK_IMPORTED_MODULE_3__DirectedEdge__["a" /* default */].toEdges(node1.getOutEdges().getEdges());
	commonEdges.retainAll(edges1);
	return commonEdges;
};


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Edge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Node__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__GraphComponent__ = __webpack_require__(81);




function Edge() {
	__WEBPACK_IMPORTED_MODULE_3__GraphComponent__["a" /* default */].apply(this);
	this._dirEdge = null;
	if (arguments.length === 0) {} else if (arguments.length === 2) {
		let de0 = arguments[0], de1 = arguments[1];
		this.setDirectedEdges(de0, de1);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(Edge, __WEBPACK_IMPORTED_MODULE_3__GraphComponent__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Edge.prototype, {
	isRemoved: function () {
		return this._dirEdge === null;
	},
	setDirectedEdges: function (de0, de1) {
		this._dirEdge = [de0, de1];
		de0.setEdge(this);
		de1.setEdge(this);
		de0.setSym(de1);
		de1.setSym(de0);
		de0.getFromNode().addOutEdge(de0);
		de1.getFromNode().addOutEdge(de1);
	},
	getDirEdge: function () {
		if (Number.isInteger(arguments[0])) {
			let i = arguments[0];
			return this._dirEdge[i];
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__Node__["a" /* default */]) {
			let fromNode = arguments[0];
			if (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];
			if (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];
			return null;
		}
	},
	remove: function () {
		this._dirEdge = null;
	},
	getOppositeNode: function (node) {
		if (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();
		if (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();
		return null;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Edge;
	}
});


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Vertex;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_NotRepresentableException__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__TrianglePredicate__ = __webpack_require__(369);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__algorithm_HCoordinate__ = __webpack_require__(56);






function Vertex() {
	this._p = null;
	if (arguments.length === 1) {
		let _p = arguments[0];
		this._p = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](_p);
	} else if (arguments.length === 2) {
		let _x = arguments[0], _y = arguments[1];
		this._p = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](_x, _y);
	} else if (arguments.length === 3) {
		let _x = arguments[0], _y = arguments[1], _z = arguments[2];
		this._p = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](_x, _y, _z);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Vertex.prototype, {
	circleCenter: function (b, c) {
		var a = new Vertex(this.getX(), this.getY());
		var cab = this.bisector(a, b);
		var cbc = this.bisector(b, c);
		var hcc = new __WEBPACK_IMPORTED_MODULE_5__algorithm_HCoordinate__["a" /* default */](cab, cbc);
		var cc = null;
		try {
			cc = new Vertex(hcc.getX(), hcc.getY());
		} catch (nre) {
			if (nre instanceof __WEBPACK_IMPORTED_MODULE_0__algorithm_NotRepresentableException__["a" /* default */]) {
				__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].err.println("a: " + a + "  b: " + b + "  c: " + c);
				__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].err.println(nre);
			} else throw nre;
		} finally {}
		return cc;
	},
	dot: function (v) {
		return this._p.x * v.getX() + this._p.y * v.getY();
	},
	magn: function () {
		return Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);
	},
	getZ: function () {
		return this._p.z;
	},
	bisector: function (a, b) {
		var dx = b.getX() - a.getX();
		var dy = b.getY() - a.getY();
		var l1 = new __WEBPACK_IMPORTED_MODULE_5__algorithm_HCoordinate__["a" /* default */](a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);
		var l2 = new __WEBPACK_IMPORTED_MODULE_5__algorithm_HCoordinate__["a" /* default */](a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);
		return new __WEBPACK_IMPORTED_MODULE_5__algorithm_HCoordinate__["a" /* default */](l1, l2);
	},
	equals: function () {
		if (arguments.length === 1) {
			let _x = arguments[0];
			if (this._p.x === _x.getX() && this._p.y === _x.getY()) {
				return true;
			} else {
				return false;
			}
		} else if (arguments.length === 2) {
			let _x = arguments[0], tolerance = arguments[1];
			if (this._p.distance(_x.getCoordinate()) < tolerance) {
				return true;
			} else {
				return false;
			}
		}
	},
	getCoordinate: function () {
		return this._p;
	},
	isInCircle: function (a, b, c) {
		return __WEBPACK_IMPORTED_MODULE_2__TrianglePredicate__["a" /* default */].isInCircleRobust(a._p, b._p, c._p, this._p);
	},
	interpolateZValue: function (v0, v1, v2) {
		var x0 = v0.getX();
		var y0 = v0.getY();
		var a = v1.getX() - x0;
		var b = v2.getX() - x0;
		var c = v1.getY() - y0;
		var d = v2.getY() - y0;
		var det = a * d - b * c;
		var dx = this.getX() - x0;
		var dy = this.getY() - y0;
		var t = (d * dx - b * dy) / det;
		var u = (-c * dx + a * dy) / det;
		var z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());
		return z;
	},
	midPoint: function (a) {
		var xm = (this._p.x + a.getX()) / 2.0;
		var ym = (this._p.y + a.getY()) / 2.0;
		var zm = (this._p.z + a.getZ()) / 2.0;
		return new Vertex(xm, ym, zm);
	},
	rightOf: function (e) {
		return this.isCCW(e.dest(), e.orig());
	},
	isCCW: function (b, c) {
		return (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;
	},
	getX: function () {
		return this._p.x;
	},
	crossProduct: function (v) {
		return this._p.x * v.getY() - this._p.y * v.getX();
	},
	setZ: function (_z) {
		this._p.z = _z;
	},
	times: function (c) {
		return new Vertex(c * this._p.x, c * this._p.y);
	},
	cross: function () {
		return new Vertex(this._p.y, -this._p.x);
	},
	leftOf: function (e) {
		return this.isCCW(e.orig(), e.dest());
	},
	toString: function () {
		return "POINT (" + this._p.x + " " + this._p.y + ")";
	},
	sub: function (v) {
		return new Vertex(this._p.x - v.getX(), this._p.y - v.getY());
	},
	getY: function () {
		return this._p.y;
	},
	classify: function (p0, p1) {
		var p2 = this;
		var a = p1.sub(p0);
		var b = p2.sub(p0);
		var sa = a.crossProduct(b);
		if (sa > 0.0) return Vertex.LEFT;
		if (sa < 0.0) return Vertex.RIGHT;
		if (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;
		if (a.magn() < b.magn()) return Vertex.BEYOND;
		if (p0.equals(p2)) return Vertex.ORIGIN;
		if (p1.equals(p2)) return Vertex.DESTINATION;
		return Vertex.BETWEEN;
	},
	sum: function (v) {
		return new Vertex(this._p.x + v.getX(), this._p.y + v.getY());
	},
	distance: function (v1, v2) {
		return Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));
	},
	circumRadiusRatio: function (b, c) {
		var x = this.circleCenter(b, c);
		var radius = this.distance(x, b);
		var edgeLength = this.distance(this, b);
		var el = this.distance(b, c);
		if (el < edgeLength) {
			edgeLength = el;
		}
		el = this.distance(c, this);
		if (el < edgeLength) {
			edgeLength = el;
		}
		return radius / edgeLength;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Vertex;
	}
});
Vertex.interpolateZ = function () {
	if (arguments.length === 3) {
		let p = arguments[0], p0 = arguments[1], p1 = arguments[2];
		var segLen = p0.distance(p1);
		var ptLen = p.distance(p0);
		var dz = p1.z - p0.z;
		var pz = p0.z + dz * (ptLen / segLen);
		return pz;
	} else if (arguments.length === 4) {
		let p = arguments[0], v0 = arguments[1], v1 = arguments[2], v2 = arguments[3];
		var x0 = v0.x;
		var y0 = v0.y;
		var a = v1.x - x0;
		var b = v2.x - x0;
		var c = v1.y - y0;
		var d = v2.y - y0;
		var det = a * d - b * c;
		var dx = p.x - x0;
		var dy = p.y - y0;
		var t = (d * dx - b * dy) / det;
		var u = (-c * dx + a * dy) / det;
		var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
		return z;
	}
};
Vertex.LEFT = 0;
Vertex.RIGHT = 1;
Vertex.BEYOND = 2;
Vertex.BEHIND = 3;
Vertex.BETWEEN = 4;
Vertex.ORIGIN = 5;
Vertex.DESTINATION = 6;


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LinearLocation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__ = __webpack_require__(20);




function LinearLocation() {
	this._componentIndex = 0;
	this._segmentIndex = 0;
	this._segmentFraction = 0.0;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let loc = arguments[0];
		this._componentIndex = loc._componentIndex;
		this._segmentIndex = loc._segmentIndex;
		this._segmentFraction = loc._segmentFraction;
	} else if (arguments.length === 2) {
		let segmentIndex = arguments[0], segmentFraction = arguments[1];
		LinearLocation.call(this, 0, segmentIndex, segmentFraction);
	} else if (arguments.length === 3) {
		let componentIndex = arguments[0], segmentIndex = arguments[1], segmentFraction = arguments[2];
		this._componentIndex = componentIndex;
		this._segmentIndex = segmentIndex;
		this._segmentFraction = segmentFraction;
		this.normalize();
	} else if (arguments.length === 4) {
		let componentIndex = arguments[0], segmentIndex = arguments[1], segmentFraction = arguments[2], doNormalize = arguments[3];
		this._componentIndex = componentIndex;
		this._segmentIndex = segmentIndex;
		this._segmentFraction = segmentFraction;
		if (doNormalize) this.normalize();
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(LinearLocation.prototype, {
	getSegmentIndex: function () {
		return this._segmentIndex;
	},
	getComponentIndex: function () {
		return this._componentIndex;
	},
	isEndpoint: function (linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var nseg = lineComp.getNumPoints() - 1;
		return this._segmentIndex >= nseg || this._segmentIndex === nseg && this._segmentFraction >= 1.0;
	},
	isValid: function (linearGeom) {
		if (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		if (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;
		if (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;
		if (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;
		return true;
	},
	normalize: function () {
		if (this._segmentFraction < 0.0) {
			this._segmentFraction = 0.0;
		}
		if (this._segmentFraction > 1.0) {
			this._segmentFraction = 1.0;
		}
		if (this._componentIndex < 0) {
			this._componentIndex = 0;
			this._segmentIndex = 0;
			this._segmentFraction = 0.0;
		}
		if (this._segmentIndex < 0) {
			this._segmentIndex = 0;
			this._segmentFraction = 0.0;
		}
		if (this._segmentFraction === 1.0) {
			this._segmentFraction = 0.0;
			this._segmentIndex += 1;
		}
	},
	toLowest: function (linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var nseg = lineComp.getNumPoints() - 1;
		if (this._segmentIndex < nseg) return this;
		return new LinearLocation(this._componentIndex, nseg, 1.0, false);
	},
	getCoordinate: function (linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var p0 = lineComp.getCoordinateN(this._segmentIndex);
		if (this._segmentIndex >= lineComp.getNumPoints() - 1) return p0;
		var p1 = lineComp.getCoordinateN(this._segmentIndex + 1);
		return LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);
	},
	getSegmentFraction: function () {
		return this._segmentFraction;
	},
	getSegment: function (linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var p0 = lineComp.getCoordinateN(this._segmentIndex);
		if (this._segmentIndex >= lineComp.getNumPoints() - 1) {
			var prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);
			return new __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__["a" /* default */](prev, p0);
		}
		var p1 = lineComp.getCoordinateN(this._segmentIndex + 1);
		return new __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__["a" /* default */](p0, p1);
	},
	clamp: function (linear) {
		if (this._componentIndex >= linear.getNumGeometries()) {
			this.setToEnd(linear);
			return null;
		}
		if (this._segmentIndex >= linear.getNumPoints()) {
			var line = linear.getGeometryN(this._componentIndex);
			this._segmentIndex = line.getNumPoints() - 1;
			this._segmentFraction = 1.0;
		}
	},
	setToEnd: function (linear) {
		this._componentIndex = linear.getNumGeometries() - 1;
		var lastLine = linear.getGeometryN(this._componentIndex);
		this._segmentIndex = lastLine.getNumPoints() - 1;
		this._segmentFraction = 1.0;
	},
	compareTo: function (o) {
		var other = o;
		if (this._componentIndex < other._componentIndex) return -1;
		if (this._componentIndex > other._componentIndex) return 1;
		if (this._segmentIndex < other._segmentIndex) return -1;
		if (this._segmentIndex > other._segmentIndex) return 1;
		if (this._segmentFraction < other._segmentFraction) return -1;
		if (this._segmentFraction > other._segmentFraction) return 1;
		return 0;
	},
	clone: function () {
		return new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);
	},
	toString: function () {
		return "LinearLoc[" + this._componentIndex + ", " + this._segmentIndex + ", " + this._segmentFraction + "]";
	},
	isOnSameSegment: function (loc) {
		if (this._componentIndex !== loc._componentIndex) return false;
		if (this._segmentIndex === loc._segmentIndex) return true;
		if (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;
		if (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;
		return false;
	},
	snapToVertex: function (linearGeom, minDistance) {
		if (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;
		var segLen = this.getSegmentLength(linearGeom);
		var lenToStart = this._segmentFraction * segLen;
		var lenToEnd = segLen - lenToStart;
		if (lenToStart <= lenToEnd && lenToStart < minDistance) {
			this._segmentFraction = 0.0;
		} else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {
			this._segmentFraction = 1.0;
		}
	},
	compareLocationValues: function (componentIndex1, segmentIndex1, segmentFraction1) {
		if (this._componentIndex < componentIndex1) return -1;
		if (this._componentIndex > componentIndex1) return 1;
		if (this._segmentIndex < segmentIndex1) return -1;
		if (this._segmentIndex > segmentIndex1) return 1;
		if (this._segmentFraction < segmentFraction1) return -1;
		if (this._segmentFraction > segmentFraction1) return 1;
		return 0;
	},
	getSegmentLength: function (linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var segIndex = this._segmentIndex;
		if (this._segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;
		var p0 = lineComp.getCoordinateN(segIndex);
		var p1 = lineComp.getCoordinateN(segIndex + 1);
		return p0.distance(p1);
	},
	isVertex: function () {
		return this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return LinearLocation;
	}
});
LinearLocation.getEndLocation = function (linear) {
	var loc = new LinearLocation();
	loc.setToEnd(linear);
	return loc;
};
LinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {
	if (frac <= 0.0) return p0;
	if (frac >= 1.0) return p1;
	var x = (p1.x - p0.x) * frac + p0.x;
	var y = (p1.y - p0.y) * frac + p0.y;
	var z = (p1.z - p0.z) * frac + p0.z;
	return new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](x, y, z);
};
LinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {
	if (componentIndex0 < componentIndex1) return -1;
	if (componentIndex0 > componentIndex1) return 1;
	if (segmentIndex0 < segmentIndex1) return -1;
	if (segmentIndex0 > segmentIndex1) return 1;
	if (segmentFraction0 < segmentFraction1) return -1;
	if (segmentFraction0 > segmentFraction1) return 1;
	return 0;
};


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OperationNotSupported;
/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function OperationNotSupported(message) {
  this.message = message || '';
};
OperationNotSupported.prototype = new Error();


/**
 * @type {string}
 */
OperationNotSupported.prototype.name = 'OperationNotSupported';


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Exception;
function Exception () {}


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MathUtil;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function MathUtil() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(MathUtil.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MathUtil;
	}
});
MathUtil.log10 = function (x) {
	var ln = Math.log(x);
	if (__WEBPACK_IMPORTED_MODULE_0__java_lang_Double__["a" /* default */].isInfinite(ln)) return ln;
	if (__WEBPACK_IMPORTED_MODULE_0__java_lang_Double__["a" /* default */].isNaN(ln)) return ln;
	return ln / MathUtil.LOG_10;
};
MathUtil.min = function (v1, v2, v3, v4) {
	var min = v1;
	if (v2 < min) min = v2;
	if (v3 < min) min = v3;
	if (v4 < min) min = v4;
	return min;
};
MathUtil.clamp = function () {
	if (typeof arguments[2] === "number" && (typeof arguments[0] === "number" && typeof arguments[1] === "number")) {
		let x = arguments[0], min = arguments[1], max = arguments[2];
		if (x < min) return min;
		if (x > max) return max;
		return x;
	} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
		let x = arguments[0], min = arguments[1], max = arguments[2];
		if (x < min) return min;
		if (x > max) return max;
		return x;
	}
};
MathUtil.wrap = function (index, max) {
	if (index < 0) {
		return max - -index % max;
	}
	return index % max;
};
MathUtil.max = function () {
	if (arguments.length === 3) {
		let v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];
		var max = v1;
		if (v2 > max) max = v2;
		if (v3 > max) max = v3;
		return max;
	} else if (arguments.length === 4) {
		let v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];
		var max = v1;
		if (v2 > max) max = v2;
		if (v3 > max) max = v3;
		if (v4 > max) max = v4;
		return max;
	}
};
MathUtil.average = function (x1, x2) {
	return (x1 + x2) / 2.0;
};
MathUtil.LOG_10 = Math.log(10);


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BoundaryOp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_BoundaryNodeRule__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_TreeMap__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_MultiLineString__ = __webpack_require__(28);







function BoundaryOp() {
	this._geom = null;
	this._geomFact = null;
	this._bnRule = null;
	this._endpointMap = null;
	if (arguments.length === 1) {
		let geom = arguments[0];
		BoundaryOp.call(this, geom, __WEBPACK_IMPORTED_MODULE_1__algorithm_BoundaryNodeRule__["a" /* default */].MOD2_BOUNDARY_RULE);
	} else if (arguments.length === 2) {
		let geom = arguments[0], bnRule = arguments[1];
		this._geom = geom;
		this._geomFact = geom.getFactory();
		this._bnRule = bnRule;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(BoundaryOp.prototype, {
	boundaryMultiLineString: function (mLine) {
		if (this._geom.isEmpty()) {
			return this.getEmptyMultiPoint();
		}
		var bdyPts = this.computeBoundaryCoordinates(mLine);
		if (bdyPts.length === 1) {
			return this._geomFact.createPoint(bdyPts[0]);
		}
		return this._geomFact.createMultiPointFromCoords(bdyPts);
	},
	getBoundary: function () {
		if (this._geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) return this.boundaryLineString(this._geom);
		if (this._geom instanceof __WEBPACK_IMPORTED_MODULE_6__geom_MultiLineString__["a" /* default */]) return this.boundaryMultiLineString(this._geom);
		return this._geom.getBoundary();
	},
	boundaryLineString: function (line) {
		if (this._geom.isEmpty()) {
			return this.getEmptyMultiPoint();
		}
		if (line.isClosed()) {
			var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
			if (closedEndpointOnBoundary) {
				return line.getStartPoint();
			} else {
				return this._geomFact.createMultiPoint();
			}
		}
		return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);
	},
	getEmptyMultiPoint: function () {
		return this._geomFact.createMultiPoint();
	},
	computeBoundaryCoordinates: function (mLine) {
		var bdyPts = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
		this._endpointMap = new __WEBPACK_IMPORTED_MODULE_5__java_util_TreeMap__["a" /* default */]();
		for (var i = 0; i < mLine.getNumGeometries(); i++) {
			var line = mLine.getGeometryN(i);
			if (line.getNumPoints() === 0) continue;
			this.addEndpoint(line.getCoordinateN(0));
			this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
		}
		for (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {
			var entry = it.next();
			var counter = entry.getValue();
			var valence = counter.count;
			if (this._bnRule.isInBoundary(valence)) {
				bdyPts.add(entry.getKey());
			}
		}
		return __WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__["a" /* default */].toCoordinateArray(bdyPts);
	},
	addEndpoint: function (pt) {
		var counter = this._endpointMap.get(pt);
		if (counter === null) {
			counter = new Counter();
			this._endpointMap.put(pt, counter);
		}
		counter.count++;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return BoundaryOp;
	}
});
BoundaryOp.getBoundary = function () {
	if (arguments.length === 1) {
		let g = arguments[0];
		var bop = new BoundaryOp(g);
		return bop.getBoundary();
	} else if (arguments.length === 2) {
		let g = arguments[0], bnRule = arguments[1];
		var bop = new BoundaryOp(g, bnRule);
		return bop.getBoundary();
	}
};
function Counter() {
	this.count = null;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Counter.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Counter;
	}
});


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Lineal;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Lineal() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Lineal.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Lineal;
	}
});


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateSequences;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_StringUtil__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__ = __webpack_require__(37);





function CoordinateSequences() {}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(CoordinateSequences.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CoordinateSequences;
	}
});
CoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {
	var minDim = Math.min(src.getDimension(), dest.getDimension());
	for (var dim = 0; dim < minDim; dim++) {
		dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
	}
};
CoordinateSequences.isRing = function (seq) {
	var n = seq.size();
	if (n === 0) return true;
	if (n <= 3) return false;
	return seq.getOrdinate(0, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].X) === seq.getOrdinate(n - 1, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].X) && seq.getOrdinate(0, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].Y) === seq.getOrdinate(n - 1, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].Y);
};
CoordinateSequences.isEqual = function (cs1, cs2) {
	var cs1Size = cs1.size();
	var cs2Size = cs2.size();
	if (cs1Size !== cs2Size) return false;
	var dim = Math.min(cs1.getDimension(), cs2.getDimension());
	for (var i = 0; i < cs1Size; i++) {
		for (var d = 0; d < dim; d++) {
			var v1 = cs1.getOrdinate(i, d);
			var v2 = cs2.getOrdinate(i, d);
			if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;
			if (__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(v1) && __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].isNaN(v2)) continue;
			return false;
		}
	}
	return true;
};
CoordinateSequences.extend = function (fact, seq, size) {
	var newseq = fact.create(size, seq.getDimension());
	var n = seq.size();
	CoordinateSequences.copy(seq, 0, newseq, 0, n);
	if (n > 0) {
		for (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
	}
	return newseq;
};
CoordinateSequences.reverse = function (seq) {
	var last = seq.size() - 1;
	var mid = Math.trunc(last / 2);
	for (var i = 0; i <= mid; i++) {
		CoordinateSequences.swap(seq, i, last - i);
	}
};
CoordinateSequences.swap = function (seq, i, j) {
	if (i === j) return null;
	for (var dim = 0; dim < seq.getDimension(); dim++) {
		var tmp = seq.getOrdinate(i, dim);
		seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
		seq.setOrdinate(j, dim, tmp);
	}
};
CoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {
	for (var i = 0; i < length; i++) {
		CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
	}
};
CoordinateSequences.toString = function () {
	if (arguments.length === 1) {
		let cs = arguments[0];
		var size = cs.size();
		if (size === 0) return "()";
		var dim = cs.getDimension();
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		buf.append('(');
		for (var i = 0; i < size; i++) {
			if (i > 0) buf.append(" ");
			for (var d = 0; d < dim; d++) {
				if (d > 0) buf.append(",");
				buf.append(__WEBPACK_IMPORTED_MODULE_1__util_StringUtil__["a" /* default */].toString(cs.getOrdinate(i, d)));
			}
		}
		buf.append(')');
		return buf.toString();
	}
};
CoordinateSequences.ensureValidRing = function (fact, seq) {
	var n = seq.size();
	if (n === 0) return seq;
	if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);
	var isClosed = seq.getOrdinate(0, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].X) === seq.getOrdinate(n - 1, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].X) && seq.getOrdinate(0, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].Y) === seq.getOrdinate(n - 1, __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */].Y);
	if (isClosed) return seq;
	return CoordinateSequences.createClosedRing(fact, seq, n + 1);
};
CoordinateSequences.createClosedRing = function (fact, seq, size) {
	var newseq = fact.create(size, seq.getDimension());
	var n = seq.size();
	CoordinateSequences.copy(seq, 0, newseq, 0, n);
	for (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);
	return newseq;
};


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryEditor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__MultiLineString__ = __webpack_require__(28);











function GeometryEditor() {
	this._factory = null;
	this._isUserDataCopied = false;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let factory = arguments[0];
		this._factory = factory;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(GeometryEditor.prototype, {
	setCopyUserData: function (isUserDataCopied) {
		this._isUserDataCopied = isUserDataCopied;
	},
	edit: function (geometry, operation) {
		if (geometry === null) return null;
		var result = this.editInternal(geometry, operation);
		if (this._isUserDataCopied) {
			result.setUserData(geometry.getUserData());
		}
		return result;
	},
	editInternal: function (geometry, operation) {
		if (this._factory === null) this._factory = geometry.getFactory();
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_7__GeometryCollection__["a" /* default */]) {
			return this.editGeometryCollection(geometry, operation);
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_2__Polygon__["a" /* default */]) {
			return this.editPolygon(geometry, operation);
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_1__Point__["a" /* default */]) {
			return operation.edit(geometry, this._factory);
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]) {
			return operation.edit(geometry, this._factory);
		}
		__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].shouldNeverReachHere("Unsupported Geometry class: " + geometry.getClass().getName());
		return null;
	},
	editGeometryCollection: function (collection, operation) {
		var collectionForType = operation.edit(collection, this._factory);
		var geometries = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
			var geometry = this.edit(collectionForType.getGeometryN(i), operation);
			if (geometry === null || geometry.isEmpty()) {
				continue;
			}
			geometries.add(geometry);
		}
		if (collectionForType.getClass() === __WEBPACK_IMPORTED_MODULE_3__MultiPoint__["a" /* default */]) {
			return this._factory.createMultiPoint(geometries.toArray([]));
		}
		if (collectionForType.getClass() === __WEBPACK_IMPORTED_MODULE_10__MultiLineString__["a" /* default */]) {
			return this._factory.createMultiLineString(geometries.toArray([]));
		}
		if (collectionForType.getClass() === __WEBPACK_IMPORTED_MODULE_6__MultiPolygon__["a" /* default */]) {
			return this._factory.createMultiPolygon(geometries.toArray([]));
		}
		return this._factory.createGeometryCollection(geometries.toArray([]));
	},
	editPolygon: function (polygon, operation) {
		var newPolygon = operation.edit(polygon, this._factory);
		if (newPolygon === null) newPolygon = this._factory.createPolygon(null);
		if (newPolygon.isEmpty()) {
			return newPolygon;
		}
		var shell = this.edit(newPolygon.getExteriorRing(), operation);
		if (shell === null || shell.isEmpty()) {
			return this._factory.createPolygon();
		}
		var holes = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
			var hole = this.edit(newPolygon.getInteriorRingN(i), operation);
			if (hole === null || hole.isEmpty()) {
				continue;
			}
			holes.add(hole);
		}
		return this._factory.createPolygon(shell, holes.toArray([]));
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryEditor;
	}
});
function GeometryEditorOperation() {}
GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;
function NoOpGeometryOperation() {}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(NoOpGeometryOperation.prototype, {
	edit: function (geometry, factory) {
		return geometry;
	},
	interfaces_: function () {
		return [GeometryEditorOperation];
	},
	getClass: function () {
		return NoOpGeometryOperation;
	}
});
function CoordinateOperation() {}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(CoordinateOperation.prototype, {
	edit: function (geometry, factory) {
		var coords = this.editCoordinates(geometry.getCoordinates(), geometry);
		if (coords === null) return geometry;
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_4__LinearRing__["a" /* default */]) {
			return factory.createLinearRing(coords);
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]) {
			return factory.createLineString(coords);
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_1__Point__["a" /* default */]) {
			if (coords.length > 0) {
				return factory.createPoint(coords[0]);
			} else {
				return factory.createPoint();
			}
		}
		return geometry;
	},
	interfaces_: function () {
		return [GeometryEditorOperation];
	},
	getClass: function () {
		return CoordinateOperation;
	}
});
function CoordinateSequenceOperation() {}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(CoordinateSequenceOperation.prototype, {
	edit: function (geometry, factory) {
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_4__LinearRing__["a" /* default */]) {
			return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_0__LineString__["a" /* default */]) {
			return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));
		}
		if (geometry instanceof __WEBPACK_IMPORTED_MODULE_1__Point__["a" /* default */]) {
			return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));
		}
		return geometry;
	},
	interfaces_: function () {
		return [GeometryEditorOperation];
	},
	getClass: function () {
		return CoordinateSequenceOperation;
	}
});
GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;
GeometryEditor.CoordinateOperation = CoordinateOperation;
GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConvexHull;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_Arrays__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_Stack__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_Comparator__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_UniqueCoordinateArrayFilter__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__util_Assert__ = __webpack_require__(4);











function ConvexHull() {
	this._geomFactory = null;
	this._inputPts = null;
	if (arguments.length === 1) {
		let geometry = arguments[0];
		ConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());
	} else if (arguments.length === 2) {
		let pts = arguments[0], geomFactory = arguments[1];
		this._inputPts = __WEBPACK_IMPORTED_MODULE_9__util_UniqueCoordinateArrayFilter__["a" /* default */].filterCoordinates(pts);
		this._geomFactory = geomFactory;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(ConvexHull.prototype, {
	preSort: function (pts) {
		var t = null;
		for (var i = 1; i < pts.length; i++) {
			if (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {
				t = pts[0];
				pts[0] = pts[i];
				pts[i] = t;
			}
		}
		__WEBPACK_IMPORTED_MODULE_3__java_util_Arrays__["a" /* default */].sort(pts, 1, pts.length, new RadialComparator(pts[0]));
		return pts;
	},
	computeOctRing: function (inputPts) {
		var octPts = this.computeOctPts(inputPts);
		var coordList = new __WEBPACK_IMPORTED_MODULE_2__geom_CoordinateList__["a" /* default */]();
		coordList.add(octPts, false);
		if (coordList.size() < 3) {
			return null;
		}
		coordList.closeRing();
		return coordList.toCoordinateArray();
	},
	lineOrPolygon: function (coordinates) {
		coordinates = this.cleanRing(coordinates);
		if (coordinates.length === 3) {
			return this._geomFactory.createLineString([coordinates[0], coordinates[1]]);
		}
		var linearRing = this._geomFactory.createLinearRing(coordinates);
		return this._geomFactory.createPolygon(linearRing, null);
	},
	cleanRing: function (original) {
		__WEBPACK_IMPORTED_MODULE_10__util_Assert__["a" /* default */].equals(original[0], original[original.length - 1]);
		var cleanedRing = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */]();
		var previousDistinctCoordinate = null;
		for (var i = 0; i <= original.length - 2; i++) {
			var currentCoordinate = original[i];
			var nextCoordinate = original[i + 1];
			if (currentCoordinate.equals(nextCoordinate)) {
				continue;
			}
			if (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {
				continue;
			}
			cleanedRing.add(currentCoordinate);
			previousDistinctCoordinate = currentCoordinate;
		}
		cleanedRing.add(original[original.length - 1]);
		var cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);
		return cleanedRing.toArray(cleanedRingCoordinates);
	},
	isBetween: function (c1, c2, c3) {
		if (__WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].computeOrientation(c1, c2, c3) !== 0) {
			return false;
		}
		if (c1.x !== c3.x) {
			if (c1.x <= c2.x && c2.x <= c3.x) {
				return true;
			}
			if (c3.x <= c2.x && c2.x <= c1.x) {
				return true;
			}
		}
		if (c1.y !== c3.y) {
			if (c1.y <= c2.y && c2.y <= c3.y) {
				return true;
			}
			if (c3.y <= c2.y && c2.y <= c1.y) {
				return true;
			}
		}
		return false;
	},
	reduce: function (inputPts) {
		var polyPts = this.computeOctRing(inputPts);
		if (polyPts === null) return inputPts;
		var reducedSet = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */]();
		for (var i = 0; i < polyPts.length; i++) {
			reducedSet.add(polyPts[i]);
		}
		for (var i = 0; i < inputPts.length; i++) {
			if (!__WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].isPointInRing(inputPts[i], polyPts)) {
				reducedSet.add(inputPts[i]);
			}
		}
		var reducedPts = __WEBPACK_IMPORTED_MODULE_6__geom_CoordinateArrays__["a" /* default */].toCoordinateArray(reducedSet);
		if (reducedPts.length < 3) return this.padArray3(reducedPts);
		return reducedPts;
	},
	getConvexHull: function () {
		if (this._inputPts.length === 0) {
			return this._geomFactory.createGeometryCollection(null);
		}
		if (this._inputPts.length === 1) {
			return this._geomFactory.createPoint(this._inputPts[0]);
		}
		if (this._inputPts.length === 2) {
			return this._geomFactory.createLineString(this._inputPts);
		}
		var reducedPts = this._inputPts;
		if (this._inputPts.length > 50) {
			reducedPts = this.reduce(this._inputPts);
		}
		var sortedPts = this.preSort(reducedPts);
		var cHS = this.grahamScan(sortedPts);
		var cH = this.toCoordinateArray(cHS);
		return this.lineOrPolygon(cH);
	},
	padArray3: function (pts) {
		var pad = new Array(3).fill(null);
		for (var i = 0; i < pad.length; i++) {
			if (i < pts.length) {
				pad[i] = pts[i];
			} else pad[i] = pts[0];
		}
		return pad;
	},
	computeOctPts: function (inputPts) {
		var pts = new Array(8).fill(null);
		for (var j = 0; j < pts.length; j++) {
			pts[j] = inputPts[0];
		}
		for (var i = 1; i < inputPts.length; i++) {
			if (inputPts[i].x < pts[0].x) {
				pts[0] = inputPts[i];
			}
			if (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {
				pts[1] = inputPts[i];
			}
			if (inputPts[i].y > pts[2].y) {
				pts[2] = inputPts[i];
			}
			if (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {
				pts[3] = inputPts[i];
			}
			if (inputPts[i].x > pts[4].x) {
				pts[4] = inputPts[i];
			}
			if (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {
				pts[5] = inputPts[i];
			}
			if (inputPts[i].y < pts[6].y) {
				pts[6] = inputPts[i];
			}
			if (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {
				pts[7] = inputPts[i];
			}
		}
		return pts;
	},
	toCoordinateArray: function (stack) {
		var coordinates = new Array(stack.size()).fill(null);
		for (var i = 0; i < stack.size(); i++) {
			var coordinate = stack.get(i);
			coordinates[i] = coordinate;
		}
		return coordinates;
	},
	grahamScan: function (c) {
		var p = null;
		var ps = new __WEBPACK_IMPORTED_MODULE_4__java_util_Stack__["a" /* default */]();
		p = ps.push(c[0]);
		p = ps.push(c[1]);
		p = ps.push(c[2]);
		for (var i = 3; i < c.length; i++) {
			p = ps.pop();
			while (!ps.empty() && __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].computeOrientation(ps.peek(), p, c[i]) > 0) {
				p = ps.pop();
			}
			p = ps.push(p);
			p = ps.push(c[i]);
		}
		p = ps.push(c[0]);
		return ps;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConvexHull;
	}
});
ConvexHull.extractCoordinates = function (geom) {
	var filter = new __WEBPACK_IMPORTED_MODULE_9__util_UniqueCoordinateArrayFilter__["a" /* default */]();
	geom.apply(filter);
	return filter.getCoordinates();
};
function RadialComparator() {
	this._origin = null;
	let origin = arguments[0];
	this._origin = origin;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(RadialComparator.prototype, {
	compare: function (o1, o2) {
		var p1 = o1;
		var p2 = o2;
		return RadialComparator.polarCompare(this._origin, p1, p2);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_8__java_util_Comparator__["a" /* default */]];
	},
	getClass: function () {
		return RadialComparator;
	}
});
RadialComparator.polarCompare = function (o, p, q) {
	var dxp = p.x - o.x;
	var dyp = p.y - o.y;
	var dxq = q.x - o.x;
	var dyq = q.y - o.y;
	var orient = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].computeOrientation(o, p, q);
	if (orient === __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].COUNTERCLOCKWISE) return 1;
	if (orient === __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].CLOCKWISE) return -1;
	var op = dxp * dxp + dyp * dyp;
	var oq = dxq * dxq + dyq * dyq;
	if (op < oq) {
		return -1;
	}
	if (op > oq) {
		return 1;
	}
	return 0;
};
ConvexHull.RadialComparator = RadialComparator;


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SegmentString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function SegmentString() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(SegmentString.prototype, {
	getCoordinates: function () {},
	size: function () {},
	getCoordinate: function (i) {},
	isClosed: function () {},
	setData: function (data) {},
	getData: function () {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SegmentString;
	}
});


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = AbstractNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Boundable__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);





function AbstractNode() {
	this._childBoundables = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
	this._bounds = null;
	this._level = null;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let level = arguments[0];
		this._level = level;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(AbstractNode.prototype, {
	getLevel: function () {
		return this._level;
	},
	size: function () {
		return this._childBoundables.size();
	},
	getChildBoundables: function () {
		return this._childBoundables;
	},
	addChildBoundable: function (childBoundable) {
		__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(this._bounds === null);
		this._childBoundables.add(childBoundable);
	},
	isEmpty: function () {
		return this._childBoundables.isEmpty();
	},
	getBounds: function () {
		if (this._bounds === null) {
			this._bounds = this.computeBounds();
		}
		return this._bounds;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_0__Boundable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return AbstractNode;
	}
});
AbstractNode.serialVersionUID = 6493722185909573708;


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Noder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Noder() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Noder.prototype, {
	computeNodes: function (segStrings) {},
	getNodedSubstrings: function () {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Noder;
	}
});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SegmentIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function SegmentIntersector() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(SegmentIntersector.prototype, {
	processIntersections: function (e0, segIndex0, e1, segIndex1) {},
	isDone: function () {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SegmentIntersector;
	}
});


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodeMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_TreeMap__ = __webpack_require__(35);






function NodeMap() {
	this.nodeMap = new __WEBPACK_IMPORTED_MODULE_5__java_util_TreeMap__["a" /* default */]();
	this.nodeFact = null;
	let nodeFact = arguments[0];
	this.nodeFact = nodeFact;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(NodeMap.prototype, {
	find: function (coord) {
		return this.nodeMap.get(coord);
	},
	addNode: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]) {
			let coord = arguments[0];
			var node = this.nodeMap.get(coord);
			if (node === null) {
				node = this.nodeFact.createNode(coord);
				this.nodeMap.put(coord, node);
			}
			return node;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* default */]) {
			let n = arguments[0];
			var node = this.nodeMap.get(n.getCoordinate());
			if (node === null) {
				this.nodeMap.put(n.getCoordinate(), n);
				return n;
			}
			node.mergeLabel(n);
			return node;
		}
	},
	print: function (out) {
		for (var it = this.iterator(); it.hasNext(); ) {
			var n = it.next();
			n.print(out);
		}
	},
	iterator: function () {
		return this.nodeMap.values().iterator();
	},
	values: function () {
		return this.nodeMap.values();
	},
	getBoundaryNodes: function (geomIndex) {
		var bdyNodes = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
		for (var i = this.iterator(); i.hasNext(); ) {
			var node = i.next();
			if (node.getLabel().getLocation(geomIndex) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) bdyNodes.add(node);
		}
		return bdyNodes;
	},
	add: function (e) {
		var p = e.getCoordinate();
		var n = this.addNode(p);
		n.add(e);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NodeMap;
	}
});


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeEnd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Quadrant__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);





function EdgeEnd() {
	this._edge = null;
	this._label = null;
	this._node = null;
	this._p0 = null;
	this._p1 = null;
	this._dx = null;
	this._dy = null;
	this._quadrant = null;
	if (arguments.length === 1) {
		let edge = arguments[0];
		this._edge = edge;
	} else if (arguments.length === 3) {
		let edge = arguments[0], p0 = arguments[1], p1 = arguments[2];
		EdgeEnd.call(this, edge, p0, p1, null);
	} else if (arguments.length === 4) {
		let edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];
		EdgeEnd.call(this, edge);
		this.init(p0, p1);
		this._label = label;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeEnd.prototype, {
	compareDirection: function (e) {
		if (this._dx === e._dx && this._dy === e._dy) return 0;
		if (this._quadrant > e._quadrant) return 1;
		if (this._quadrant < e._quadrant) return -1;
		return __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(e._p0, e._p1, this._p1);
	},
	getDy: function () {
		return this._dy;
	},
	getCoordinate: function () {
		return this._p0;
	},
	setNode: function (node) {
		this._node = node;
	},
	print: function (out) {
		var angle = Math.atan2(this._dy, this._dx);
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		out.print("  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle + "   " + this._label);
	},
	compareTo: function (obj) {
		var e = obj;
		return this.compareDirection(e);
	},
	getDirectedCoordinate: function () {
		return this._p1;
	},
	getDx: function () {
		return this._dx;
	},
	getLabel: function () {
		return this._label;
	},
	getEdge: function () {
		return this._edge;
	},
	getQuadrant: function () {
		return this._quadrant;
	},
	getNode: function () {
		return this._node;
	},
	toString: function () {
		var angle = Math.atan2(this._dy, this._dx);
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		return "  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle + "   " + this._label;
	},
	computeLabel: function (boundaryNodeRule) {},
	init: function (p0, p1) {
		this._p0 = p0;
		this._p1 = p1;
		this._dx = p1.x - p0.x;
		this._dy = p1.y - p0.y;
		this._quadrant = __WEBPACK_IMPORTED_MODULE_3__Quadrant__["a" /* default */].quadrant(this._dx, this._dy);
		__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return EdgeEnd;
	}
});


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodeFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function NodeFactory() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(NodeFactory.prototype, {
	createNode: function (coord) {
		return new __WEBPACK_IMPORTED_MODULE_0__Node__["a" /* default */](coord, null);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NodeFactory;
	}
});


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OverlayNodeFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geomgraph_DirectedEdgeStar__ = __webpack_require__(251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_Node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geomgraph_NodeFactory__ = __webpack_require__(100);





function OverlayNodeFactory() {
	__WEBPACK_IMPORTED_MODULE_4__geomgraph_NodeFactory__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(OverlayNodeFactory, __WEBPACK_IMPORTED_MODULE_4__geomgraph_NodeFactory__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(OverlayNodeFactory.prototype, {
	createNode: function (coord) {
		return new __WEBPACK_IMPORTED_MODULE_1__geomgraph_Node__["a" /* default */](coord, new __WEBPACK_IMPORTED_MODULE_0__geomgraph_DirectedEdgeStar__["a" /* default */]());
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return OverlayNodeFactory;
	}
});


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryGraphOperation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_BoundaryNodeRule__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_GeometryGraph__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__algorithm_RobustLineIntersector__ = __webpack_require__(22);




function GeometryGraphOperation() {
	this._li = new __WEBPACK_IMPORTED_MODULE_3__algorithm_RobustLineIntersector__["a" /* default */]();
	this._resultPrecisionModel = null;
	this._arg = null;
	if (arguments.length === 1) {
		let g0 = arguments[0];
		this.setComputationPrecision(g0.getPrecisionModel());
		this._arg = new Array(1).fill(null);
		this._arg[0] = new __WEBPACK_IMPORTED_MODULE_2__geomgraph_GeometryGraph__["a" /* default */](0, g0);
		;
	} else if (arguments.length === 2) {
		let g0 = arguments[0], g1 = arguments[1];
		GeometryGraphOperation.call(this, g0, g1, __WEBPACK_IMPORTED_MODULE_0__algorithm_BoundaryNodeRule__["a" /* default */].OGC_SFS_BOUNDARY_RULE);
	} else if (arguments.length === 3) {
		let g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];
		if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());
		this._arg = new Array(2).fill(null);
		this._arg[0] = new __WEBPACK_IMPORTED_MODULE_2__geomgraph_GeometryGraph__["a" /* default */](0, g0, boundaryNodeRule);
		this._arg[1] = new __WEBPACK_IMPORTED_MODULE_2__geomgraph_GeometryGraph__["a" /* default */](1, g1, boundaryNodeRule);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(GeometryGraphOperation.prototype, {
	getArgGeometry: function (i) {
		return this._arg[i].getGeometry();
	},
	setComputationPrecision: function (pm) {
		this._resultPrecisionModel = pm;
		this._li.setPrecisionModel(this._resultPrecisionModel);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryGraphOperation;
	}
});


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DoubleBits;
function DoubleBits () { }
DoubleBits.exponent = function (d) {
  return CVTFWD(64, d) - 1023
}
DoubleBits.powerOf2 = function (exp) {
  return Math.pow(2, exp)
}

/**
 * Calculates the exponent of the bit-pattern for a number. Uses code from:
 * http://www.merlyn.demon.co.uk/js-exact.htm
 *
 * @param {Number}
 *          NumW 32 or 64 to denote the number of bits.
 * @param {Number}
 *          Qty the number to calculate the bit pattern for.
 * @return {Number} The integer value of the exponent.
 */
function CVTFWD (NumW, Qty) {
  var Sign
  var Expo
  var Mant
  var Bin
  var Inf = {
    32: {
      d: 0x7F,
      c: 0x80,
      b: 0,
      a: 0
    },
    64: {
      d: 0x7FF0,
      c: 0,
      b: 0,
      a: 0
    }
  }
  var ExW = {
    32: 8,
    64: 11
  }[NumW]

  if (!Bin) {
    Sign = Qty < 0 || 1 / Qty < 0 // OK for +-0
    if (!isFinite(Qty)) {
      Bin = Inf[NumW]
      if (Sign) {
        Bin.d += 1 << (NumW / 4 - 1)
      }
      Expo = Math.pow(2, ExW) - 1
      Mant = 0
    }
  }

  if (!Bin) {
    Expo = {
      32: 127,
      64: 1023
    }[NumW]
    Mant = Math.abs(Qty)
    while (Mant >= 2) {
      Expo++
      Mant /= 2
    }
    while (Mant < 1 && Expo > 0) {
      Expo--
      Mant *= 2
    }
    if (Expo <= 0) {
      Mant /= 2
    }
    if (NumW === 32 && Expo > 254) {
      Bin = {
        d: Sign ? 0xFF : 0x7F,
        c: 0x80,
        b: 0,
        a: 0
      }
      Expo = Math.pow(2, ExW) - 1
      Mant = 0
    }
  }

  return Expo
}


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Angle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function Angle() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Angle.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Angle;
	}
});
Angle.toDegrees = function (radians) {
	return radians * 180 / Math.PI;
};
Angle.normalize = function (angle) {
	while (angle > Math.PI) angle -= Angle.PI_TIMES_2;
	while (angle <= -Math.PI) angle += Angle.PI_TIMES_2;
	return angle;
};
Angle.angle = function () {
	if (arguments.length === 1) {
		let p = arguments[0];
		return Math.atan2(p.y, p.x);
	} else if (arguments.length === 2) {
		let p0 = arguments[0], p1 = arguments[1];
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		return Math.atan2(dy, dx);
	}
};
Angle.isAcute = function (p0, p1, p2) {
	var dx0 = p0.x - p1.x;
	var dy0 = p0.y - p1.y;
	var dx1 = p2.x - p1.x;
	var dy1 = p2.y - p1.y;
	var dotprod = dx0 * dx1 + dy0 * dy1;
	return dotprod > 0;
};
Angle.isObtuse = function (p0, p1, p2) {
	var dx0 = p0.x - p1.x;
	var dy0 = p0.y - p1.y;
	var dx1 = p2.x - p1.x;
	var dy1 = p2.y - p1.y;
	var dotprod = dx0 * dx1 + dy0 * dy1;
	return dotprod < 0;
};
Angle.interiorAngle = function (p0, p1, p2) {
	var anglePrev = Angle.angle(p1, p0);
	var angleNext = Angle.angle(p1, p2);
	return Math.abs(angleNext - anglePrev);
};
Angle.normalizePositive = function (angle) {
	if (angle < 0.0) {
		while (angle < 0.0) angle += Angle.PI_TIMES_2;
		if (angle >= Angle.PI_TIMES_2) angle = 0.0;
	} else {
		while (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2;
		if (angle < 0.0) angle = 0.0;
	}
	return angle;
};
Angle.angleBetween = function (tip1, tail, tip2) {
	var a1 = Angle.angle(tail, tip1);
	var a2 = Angle.angle(tail, tip2);
	return Angle.diff(a1, a2);
};
Angle.diff = function (ang1, ang2) {
	var delAngle = null;
	if (ang1 < ang2) {
		delAngle = ang2 - ang1;
	} else {
		delAngle = ang1 - ang2;
	}
	if (delAngle > Math.PI) {
		delAngle = 2 * Math.PI - delAngle;
	}
	return delAngle;
};
Angle.toRadians = function (angleDegrees) {
	return angleDegrees * Math.PI / 180.0;
};
Angle.getTurn = function (ang1, ang2) {
	var crossproduct = Math.sin(ang2 - ang1);
	if (crossproduct > 0) {
		return Angle.COUNTERCLOCKWISE;
	}
	if (crossproduct < 0) {
		return Angle.CLOCKWISE;
	}
	return Angle.NONE;
};
Angle.angleBetweenOriented = function (tip1, tail, tip2) {
	var a1 = Angle.angle(tail, tip1);
	var a2 = Angle.angle(tail, tip2);
	var angDel = a2 - a1;
	if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;
	if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;
	return angDel;
};
Angle.PI_TIMES_2 = 2.0 * Math.PI;
Angle.PI_OVER_2 = Math.PI / 2.0;
Angle.PI_OVER_4 = Math.PI / 4.0;
Angle.COUNTERCLOCKWISE = __WEBPACK_IMPORTED_MODULE_0__CGAlgorithms__["a" /* default */].COUNTERCLOCKWISE;
Angle.CLOCKWISE = __WEBPACK_IMPORTED_MODULE_0__CGAlgorithms__["a" /* default */].CLOCKWISE;
Angle.NONE = __WEBPACK_IMPORTED_MODULE_0__CGAlgorithms__["a" /* default */].COLLINEAR;


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IsValidOp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ConnectedInteriorTester__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__algorithm_MCPointInRing__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geomgraph_GeometryGraph__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ConsistentAreaTester__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__IndexedNestedRingTester__ = __webpack_require__(338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__ = __webpack_require__(339);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__util_Assert__ = __webpack_require__(4);





















function IsValidOp() {
	this._parentGeometry = null;
	this._isSelfTouchingRingFormingHoleValid = false;
	this._validErr = null;
	let parentGeometry = arguments[0];
	this._parentGeometry = parentGeometry;
}
Object(__WEBPACK_IMPORTED_MODULE_11__extend__["a" /* default */])(IsValidOp.prototype, {
	checkInvalidCoordinates: function () {
		if (arguments[0] instanceof Array) {
			let coords = arguments[0];
			for (var i = 0; i < coords.length; i++) {
				if (!IsValidOp.isValid(coords[i])) {
					this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].INVALID_COORDINATE, coords[i]);
					return null;
				}
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_7__geom_Polygon__["a" /* default */]) {
			let poly = arguments[0];
			this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());
			if (this._validErr !== null) return null;
			for (var i = 0; i < poly.getNumInteriorRing(); i++) {
				this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());
				if (this._validErr !== null) return null;
			}
		}
	},
	checkHolesNotNested: function (p, graph) {
		var nestedTester = new __WEBPACK_IMPORTED_MODULE_17__IndexedNestedRingTester__["a" /* default */](graph);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var innerHole = p.getInteriorRingN(i);
			nestedTester.add(innerHole);
		}
		var isNonNested = nestedTester.isNonNested();
		if (!isNonNested) {
			this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].NESTED_HOLES, nestedTester.getNestedPoint());
		}
	},
	checkConsistentArea: function (graph) {
		var cat = new __WEBPACK_IMPORTED_MODULE_15__ConsistentAreaTester__["a" /* default */](graph);
		var isValidArea = cat.isNodeConsistentArea();
		if (!isValidArea) {
			this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].SELF_INTERSECTION, cat.getInvalidPoint());
			return null;
		}
		if (cat.hasDuplicateRings()) {
			this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].DUPLICATE_RINGS, cat.getInvalidPoint());
		}
	},
	isValid: function () {
		this.checkValid(this._parentGeometry);
		return this._validErr === null;
	},
	checkShellInsideHole: function (shell, hole, graph) {
		var shellPts = shell.getCoordinates();
		var holePts = hole.getCoordinates();
		var shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);
		if (shellPt !== null) {
			var insideHole = __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(shellPt, holePts);
			if (!insideHole) {
				return shellPt;
			}
		}
		var holePt = IsValidOp.findPtNotNode(holePts, shell, graph);
		if (holePt !== null) {
			var insideShell = __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(holePt, shellPts);
			if (insideShell) {
				return holePt;
			}
			return null;
		}
		__WEBPACK_IMPORTED_MODULE_20__util_Assert__["a" /* default */].shouldNeverReachHere("points in shell and hole appear to be equal");
		return null;
	},
	checkNoSelfIntersectingRings: function (graph) {
		for (var i = graph.getEdgeIterator(); i.hasNext(); ) {
			var e = i.next();
			this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());
			if (this._validErr !== null) return null;
		}
	},
	checkConnectedInteriors: function (graph) {
		var cit = new __WEBPACK_IMPORTED_MODULE_4__ConnectedInteriorTester__["a" /* default */](graph);
		if (!cit.isInteriorsConnected()) this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].DISCONNECTED_INTERIOR, cit.getCoordinate());
	},
	checkNoSelfIntersectingRing: function (eiList) {
		var nodeSet = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */]();
		var isFirst = true;
		for (var i = eiList.iterator(); i.hasNext(); ) {
			var ei = i.next();
			if (isFirst) {
				isFirst = false;
				continue;
			}
			if (nodeSet.contains(ei.coord)) {
				this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].RING_SELF_INTERSECTION, ei.coord);
				return null;
			} else {
				nodeSet.add(ei.coord);
			}
		}
	},
	checkHolesInShell: function (p, graph) {
		var shell = p.getExteriorRing();
		var pir = new __WEBPACK_IMPORTED_MODULE_12__algorithm_MCPointInRing__["a" /* default */](shell);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			var holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);
			if (holePt === null) return null;
			var outside = !pir.isInside(holePt);
			if (outside) {
				this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].HOLE_OUTSIDE_SHELL, holePt);
				return null;
			}
		}
	},
	checkTooFewPoints: function (graph) {
		if (graph.hasTooFewPoints()) {
			this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].TOO_FEW_POINTS, graph.getInvalidPoint());
			return null;
		}
	},
	getValidationError: function () {
		this.checkValid(this._parentGeometry);
		return this._validErr;
	},
	checkValid: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_6__geom_Point__["a" /* default */]) {
			let g = arguments[0];
			this.checkInvalidCoordinates(g.getCoordinates());
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_8__geom_MultiPoint__["a" /* default */]) {
			let g = arguments[0];
			this.checkInvalidCoordinates(g.getCoordinates());
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_9__geom_LinearRing__["a" /* default */]) {
			let g = arguments[0];
			this.checkInvalidCoordinates(g.getCoordinates());
			if (this._validErr !== null) return null;
			this.checkClosedRing(g);
			if (this._validErr !== null) return null;
			var graph = new __WEBPACK_IMPORTED_MODULE_13__geomgraph_GeometryGraph__["a" /* default */](0, g);
			this.checkTooFewPoints(graph);
			if (this._validErr !== null) return null;
			var li = new __WEBPACK_IMPORTED_MODULE_18__algorithm_RobustLineIntersector__["a" /* default */]();
			graph.computeSelfNodes(li, true, true);
			this.checkNoSelfIntersectingRings(graph);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) {
			let g = arguments[0];
			this.checkInvalidCoordinates(g.getCoordinates());
			if (this._validErr !== null) return null;
			var graph = new __WEBPACK_IMPORTED_MODULE_13__geomgraph_GeometryGraph__["a" /* default */](0, g);
			this.checkTooFewPoints(graph);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_7__geom_Polygon__["a" /* default */]) {
			let g = arguments[0];
			this.checkInvalidCoordinates(g);
			if (this._validErr !== null) return null;
			this.checkClosedRings(g);
			if (this._validErr !== null) return null;
			var graph = new __WEBPACK_IMPORTED_MODULE_13__geomgraph_GeometryGraph__["a" /* default */](0, g);
			this.checkTooFewPoints(graph);
			if (this._validErr !== null) return null;
			this.checkConsistentArea(graph);
			if (this._validErr !== null) return null;
			if (!this._isSelfTouchingRingFormingHoleValid) {
				this.checkNoSelfIntersectingRings(graph);
				if (this._validErr !== null) return null;
			}
			this.checkHolesInShell(g, graph);
			if (this._validErr !== null) return null;
			this.checkHolesNotNested(g, graph);
			if (this._validErr !== null) return null;
			this.checkConnectedInteriors(graph);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_14__geom_MultiPolygon__["a" /* default */]) {
			let g = arguments[0];
			for (var i = 0; i < g.getNumGeometries(); i++) {
				var p = g.getGeometryN(i);
				this.checkInvalidCoordinates(p);
				if (this._validErr !== null) return null;
				this.checkClosedRings(p);
				if (this._validErr !== null) return null;
			}
			var graph = new __WEBPACK_IMPORTED_MODULE_13__geomgraph_GeometryGraph__["a" /* default */](0, g);
			this.checkTooFewPoints(graph);
			if (this._validErr !== null) return null;
			this.checkConsistentArea(graph);
			if (this._validErr !== null) return null;
			if (!this._isSelfTouchingRingFormingHoleValid) {
				this.checkNoSelfIntersectingRings(graph);
				if (this._validErr !== null) return null;
			}
			for (var i = 0; i < g.getNumGeometries(); i++) {
				var p = g.getGeometryN(i);
				this.checkHolesInShell(p, graph);
				if (this._validErr !== null) return null;
			}
			for (var i = 0; i < g.getNumGeometries(); i++) {
				var p = g.getGeometryN(i);
				this.checkHolesNotNested(p, graph);
				if (this._validErr !== null) return null;
			}
			this.checkShellsNotNested(g, graph);
			if (this._validErr !== null) return null;
			this.checkConnectedInteriors(graph);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_16__geom_GeometryCollection__["a" /* default */]) {
			let gc = arguments[0];
			for (var i = 0; i < gc.getNumGeometries(); i++) {
				var g = gc.getGeometryN(i);
				this.checkValid(g);
				if (this._validErr !== null) return null;
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Geometry__["a" /* default */]) {
			let g = arguments[0];
			this._validErr = null;
			if (g.isEmpty()) return null;
			if (g instanceof __WEBPACK_IMPORTED_MODULE_6__geom_Point__["a" /* default */]) this.checkValid(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_8__geom_MultiPoint__["a" /* default */]) this.checkValid(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_9__geom_LinearRing__["a" /* default */]) this.checkValid(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) this.checkValid(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_7__geom_Polygon__["a" /* default */]) this.checkValid(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_14__geom_MultiPolygon__["a" /* default */]) this.checkValid(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_16__geom_GeometryCollection__["a" /* default */]) this.checkValid(g); else throw new UnsupportedOperationException(g.getClass().getName());
		}
	},
	setSelfTouchingRingFormingHoleValid: function (isValid) {
		this._isSelfTouchingRingFormingHoleValid = isValid;
	},
	checkShellNotNested: function (shell, p, graph) {
		var shellPts = shell.getCoordinates();
		var polyShell = p.getExteriorRing();
		var polyPts = polyShell.getCoordinates();
		var shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);
		if (shellPt === null) return null;
		var insidePolyShell = __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(shellPt, polyPts);
		if (!insidePolyShell) return null;
		if (p.getNumInteriorRing() <= 0) {
			this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].NESTED_SHELLS, shellPt);
			return null;
		}
		var badNestedPt = null;
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			badNestedPt = this.checkShellInsideHole(shell, hole, graph);
			if (badNestedPt === null) return null;
		}
		this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].NESTED_SHELLS, badNestedPt);
	},
	checkClosedRings: function (poly) {
		this.checkClosedRing(poly.getExteriorRing());
		if (this._validErr !== null) return null;
		for (var i = 0; i < poly.getNumInteriorRing(); i++) {
			this.checkClosedRing(poly.getInteriorRingN(i));
			if (this._validErr !== null) return null;
		}
	},
	checkClosedRing: function (ring) {
		if (!ring.isClosed()) {
			var pt = null;
			if (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);
			this._validErr = new __WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */](__WEBPACK_IMPORTED_MODULE_19__TopologyValidationError__["a" /* default */].RING_NOT_CLOSED, pt);
		}
	},
	checkShellsNotNested: function (mp, graph) {
		for (var i = 0; i < mp.getNumGeometries(); i++) {
			var p = mp.getGeometryN(i);
			var shell = p.getExteriorRing();
			for (var j = 0; j < mp.getNumGeometries(); j++) {
				if (i === j) continue;
				var p2 = mp.getGeometryN(j);
				this.checkShellNotNested(shell, p2, graph);
				if (this._validErr !== null) return null;
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IsValidOp;
	}
});
IsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {
	var searchEdge = graph.findEdge(searchRing);
	var eiList = searchEdge.getEdgeIntersectionList();
	for (var i = 0; i < testCoords.length; i++) {
		var pt = testCoords[i];
		if (!eiList.isIntersection(pt)) return pt;
	}
	return null;
};
IsValidOp.isValid = function () {
	if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Geometry__["a" /* default */]) {
		let geom = arguments[0];
		var isValidOp = new IsValidOp(geom);
		return isValidOp.isValid();
	} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Coordinate__["a" /* default */]) {
		let coord = arguments[0];
		if (__WEBPACK_IMPORTED_MODULE_10__java_lang_Double__["a" /* default */].isNaN(coord.x)) return false;
		if (__WEBPACK_IMPORTED_MODULE_10__java_lang_Double__["a" /* default */].isInfinite(coord.x)) return false;
		if (__WEBPACK_IMPORTED_MODULE_10__java_lang_Double__["a" /* default */].isNaN(coord.y)) return false;
		if (__WEBPACK_IMPORTED_MODULE_10__java_lang_Double__["a" /* default */].isInfinite(coord.y)) return false;
		return true;
	}
};


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryCombiner;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__ = __webpack_require__(1);


function GeometryCombiner() {
	this._geomFactory = null;
	this._skipEmpty = false;
	this._inputGeoms = null;
	let geoms = arguments[0];
	this._geomFactory = GeometryCombiner.extractFactory(geoms);
	this._inputGeoms = geoms;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GeometryCombiner.prototype, {
	extractElements: function (geom, elems) {
		if (geom === null) return null;
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elemGeom = geom.getGeometryN(i);
			if (this._skipEmpty && elemGeom.isEmpty()) continue;
			elems.add(elemGeom);
		}
	},
	combine: function () {
		var elems = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
		for (var i = this._inputGeoms.iterator(); i.hasNext(); ) {
			var g = i.next();
			this.extractElements(g, elems);
		}
		if (elems.size() === 0) {
			if (this._geomFactory !== null) {
				return this._geomFactory.createGeometryCollection(null);
			}
			return null;
		}
		return this._geomFactory.buildGeometry(elems);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryCombiner;
	}
});
GeometryCombiner.combine = function () {
	if (arguments.length === 1) {
		let geoms = arguments[0];
		var combiner = new GeometryCombiner(geoms);
		return combiner.combine();
	} else if (arguments.length === 2) {
		let g0 = arguments[0], g1 = arguments[1];
		var combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
		return combiner.combine();
	} else if (arguments.length === 3) {
		let g0 = arguments[0], g1 = arguments[1], g2 = arguments[2];
		var combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));
		return combiner.combine();
	}
};
GeometryCombiner.extractFactory = function (geoms) {
	if (geoms.isEmpty()) return null;
	return geoms.iterator().next().getFactory();
};
GeometryCombiner.createList = function () {
	if (arguments.length === 2) {
		let obj0 = arguments[0], obj1 = arguments[1];
		var list = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
		list.add(obj0);
		list.add(obj1);
		return list;
	} else if (arguments.length === 3) {
		let obj0 = arguments[0], obj1 = arguments[1], obj2 = arguments[2];
		var list = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
		list.add(obj0);
		list.add(obj1);
		list.add(obj2);
		return list;
	}
};


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IncrementalDelaunayTriangulator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__quadedge_QuadEdge__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function IncrementalDelaunayTriangulator() {
	this._subdiv = null;
	this._isUsingTolerance = false;
	let subdiv = arguments[0];
	this._subdiv = subdiv;
	this._isUsingTolerance = subdiv.getTolerance() > 0.0;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(IncrementalDelaunayTriangulator.prototype, {
	insertSite: function (v) {
		var e = this._subdiv.locate(v);
		if (this._subdiv.isVertexOfEdge(e, v)) {
			return e;
		} else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {
			e = e.oPrev();
			this._subdiv.delete(e.oNext());
		}
		var base = this._subdiv.makeEdge(e.orig(), v);
		__WEBPACK_IMPORTED_MODULE_0__quadedge_QuadEdge__["a" /* default */].splice(base, e);
		var startEdge = base;
		do {
			base = this._subdiv.connect(e, base.sym());
			e = base.oPrev();
		} while (e.lNext() !== startEdge);
		do {
			var t = e.oPrev();
			if (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {
				__WEBPACK_IMPORTED_MODULE_0__quadedge_QuadEdge__["a" /* default */].swap(e);
				e = e.oPrev();
			} else if (e.oNext() === startEdge) {
				return base;
			} else {
				e = e.oNext().lPrev();
			}
		} while (true);
	},
	insertSites: function (vertices) {
		for (var i = vertices.iterator(); i.hasNext(); ) {
			var v = i.next();
			this.insertSite(v);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IncrementalDelaunayTriangulator;
	}
});


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = QuadEdgeSubdivision;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__QuadEdge__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_HashSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_Stack__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__LastFoundQuadEdgeLocator__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__LocateFailureException__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Vertex__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__geom_Triangle__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__TriangleVisitor__ = __webpack_require__(372);


















function QuadEdgeSubdivision() {
	this._visitedKey = 0;
	this._quadEdges = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
	this._startingEdge = null;
	this._tolerance = null;
	this._edgeCoincidenceTolerance = null;
	this._frameVertex = new Array(3).fill(null);
	this._frameEnv = null;
	this._locator = null;
	this._seg = new __WEBPACK_IMPORTED_MODULE_13__geom_LineSegment__["a" /* default */]();
	this._triEdges = new Array(3).fill(null);
	let env = arguments[0], tolerance = arguments[1];
	this._tolerance = tolerance;
	this._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;
	this.createFrame(env);
	this._startingEdge = this.initSubdiv();
	this._locator = new __WEBPACK_IMPORTED_MODULE_9__LastFoundQuadEdgeLocator__["a" /* default */](this);
}
Object(__WEBPACK_IMPORTED_MODULE_8__extend__["a" /* default */])(QuadEdgeSubdivision.prototype, {
	getTriangleVertices: function (includeFrame) {
		var visitor = new TriangleVertexListVisitor();
		this.visitTriangles(visitor, includeFrame);
		return visitor.getTriangleVertices();
	},
	isFrameVertex: function (v) {
		if (v.equals(this._frameVertex[0])) return true;
		if (v.equals(this._frameVertex[1])) return true;
		if (v.equals(this._frameVertex[2])) return true;
		return false;
	},
	isVertexOfEdge: function (e, v) {
		if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {
			return true;
		}
		return false;
	},
	connect: function (a, b) {
		var q = __WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].connect(a, b);
		this._quadEdges.add(q);
		return q;
	},
	getVoronoiCellPolygon: function (qe, geomFact) {
		var cellPts = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		var startQE = qe;
		do {
			var cc = qe.rot().orig().getCoordinate();
			cellPts.add(cc);
			qe = qe.oPrev();
		} while (qe !== startQE);
		var coordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
		coordList.addAll(cellPts, false);
		coordList.closeRing();
		if (coordList.size() < 4) {
			__WEBPACK_IMPORTED_MODULE_12__java_lang_System__["a" /* default */].out.println(coordList);
			coordList.add(coordList.get(coordList.size() - 1), true);
		}
		var pts = coordList.toCoordinateArray();
		var cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts), null);
		var v = startQE.orig();
		cellPoly.setUserData(v.getCoordinate());
		return cellPoly;
	},
	setLocator: function (locator) {
		this._locator = locator;
	},
	initSubdiv: function () {
		var ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);
		var eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);
		__WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].splice(ea.sym(), eb);
		var ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);
		__WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].splice(eb.sym(), ec);
		__WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].splice(ec.sym(), ea);
		return ea;
	},
	isFrameBorderEdge: function (e) {
		var leftTri = new Array(3).fill(null);
		QuadEdgeSubdivision.getTriangleEdges(e, leftTri);
		var rightTri = new Array(3).fill(null);
		QuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);
		var vLeftTriOther = e.lNext().dest();
		if (this.isFrameVertex(vLeftTriOther)) return true;
		var vRightTriOther = e.sym().lNext().dest();
		if (this.isFrameVertex(vRightTriOther)) return true;
		return false;
	},
	makeEdge: function (o, d) {
		var q = __WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].makeEdge(o, d);
		this._quadEdges.add(q);
		return q;
	},
	visitTriangles: function (triVisitor, includeFrame) {
		this._visitedKey++;
		var edgeStack = new __WEBPACK_IMPORTED_MODULE_7__java_util_Stack__["a" /* default */]();
		edgeStack.push(this._startingEdge);
		var visitedEdges = new __WEBPACK_IMPORTED_MODULE_2__java_util_HashSet__["a" /* default */]();
		while (!edgeStack.empty()) {
			var edge = edgeStack.pop();
			if (!visitedEdges.contains(edge)) {
				var triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);
				if (triEdges !== null) triVisitor.visit(triEdges);
			}
		}
	},
	isFrameEdge: function (e) {
		if (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;
		return false;
	},
	isOnEdge: function (e, p) {
		this._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());
		var dist = this._seg.distance(p);
		return dist < this._edgeCoincidenceTolerance;
	},
	getEnvelope: function () {
		return new __WEBPACK_IMPORTED_MODULE_15__geom_Envelope__["a" /* default */](this._frameEnv);
	},
	createFrame: function (env) {
		var deltaX = env.getWidth();
		var deltaY = env.getHeight();
		var offset = 0.0;
		if (deltaX > deltaY) {
			offset = deltaX * 10.0;
		} else {
			offset = deltaY * 10.0;
		}
		this._frameVertex[0] = new __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */]((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);
		this._frameVertex[1] = new __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */](env.getMinX() - offset, env.getMinY() - offset);
		this._frameVertex[2] = new __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */](env.getMaxX() + offset, env.getMinY() - offset);
		this._frameEnv = new __WEBPACK_IMPORTED_MODULE_15__geom_Envelope__["a" /* default */](this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());
		this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());
	},
	getTriangleCoordinates: function (includeFrame) {
		var visitor = new TriangleCoordinatesVisitor();
		this.visitTriangles(visitor, includeFrame);
		return visitor.getTriangles();
	},
	getVertices: function (includeFrame) {
		var vertices = new __WEBPACK_IMPORTED_MODULE_2__java_util_HashSet__["a" /* default */]();
		for (var i = this._quadEdges.iterator(); i.hasNext(); ) {
			var qe = i.next();
			var v = qe.orig();
			if (includeFrame || !this.isFrameVertex(v)) vertices.add(v);
			var vd = qe.dest();
			if (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);
		}
		return vertices;
	},
	fetchTriangleToVisit: function (edge, edgeStack, includeFrame, visitedEdges) {
		var curr = edge;
		var edgeCount = 0;
		var isFrame = false;
		do {
			this._triEdges[edgeCount] = curr;
			if (this.isFrameEdge(curr)) isFrame = true;
			var sym = curr.sym();
			if (!visitedEdges.contains(sym)) edgeStack.push(sym);
			visitedEdges.add(curr);
			edgeCount++;
			curr = curr.lNext();
		} while (curr !== edge);
		if (isFrame && !includeFrame) return null;
		return this._triEdges;
	},
	getEdges: function () {
		if (arguments.length === 0) {
			return this._quadEdges;
		} else if (arguments.length === 1) {
			let geomFact = arguments[0];
			var quadEdges = this.getPrimaryEdges(false);
			var edges = new Array(quadEdges.size()).fill(null);
			var i = 0;
			for (var it = quadEdges.iterator(); it.hasNext(); ) {
				var qe = it.next();
				edges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);
			}
			return geomFact.createMultiLineString(edges);
		}
	},
	getVertexUniqueEdges: function (includeFrame) {
		var edges = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		var visitedVertices = new __WEBPACK_IMPORTED_MODULE_2__java_util_HashSet__["a" /* default */]();
		for (var i = this._quadEdges.iterator(); i.hasNext(); ) {
			var qe = i.next();
			var v = qe.orig();
			if (!visitedVertices.contains(v)) {
				visitedVertices.add(v);
				if (includeFrame || !this.isFrameVertex(v)) {
					edges.add(qe);
				}
			}
			var qd = qe.sym();
			var vd = qd.orig();
			if (!visitedVertices.contains(vd)) {
				visitedVertices.add(vd);
				if (includeFrame || !this.isFrameVertex(vd)) {
					edges.add(qd);
				}
			}
		}
		return edges;
	},
	getTriangleEdges: function (includeFrame) {
		var visitor = new TriangleEdgesListVisitor();
		this.visitTriangles(visitor, includeFrame);
		return visitor.getTriangleEdges();
	},
	getPrimaryEdges: function (includeFrame) {
		this._visitedKey++;
		var edges = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		var edgeStack = new __WEBPACK_IMPORTED_MODULE_7__java_util_Stack__["a" /* default */]();
		edgeStack.push(this._startingEdge);
		var visitedEdges = new __WEBPACK_IMPORTED_MODULE_2__java_util_HashSet__["a" /* default */]();
		while (!edgeStack.empty()) {
			var edge = edgeStack.pop();
			if (!visitedEdges.contains(edge)) {
				var priQE = edge.getPrimary();
				if (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);
				edgeStack.push(edge.oNext());
				edgeStack.push(edge.sym().oNext());
				visitedEdges.add(edge);
				visitedEdges.add(edge.sym());
			}
		}
		return edges;
	},
	delete: function (e) {
		__WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].splice(e, e.oPrev());
		__WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].splice(e.sym(), e.sym().oPrev());
		var eSym = e.sym();
		var eRot = e.rot();
		var eRotSym = e.rot().sym();
		this._quadEdges.remove(e);
		this._quadEdges.remove(eSym);
		this._quadEdges.remove(eRot);
		this._quadEdges.remove(eRotSym);
		e.delete();
		eSym.delete();
		eRot.delete();
		eRotSym.delete();
	},
	locateFromEdge: function (v, startEdge) {
		var iter = 0;
		var maxIter = this._quadEdges.size();
		var e = startEdge;
		while (true) {
			iter++;
			if (iter > maxIter) {
				throw new __WEBPACK_IMPORTED_MODULE_10__LocateFailureException__["a" /* default */](e.toLineSegment());
			}
			if (v.equals(e.orig()) || v.equals(e.dest())) {
				break;
			} else if (v.rightOf(e)) {
				e = e.sym();
			} else if (!v.rightOf(e.oNext())) {
				e = e.oNext();
			} else if (!v.rightOf(e.dPrev())) {
				e = e.dPrev();
			} else {
				break;
			}
		}
		return e;
	},
	getTolerance: function () {
		return this._tolerance;
	},
	getVoronoiCellPolygons: function (geomFact) {
		this.visitTriangles(new TriangleCircumcentreVisitor(), true);
		var cells = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		var edges = this.getVertexUniqueEdges(false);
		for (var i = edges.iterator(); i.hasNext(); ) {
			var qe = i.next();
			cells.add(this.getVoronoiCellPolygon(qe, geomFact));
		}
		return cells;
	},
	getVoronoiDiagram: function (geomFact) {
		var vorCells = this.getVoronoiCellPolygons(geomFact);
		return geomFact.createGeometryCollection(__WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__["a" /* default */].toGeometryArray(vorCells));
	},
	getTriangles: function (geomFact) {
		var triPtsList = this.getTriangleCoordinates(false);
		var tris = new Array(triPtsList.size()).fill(null);
		var i = 0;
		for (var it = triPtsList.iterator(); it.hasNext(); ) {
			var triPt = it.next();
			tris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt), null);
		}
		return geomFact.createGeometryCollection(tris);
	},
	insertSite: function (v) {
		var e = this.locate(v);
		if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {
			return e;
		}
		var base = this.makeEdge(e.orig(), v);
		__WEBPACK_IMPORTED_MODULE_0__QuadEdge__["a" /* default */].splice(base, e);
		var startEdge = base;
		do {
			base = this.connect(e, base.sym());
			e = base.oPrev();
		} while (e.lNext() !== startEdge);
		return startEdge;
	},
	locate: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */]) {
				let v = arguments[0];
				return this._locator.locate(v);
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Coordinate__["a" /* default */]) {
				let p = arguments[0];
				return this._locator.locate(new __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */](p));
			}
		} else if (arguments.length === 2) {
			let p0 = arguments[0], p1 = arguments[1];
			var e = this._locator.locate(new __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */](p0));
			if (e === null) return null;
			var base = e;
			if (e.dest().getCoordinate().equals2D(p0)) base = e.sym();
			var locEdge = base;
			do {
				if (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;
				locEdge = locEdge.oNext();
			} while (locEdge !== base);
			return null;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return QuadEdgeSubdivision;
	}
});
QuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {
	triEdge[0] = startQE;
	triEdge[1] = triEdge[0].lNext();
	triEdge[2] = triEdge[1].lNext();
	if (triEdge[2].lNext() !== triEdge[0]) throw new __WEBPACK_IMPORTED_MODULE_6__java_lang_IllegalArgumentException__["a" /* default */]("Edges do not form a triangle");
};
function TriangleCircumcentreVisitor() {}
Object(__WEBPACK_IMPORTED_MODULE_8__extend__["a" /* default */])(TriangleCircumcentreVisitor.prototype, {
	visit: function (triEdges) {
		var a = triEdges[0].orig().getCoordinate();
		var b = triEdges[1].orig().getCoordinate();
		var c = triEdges[2].orig().getCoordinate();
		var cc = __WEBPACK_IMPORTED_MODULE_16__geom_Triangle__["a" /* default */].circumcentre(a, b, c);
		var ccVertex = new __WEBPACK_IMPORTED_MODULE_11__Vertex__["a" /* default */](cc);
		for (var i = 0; i < 3; i++) {
			triEdges[i].rot().setOrig(ccVertex);
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_17__TriangleVisitor__["a" /* default */]];
	},
	getClass: function () {
		return TriangleCircumcentreVisitor;
	}
});
function TriangleEdgesListVisitor() {
	this._triList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_8__extend__["a" /* default */])(TriangleEdgesListVisitor.prototype, {
	getTriangleEdges: function () {
		return this._triList;
	},
	visit: function (triEdges) {
		this._triList.add(triEdges.clone());
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_17__TriangleVisitor__["a" /* default */]];
	},
	getClass: function () {
		return TriangleEdgesListVisitor;
	}
});
function TriangleVertexListVisitor() {
	this._triList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_8__extend__["a" /* default */])(TriangleVertexListVisitor.prototype, {
	visit: function (triEdges) {
		this._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);
	},
	getTriangleVertices: function () {
		return this._triList;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_17__TriangleVisitor__["a" /* default */]];
	},
	getClass: function () {
		return TriangleVertexListVisitor;
	}
});
function TriangleCoordinatesVisitor() {
	this._coordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
	this._triCoords = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_8__extend__["a" /* default */])(TriangleCoordinatesVisitor.prototype, {
	checkTriangleSize: function (pts) {
		var loc = "";
		if (pts.length >= 2) loc = __WEBPACK_IMPORTED_MODULE_3__io_WKTWriter__["a" /* default */].toLineString(pts[0], pts[1]); else {
			if (pts.length >= 1) loc = __WEBPACK_IMPORTED_MODULE_3__io_WKTWriter__["a" /* default */].toPoint(pts[0]);
		}
	},
	visit: function (triEdges) {
		this._coordList.clear();
		for (var i = 0; i < 3; i++) {
			var v = triEdges[i].orig();
			this._coordList.add(v.getCoordinate());
		}
		if (this._coordList.size() > 0) {
			this._coordList.closeRing();
			var pts = this._coordList.toCoordinateArray();
			if (pts.length !== 4) {
				return null;
			}
			this._triCoords.add(pts);
		}
	},
	getTriangles: function () {
		return this._triCoords;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_17__TriangleVisitor__["a" /* default */]];
	},
	getClass: function () {
		return TriangleCoordinatesVisitor;
	}
});
QuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;
QuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;
QuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;
QuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;
QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DelaunayTriangulationBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__IncrementalDelaunayTriangulator__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__quadedge_QuadEdgeSubdivision__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__quadedge_Vertex__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geom_Envelope__ = __webpack_require__(7);












function DelaunayTriangulationBuilder() {
	this._siteCoords = null;
	this._tolerance = 0.0;
	this._subdiv = null;
}
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(DelaunayTriangulationBuilder.prototype, {
	create: function () {
		if (this._subdiv !== null) return null;
		var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);
		var vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);
		this._subdiv = new __WEBPACK_IMPORTED_MODULE_6__quadedge_QuadEdgeSubdivision__["a" /* default */](siteEnv, this._tolerance);
		var triangulator = new __WEBPACK_IMPORTED_MODULE_5__IncrementalDelaunayTriangulator__["a" /* default */](this._subdiv);
		triangulator.insertSites(vertices);
	},
	setTolerance: function (tolerance) {
		this._tolerance = tolerance;
	},
	setSites: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);
		} else if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_4__java_util_Collection__["a" /* default */])) {
			let coords = arguments[0];
			this._siteCoords = DelaunayTriangulationBuilder.unique(__WEBPACK_IMPORTED_MODULE_9__geom_CoordinateArrays__["a" /* default */].toCoordinateArray(coords));
		}
	},
	getEdges: function (geomFact) {
		this.create();
		return this._subdiv.getEdges(geomFact);
	},
	getSubdivision: function () {
		this.create();
		return this._subdiv;
	},
	getTriangles: function (geomFact) {
		this.create();
		return this._subdiv.getTriangles(geomFact);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DelaunayTriangulationBuilder;
	}
});
DelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {
	if (geom === null) return new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */]();
	var coords = geom.getCoordinates();
	return DelaunayTriangulationBuilder.unique(coords);
};
DelaunayTriangulationBuilder.envelope = function (coords) {
	var env = new __WEBPACK_IMPORTED_MODULE_11__geom_Envelope__["a" /* default */]();
	for (var i = coords.iterator(); i.hasNext(); ) {
		var coord = i.next();
		env.expandToInclude(coord);
	}
	return env;
};
DelaunayTriangulationBuilder.unique = function (coords) {
	var coordsCopy = __WEBPACK_IMPORTED_MODULE_9__geom_CoordinateArrays__["a" /* default */].copyDeep(coords);
	__WEBPACK_IMPORTED_MODULE_2__java_util_Arrays__["a" /* default */].sort(coordsCopy);
	var coordList = new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */](coordsCopy, false);
	return coordList;
};
DelaunayTriangulationBuilder.toVertices = function (coords) {
	var verts = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	for (var i = coords.iterator(); i.hasNext(); ) {
		var coord = i.next();
		verts.add(new __WEBPACK_IMPORTED_MODULE_8__quadedge_Vertex__["a" /* default */](coord));
	}
	return verts;
};


/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = L;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(183);
var isArguments = __webpack_require__(184);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var rbush = __webpack_require__(185);
var meta = __webpack_require__(187);
var featureEach = meta.featureEach;
var coordEach = meta.coordEach;

/**
 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
 *
 * @name rbush
 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
 * @returns {RBush} GeoJSON RBush
 * @example
 * var rbush = require('geojson-rbush')
 * var tree = rbush()
 */
module.exports = function (maxEntries) {
    var tree = rbush(maxEntries);
    /**
     * [insert](https://github.com/mourner/rbush#data-format)
     *
     * @param {Feature<any>} feature insert single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.insert(polygon)
     */
    tree.insert = function (feature) {
        if (Array.isArray(feature)) {
            var bbox = feature;
            feature = bboxPolygon(bbox);
            feature.bbox = bbox;
        } else {
            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        }
        return rbush.prototype.insert.call(this, feature);
    };

    /**
     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
     *
     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polygons = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Polygon",
     *         "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Polygon",
     *         "coordinates": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
     *       }
     *     }
     *   ]
     * }
     * tree.load(polygons)
     */
    tree.load = function (features) {
        var load = [];
        // Load an Array of BBox
        if (Array.isArray(features)) {
            features.forEach(function (bbox) {
                var feature = bboxPolygon(bbox);
                feature.bbox = bbox;
                load.push(feature);
            });
        } else {
            // Load FeatureCollection
            featureEach(features, function (feature) {
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        }
        return rbush.prototype.load.call(this, load);
    };

    /**
     * [remove](https://github.com/mourner/rbush#removing-data)
     *
     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.remove(polygon)
     */
    tree.remove = function (feature) {
        if (Array.isArray(feature)) {
            var bbox = feature;
            feature = bboxPolygon(bbox);
            feature.bbox = bbox;
        }
        return rbush.prototype.remove.call(this, feature);
    };

    /**
     * [clear](https://github.com/mourner/rbush#removing-data)
     *
     * @returns {RBush} GeoJSON Rbush
     * @example
     * tree.clear()
     */
    tree.clear = function () {
        return rbush.prototype.clear.call(this);
    };

    /**
     * [search](https://github.com/mourner/rbush#search)
     *
     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON
     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.search(polygon)
     */
    tree.search = function (geojson) {
        var features = rbush.prototype.search.call(this, this.toBBox(geojson));
        return {
            type: 'FeatureCollection',
            features: features
        };
    };

    /**
     * [collides](https://github.com/mourner/rbush#collisions)
     *
     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON
     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.collides(polygon)
     */
    tree.collides = function (geojson) {
        return rbush.prototype.collides.call(this, this.toBBox(geojson));
    };

    /**
     * [all](https://github.com/mourner/rbush#search)
     *
     * @returns {FeatureCollection<any>} all the features in RBush
     * @example
     * tree.all()
     * //=FeatureCollection
     */
    tree.all = function () {
        var features = rbush.prototype.all.call(this);
        return {
            type: 'FeatureCollection',
            features: features
        };
    };

    /**
     * [toJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @returns {any} export data as JSON object
     * @example
     * var exported = tree.toJSON()
     * //=JSON object
     */
    tree.toJSON = function () {
        return rbush.prototype.toJSON.call(this);
    };

    /**
     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @param {any} json import previously exported data
     * @returns {RBush} GeoJSON RBush
     * @example
     * var exported = {
     *   "children": [
     *     {
     *       "type": "Feature",
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [110, 50]
     *       },
     *       "properties": {},
     *       "bbox": [110, 50, 110, 50]
     *     }
     *   ],
     *   "height": 1,
     *   "leaf": true,
     *   "minX": 110,
     *   "minY": 50,
     *   "maxX": 110,
     *   "maxY": 50
     * }
     * tree.fromJSON(exported)
     */
    tree.fromJSON = function (json) {
        return rbush.prototype.fromJSON.call(this, json);
    };

    /**
     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
     *
     * @private
     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from
     * @returns {Object} converted to {minX, minY, maxX, maxY}
     */
    tree.toBBox = function (geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else bbox = turfBBox(geojson);

        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
};

/**
 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
 *
 * @private
 * @name bboxPolygon
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @returns {Feature<Polygon>} a Polygon representation of the bounding box
 * @example
 * var bbox = [0, 0, 10, 10];
 *
 * var poly = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [poly]
 */
function bboxPolygon(bbox) {
    var lowLeft = [bbox[0], bbox[1]];
    var topLeft = [bbox[0], bbox[3]];
    var topRight = [bbox[2], bbox[3]];
    var lowRight = [bbox[2], bbox[1]];
    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];

    return {
        type: 'Feature',
        bbox: bbox,
        properties: {},
        geometry: {
            type: 'Polygon',
            coordinates: coordinates
        }
    };
}

/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @private
 * @name bbox
 * @param {FeatureCollection|Feature<any>} geojson input features
 * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */
function turfBBox(geojson) {
    var bbox = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function (coord) {
        if (bbox[0] > coord[0]) bbox[0] = coord[0];
        if (bbox[1] > coord[1]) bbox[1] = coord[1];
        if (bbox[2] < coord[0]) bbox[2] = coord[0];
        if (bbox[3] < coord[1]) bbox[3] = coord[1];
    });
    return bbox;
}


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var helpers = __webpack_require__(188);
var getCoords = __webpack_require__(32).getCoords;
var flattenEach = __webpack_require__(189).flattenEach;
var lineString = helpers.lineString;
var featureCollection = helpers.featureCollection;

/**
 * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
 *
 * @name lineSegment
 * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString
 * @returns {FeatureCollection<LineString>} 2-vertex line segments
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 * var segments = turf.lineSegment(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, segments]
 */
module.exports = function (geojson) {
    if (!geojson) throw new Error('geojson is required');

    var results = [];
    flattenEach(geojson, function (feature) {
        lineSegment(feature, results);
    });
    return featureCollection(results);
};

/**
 * Line Segment
 *
 * @private
 * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
 * @param {Array} results push to results
 * @returns {void}
 */
function lineSegment(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    switch (geometry.type) {
    case 'Polygon':
        coords = getCoords(geometry);
        break;
    case 'LineString':
        coords = [getCoords(geometry)];
    }
    coords.forEach(function (coord) {
        var segments = createSegments(coord, geojson.properties);
        segments.forEach(function (segment) {
            segment.id = results.length;
            results.push(segment);
        });
    });
}

/**
 * Create Segments from LineString coordinates
 *
 * @private
 * @param {LineString} coords LineString coordinates
 * @param {*} properties GeoJSON properties
 * @returns {Array<Feature<LineString>>} line segments
 */
function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function (previousCoords, currentCoords) {
        var segment = lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}

/**
 * Create BBox between two coordinates (faster than @turf/bbox)
 *
 * @private
 * @param {[number, number]} coords1 Point coordinate
 * @param {[number, number]} coords2 Point coordinate
 * @returns {BBox} [west, south, east, north]
 */
function bbox(coords1, coords2) {
    var x1 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = (x1 < x2) ? x1 : x2;
    var south = (y1 < y2) ? y1 : y2;
    var east = (x1 > x2) ? x1 : x2;
    var north = (y1 > y2) ? y1 : y2;
    return [west, south, east, north];
}


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var meta = __webpack_require__(198);
var rbush = __webpack_require__(112);
var helpers = __webpack_require__(199);
var getCoords = __webpack_require__(32).getCoords;
var lineSegment = __webpack_require__(113);
var point = helpers.point;
var featureEach = meta.featureEach;
var featureCollection = helpers.featureCollection;

/**
 * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
 *
 * @name lineIntersect
 * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @returns {FeatureCollection<Point>} point(s) that intersect both
 * @example
 * var line1 = turf.lineString([[126, -11], [129, -21]]);
 * var line2 = turf.lineString([[123, -18], [131, -14]]);
 * var intersects = turf.lineIntersect(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, intersects]
 */
module.exports = function (line1, line2) {
    var unique = {};
    var results = [];

    // First, normalize geometries to features
    // Then, handle simple 2-vertex segments
    if (line1.type === 'LineString') line1 = helpers.feature(line1);
    if (line2.type === 'LineString') line2 = helpers.feature(line2);
    if (line1.type === 'Feature' &&
        line2.type === 'Feature' &&
        line1.geometry.type === 'LineString' &&
        line2.geometry.type === 'LineString' &&
        line1.geometry.coordinates.length === 2 &&
        line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) results.push(intersect);
        return featureCollection(results);
    }

    // Handles complex GeoJSON Geometries
    var tree = rbush();
    tree.load(lineSegment(line2));
    featureEach(lineSegment(line1), function (segment) {
        featureEach(tree.search(segment), function (match) {
            var intersect = intersects(segment, match);
            if (intersect) {
                // prevent duplicate points https://github.com/Turfjs/turf/issues/688
                var key = getCoords(intersect).join(',');
                if (!unique[key]) {
                    unique[key] = true;
                    results.push(intersect);
                }
            }
        });
    });
    return featureCollection(results);
};

/**
 * Find a point that intersects LineStrings with two coordinates each
 *
 * @private
 * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
 * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
 * @returns {Feature<Point>} intersecting GeoJSON Point
 */
function intersects(line1, line2) {
    var coords1 = getCoords(line1);
    var coords2 = getCoords(line2);
    if (coords1.length !== 2) {
        throw new Error('<intersects> line1 must only contain 2 coordinates');
    }
    if (coords2.length !== 2) {
        throw new Error('<intersects> line2 must only contain 2 coordinates');
    }
    var x1 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));
    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));

    if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
            return null;
        }
        return null;
    }

    var uA = numeA / denom;
    var uB = numeB / denom;

    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + (uA * (x2 - x1));
        var y = y1 + (uA * (y2 - y1));
        return point([x, y]);
    }
    return null;
}


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CGAlgorithmsDD;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_DD__ = __webpack_require__(116);



function CGAlgorithmsDD() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(CGAlgorithmsDD.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CGAlgorithmsDD;
	}
});
CGAlgorithmsDD.orientationIndex = function (p1, p2, q) {
	var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
	if (index <= 1) return index;
	var dx1 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.x).selfAdd(-p1.x);
	var dy1 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.y).selfAdd(-p1.y);
	var dx2 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q.x).selfAdd(-p2.x);
	var dy2 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q.y).selfAdd(-p2.y);
	return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
};
CGAlgorithmsDD.signOfDet2x2 = function (x1, y1, x2, y2) {
	var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
	return det.signum();
};
CGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {
	var denom1 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q2.y).selfSubtract(q1.y).selfMultiply(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.x).selfSubtract(p1.x));
	var denom2 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q2.x).selfSubtract(q1.x).selfMultiply(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.y).selfSubtract(p1.y));
	var denom = denom1.subtract(denom2);
	var numx1 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q2.x).selfSubtract(q1.x).selfMultiply(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p1.y).selfSubtract(q1.y));
	var numx2 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q2.y).selfSubtract(q1.y).selfMultiply(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p1.x).selfSubtract(q1.x));
	var numx = numx1.subtract(numx2);
	var fracP = numx.selfDivide(denom).doubleValue();
	var x = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p1.x).selfAdd(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
	var numy1 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.x).selfSubtract(p1.x).selfMultiply(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p1.y).selfSubtract(q1.y));
	var numy2 = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p2.y).selfSubtract(p1.y).selfMultiply(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(p1.x).selfSubtract(q1.x));
	var numy = numy1.subtract(numy2);
	var fracQ = numy.selfDivide(denom).doubleValue();
	var y = __WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q1.y).selfAdd(__WEBPACK_IMPORTED_MODULE_2__math_DD__["a" /* default */].valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
	return new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](x, y);
};
CGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {
	var detsum = null;
	var detleft = (pa.x - pc.x) * (pb.y - pc.y);
	var detright = (pa.y - pc.y) * (pb.x - pc.x);
	var det = detleft - detright;
	if (detleft > 0.0) {
		if (detright <= 0.0) {
			return CGAlgorithmsDD.signum(det);
		} else {
			detsum = detleft + detright;
		}
	} else if (detleft < 0.0) {
		if (detright >= 0.0) {
			return CGAlgorithmsDD.signum(det);
		} else {
			detsum = -detleft - detright;
		}
	} else {
		return CGAlgorithmsDD.signum(det);
	}
	var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
	if (det >= errbound || -det >= errbound) {
		return CGAlgorithmsDD.signum(det);
	}
	return 2;
};
CGAlgorithmsDD.signum = function (x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
	return 0;
};
CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DD;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Integer__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_Character__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_Cloneable__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__ = __webpack_require__(21);








function DD() {
	this._hi = 0.0;
	this._lo = 0.0;
	if (arguments.length === 0) {
		this.init(0.0);
	} else if (arguments.length === 1) {
		if (typeof arguments[0] === "number") {
			let x = arguments[0];
			this.init(x);
		} else if (arguments[0] instanceof DD) {
			let dd = arguments[0];
			this.init(dd);
		} else if (typeof arguments[0] === "string") {
			let str = arguments[0];
			DD.call(this, DD.parse(str));
		}
	} else if (arguments.length === 2) {
		let hi = arguments[0], lo = arguments[1];
		this.init(hi, lo);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(DD.prototype, {
	le: function (y) {
		return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;
	},
	extractSignificantDigits: function (insertDecimalPoint, magnitude) {
		var y = this.abs();
		var mag = DD.magnitude(y._hi);
		var scale = DD.TEN.pow(mag);
		y = y.divide(scale);
		if (y.gt(DD.TEN)) {
			y = y.divide(DD.TEN);
			mag += 1;
		} else if (y.lt(DD.ONE)) {
			y = y.multiply(DD.TEN);
			mag -= 1;
		}
		var decimalPointPos = mag + 1;
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		var numDigits = DD.MAX_PRINT_DIGITS - 1;
		for (var i = 0; i <= numDigits; i++) {
			if (insertDecimalPoint && i === decimalPointPos) {
				buf.append('.');
			}
			var digit = Math.trunc(y._hi);
			if (digit < 0 || digit > 9) {}
			if (digit < 0) {
				break;
			}
			var rebiasBy10 = false;
			var digitChar = 0;
			if (digit > 9) {
				rebiasBy10 = true;
				digitChar = '9';
			} else {
				digitChar = '0' + digit;
			}
			buf.append(digitChar);
			y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
			if (rebiasBy10) y.selfAdd(DD.TEN);
			var continueExtractingDigits = true;
			var remMag = DD.magnitude(y._hi);
			if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
			if (!continueExtractingDigits) break;
		}
		magnitude[0] = mag;
		return buf.toString();
	},
	sqr: function () {
		return this.multiply(this);
	},
	doubleValue: function () {
		return this._hi + this._lo;
	},
	subtract: function () {
		if (arguments[0] instanceof DD) {
			let y = arguments[0];
			return this.add(y.negate());
		} else if (typeof arguments[0] === "number") {
			let y = arguments[0];
			return this.add(-y);
		}
	},
	equals: function () {
		if (arguments.length === 1) {
			let y = arguments[0];
			return this._hi === y._hi && this._lo === y._lo;
		}
	},
	isZero: function () {
		return this._hi === 0.0 && this._lo === 0.0;
	},
	selfSubtract: function () {
		if (arguments[0] instanceof DD) {
			let y = arguments[0];
			if (this.isNaN()) return this;
			return this.selfAdd(-y._hi, -y._lo);
		} else if (typeof arguments[0] === "number") {
			let y = arguments[0];
			if (this.isNaN()) return this;
			return this.selfAdd(-y, 0.0);
		}
	},
	getSpecialNumberString: function () {
		if (this.isZero()) return "0.0";
		if (this.isNaN()) return "NaN ";
		return null;
	},
	min: function (x) {
		if (this.le(x)) {
			return this;
		} else {
			return x;
		}
	},
	selfDivide: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				let y = arguments[0];
				return this.selfDivide(y._hi, y._lo);
			} else if (typeof arguments[0] === "number") {
				let y = arguments[0];
				return this.selfDivide(y, 0.0);
			}
		} else if (arguments.length === 2) {
			let yhi = arguments[0], ylo = arguments[1];
			var hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
			C = this._hi / yhi;
			c = DD.SPLIT * C;
			hc = c - C;
			u = DD.SPLIT * yhi;
			hc = c - hc;
			tc = C - hc;
			hy = u - yhi;
			U = C * yhi;
			hy = u - hy;
			ty = yhi - hy;
			u = hc * hy - U + hc * ty + tc * hy + tc * ty;
			c = (this._hi - U - u + this._lo - C * ylo) / yhi;
			u = C + c;
			this._hi = u;
			this._lo = C - u + c;
			return this;
		}
	},
	dump: function () {
		return "DD<" + this._hi + ", " + this._lo + ">";
	},
	divide: function () {
		if (arguments[0] instanceof DD) {
			let y = arguments[0];
			var hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
			C = this._hi / y._hi;
			c = DD.SPLIT * C;
			hc = c - C;
			u = DD.SPLIT * y._hi;
			hc = c - hc;
			tc = C - hc;
			hy = u - y._hi;
			U = C * y._hi;
			hy = u - hy;
			ty = y._hi - hy;
			u = hc * hy - U + hc * ty + tc * hy + tc * ty;
			c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
			u = C + c;
			var zhi = u;
			var zlo = C - u + c;
			return new DD(zhi, zlo);
		} else if (typeof arguments[0] === "number") {
			let y = arguments[0];
			if (__WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].isNaN(y)) return DD.createNaN();
			return DD.copy(this).selfDivide(y, 0.0);
		}
	},
	ge: function (y) {
		return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;
	},
	pow: function (exp) {
		if (exp === 0.0) return DD.valueOf(1.0);
		var r = new DD(this);
		var s = DD.valueOf(1.0);
		var n = Math.abs(exp);
		if (n > 1) {
			while (n > 0) {
				if (n % 2 === 1) {
					s.selfMultiply(r);
				}
				n /= 2;
				if (n > 0) r = r.sqr();
			}
		} else {
			s = r;
		}
		if (exp < 0) return s.reciprocal();
		return s;
	},
	ceil: function () {
		if (this.isNaN()) return DD.NaN;
		var fhi = Math.ceil(this._hi);
		var flo = 0.0;
		if (fhi === this._hi) {
			flo = Math.ceil(this._lo);
		}
		return new DD(fhi, flo);
	},
	compareTo: function (o) {
		var other = o;
		if (this._hi < other._hi) return -1;
		if (this._hi > other._hi) return 1;
		if (this._lo < other._lo) return -1;
		if (this._lo > other._lo) return 1;
		return 0;
	},
	rint: function () {
		if (this.isNaN()) return this;
		var plus5 = this.add(0.5);
		return plus5.floor();
	},
	setValue: function () {
		if (arguments[0] instanceof DD) {
			let value = arguments[0];
			this.init(value);
			return this;
		} else if (typeof arguments[0] === "number") {
			let value = arguments[0];
			this.init(value);
			return this;
		}
	},
	max: function (x) {
		if (this.ge(x)) {
			return this;
		} else {
			return x;
		}
	},
	sqrt: function () {
		if (this.isZero()) return DD.valueOf(0.0);
		if (this.isNegative()) {
			return DD.NaN;
		}
		var x = 1.0 / Math.sqrt(this._hi);
		var ax = this._hi * x;
		var axdd = DD.valueOf(ax);
		var diffSq = this.subtract(axdd.sqr());
		var d2 = diffSq._hi * (x * 0.5);
		return axdd.add(d2);
	},
	selfAdd: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				let y = arguments[0];
				return this.selfAdd(y._hi, y._lo);
			} else if (typeof arguments[0] === "number") {
				let y = arguments[0];
				var H = null, h = null, S = null, s = null, e = null, f = null;
				S = this._hi + y;
				e = S - this._hi;
				s = S - e;
				s = y - e + (this._hi - s);
				f = s + this._lo;
				H = S + f;
				h = f + (S - H);
				this._hi = H + h;
				this._lo = h + (H - this._hi);
				return this;
			}
		} else if (arguments.length === 2) {
			let yhi = arguments[0], ylo = arguments[1];
			var H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;
			S = this._hi + yhi;
			T = this._lo + ylo;
			e = S - this._hi;
			f = T - this._lo;
			s = S - e;
			t = T - f;
			s = yhi - e + (this._hi - s);
			t = ylo - f + (this._lo - t);
			e = s + T;
			H = S + e;
			h = e + (S - H);
			e = t + h;
			var zhi = H + e;
			var zlo = e + (H - zhi);
			this._hi = zhi;
			this._lo = zlo;
			return this;
		}
	},
	selfMultiply: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				let y = arguments[0];
				return this.selfMultiply(y._hi, y._lo);
			} else if (typeof arguments[0] === "number") {
				let y = arguments[0];
				return this.selfMultiply(y, 0.0);
			}
		} else if (arguments.length === 2) {
			let yhi = arguments[0], ylo = arguments[1];
			var hx = null, tx = null, hy = null, ty = null, C = null, c = null;
			C = DD.SPLIT * this._hi;
			hx = C - this._hi;
			c = DD.SPLIT * yhi;
			hx = C - hx;
			tx = this._hi - hx;
			hy = c - yhi;
			C = this._hi * yhi;
			hy = c - hy;
			ty = yhi - hy;
			c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
			var zhi = C + c;
			hx = C - zhi;
			var zlo = c + hx;
			this._hi = zhi;
			this._lo = zlo;
			return this;
		}
	},
	selfSqr: function () {
		return this.selfMultiply(this);
	},
	floor: function () {
		if (this.isNaN()) return DD.NaN;
		var fhi = Math.floor(this._hi);
		var flo = 0.0;
		if (fhi === this._hi) {
			flo = Math.floor(this._lo);
		}
		return new DD(fhi, flo);
	},
	negate: function () {
		if (this.isNaN()) return this;
		return new DD(-this._hi, -this._lo);
	},
	clone: function () {
		try {
			return null;
		} catch (ex) {
			if (ex instanceof CloneNotSupportedException) {
				return null;
			} else throw ex;
		} finally {}
	},
	multiply: function () {
		if (arguments[0] instanceof DD) {
			let y = arguments[0];
			if (y.isNaN()) return DD.createNaN();
			return DD.copy(this).selfMultiply(y);
		} else if (typeof arguments[0] === "number") {
			let y = arguments[0];
			if (__WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].isNaN(y)) return DD.createNaN();
			return DD.copy(this).selfMultiply(y, 0.0);
		}
	},
	isNaN: function () {
		return __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].isNaN(this._hi);
	},
	intValue: function () {
		return Math.trunc(this._hi);
	},
	toString: function () {
		var mag = DD.magnitude(this._hi);
		if (mag >= -3 && mag <= 20) return this.toStandardNotation();
		return this.toSciNotation();
	},
	toStandardNotation: function () {
		var specialStr = this.getSpecialNumberString();
		if (specialStr !== null) return specialStr;
		var magnitude = new Array(1).fill(null);
		var sigDigits = this.extractSignificantDigits(true, magnitude);
		var decimalPointPos = magnitude[0] + 1;
		var num = sigDigits;
		if (sigDigits.charAt(0) === '.') {
			num = "0" + sigDigits;
		} else if (decimalPointPos < 0) {
			num = "0." + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
		} else if (sigDigits.indexOf('.') === -1) {
			var numZeroes = decimalPointPos - sigDigits.length;
			var zeroes = DD.stringOfChar('0', numZeroes);
			num = sigDigits + zeroes + ".0";
		}
		if (this.isNegative()) return "-" + num;
		return num;
	},
	reciprocal: function () {
		var hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
		C = 1.0 / this._hi;
		c = DD.SPLIT * C;
		hc = c - C;
		u = DD.SPLIT * this._hi;
		hc = c - hc;
		tc = C - hc;
		hy = u - this._hi;
		U = C * this._hi;
		hy = u - hy;
		ty = this._hi - hy;
		u = hc * hy - U + hc * ty + tc * hy + tc * ty;
		c = (1.0 - U - u - C * this._lo) / this._hi;
		var zhi = C + c;
		var zlo = C - zhi + c;
		return new DD(zhi, zlo);
	},
	toSciNotation: function () {
		if (this.isZero()) return DD.SCI_NOT_ZERO;
		var specialStr = this.getSpecialNumberString();
		if (specialStr !== null) return specialStr;
		var magnitude = new Array(1).fill(null);
		var digits = this.extractSignificantDigits(false, magnitude);
		var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
		if (digits.charAt(0) === '0') {
			throw new IllegalStateException("Found leading zero: " + digits);
		}
		var trailingDigits = "";
		if (digits.length > 1) trailingDigits = digits.substring(1);
		var digitsWithDecimal = digits.charAt(0) + "." + trailingDigits;
		if (this.isNegative()) return "-" + digitsWithDecimal + expStr;
		return digitsWithDecimal + expStr;
	},
	abs: function () {
		if (this.isNaN()) return DD.NaN;
		if (this.isNegative()) return this.negate();
		return new DD(this);
	},
	isPositive: function () {
		return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;
	},
	lt: function (y) {
		return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;
	},
	add: function () {
		if (arguments[0] instanceof DD) {
			let y = arguments[0];
			return DD.copy(this).selfAdd(y);
		} else if (typeof arguments[0] === "number") {
			let y = arguments[0];
			return DD.copy(this).selfAdd(y);
		}
	},
	init: function () {
		if (arguments.length === 1) {
			if (typeof arguments[0] === "number") {
				let x = arguments[0];
				this._hi = x;
				this._lo = 0.0;
			} else if (arguments[0] instanceof DD) {
				let dd = arguments[0];
				this._hi = dd._hi;
				this._lo = dd._lo;
			}
		} else if (arguments.length === 2) {
			let hi = arguments[0], lo = arguments[1];
			this._hi = hi;
			this._lo = lo;
		}
	},
	gt: function (y) {
		return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;
	},
	isNegative: function () {
		return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;
	},
	trunc: function () {
		if (this.isNaN()) return DD.NaN;
		if (this.isPositive()) return this.floor(); else return this.ceil();
	},
	signum: function () {
		if (this._hi > 0) return 1;
		if (this._hi < 0) return -1;
		if (this._lo > 0) return 1;
		if (this._lo < 0) return -1;
		return 0;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__java_lang_Comparable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_6__java_lang_Cloneable__["a" /* default */]];
	},
	getClass: function () {
		return DD;
	}
});
DD.sqr = function (x) {
	return DD.valueOf(x).selfMultiply(x);
};
DD.valueOf = function () {
	if (typeof arguments[0] === "string") {
		let str = arguments[0];
		return DD.parse(str);
	} else if (typeof arguments[0] === "number") {
		let x = arguments[0];
		return new DD(x);
	}
};
DD.sqrt = function (x) {
	return DD.valueOf(x).sqrt();
};
DD.parse = function (str) {
	var i = 0;
	var strlen = str.length;
	while (__WEBPACK_IMPORTED_MODULE_4__java_lang_Character__["a" /* default */].isWhitespace(str.charAt(i))) i++;
	var isNegative = false;
	if (i < strlen) {
		var signCh = str.charAt(i);
		if (signCh === '-' || signCh === '+') {
			i++;
			if (signCh === '-') isNegative = true;
		}
	}
	var val = new DD();
	var numDigits = 0;
	var numBeforeDec = 0;
	var exp = 0;
	while (true) {
		if (i >= strlen) break;
		var ch = str.charAt(i);
		i++;
		if (__WEBPACK_IMPORTED_MODULE_4__java_lang_Character__["a" /* default */].isDigit(ch)) {
			var d = ch - '0';
			val.selfMultiply(DD.TEN);
			val.selfAdd(d);
			numDigits++;
			continue;
		}
		if (ch === '.') {
			numBeforeDec = numDigits;
			continue;
		}
		if (ch === 'e' || ch === 'E') {
			var expStr = str.substring(i);
			try {
				exp = __WEBPACK_IMPORTED_MODULE_3__java_lang_Integer__["a" /* default */].parseInt(expStr);
			} catch (ex) {
				if (ex instanceof NumberFormatException) {
					throw new NumberFormatException("Invalid exponent " + expStr + " in string " + str);
				} else throw ex;
			} finally {}
			break;
		}
		throw new NumberFormatException("Unexpected character '" + ch + "' at position " + i + " in string " + str);
	}
	var val2 = val;
	var numDecPlaces = numDigits - numBeforeDec - exp;
	if (numDecPlaces === 0) {
		val2 = val;
	} else if (numDecPlaces > 0) {
		var scale = DD.TEN.pow(numDecPlaces);
		val2 = val.divide(scale);
	} else if (numDecPlaces < 0) {
		var scale = DD.TEN.pow(-numDecPlaces);
		val2 = val.multiply(scale);
	}
	if (isNegative) {
		return val2.negate();
	}
	return val2;
};
DD.createNaN = function () {
	return new DD(__WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].NaN, __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].NaN);
};
DD.copy = function (dd) {
	return new DD(dd);
};
DD.magnitude = function (x) {
	var xAbs = Math.abs(x);
	var xLog10 = Math.log(xAbs) / Math.log(10);
	var xMag = Math.trunc(Math.floor(xLog10));
	var xApprox = Math.pow(10, xMag);
	if (xApprox * 10 <= xAbs) xMag += 1;
	return xMag;
};
DD.stringOfChar = function (ch, len) {
	var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
	for (var i = 0; i < len; i++) {
		buf.append(ch);
	}
	return buf.toString();
};
DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);
DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);
DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);
DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);
DD.NaN = new DD(__WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].NaN, __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].NaN);
DD.EPS = 1.23259516440783e-32;
DD.SPLIT = 134217729.0;
DD.MAX_PRINT_DIGITS = 32;
DD.TEN = DD.valueOf(10.0);
DD.ONE = DD.valueOf(1.0);
DD.SCI_NOT_EXPONENT_CHAR = "E";
DD.SCI_NOT_ZERO = "0.0E0";


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Character;
function Character () {}
Character.isWhitespace = c => ((c <= 32 && c >= 0) || c == 127)
Character.toUpperCase = c => c.toUpperCase()


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = WKTParser;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);




const regExes = {
  'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
  'spaces': /\s+/,
  'parenComma': /\)\s*,\s*\(/,
  'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
  'trimParens': /^\s*\(?(.*?)\)?\s*$/
}

/**
 * Class for reading and writing Well-Known Text.
 *
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/** Create a new parser for WKT
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of WKTParser.
 * @constructor
 * @private
 */
function WKTParser (geometryFactory) {
  this.geometryFactory = geometryFactory || new __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__["a" /* default */]()
}

Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(WKTParser.prototype, {
  /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */
  read (wkt) {
    var geometry, type, str
    wkt = wkt.replace(/[\n\r]/g, ' ')
    var matches = regExes.typeStr.exec(wkt)
    if (wkt.search('EMPTY') !== -1) {
      matches = regExes.emptyTypeStr.exec(wkt)
      matches[2] = undefined
    }
    if (matches) {
      type = matches[1].toLowerCase()
      str = matches[2]
      if (parse[type]) {
        geometry = parse[type].apply(this, [str])
      }
    }

    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)

    return geometry
  },

  /**
   * Serialize a geometry into a WKT string.
   *
   * @param {Geometry} geometry A feature or array of features.
   * @return {String} The WKT string representation of the input geometries.
   * @private
   */
  write (geometry) {
    return this.extractGeometry(geometry)
  },

  /**
   * Entry point to construct the WKT for a single Geometry object.
   *
   * @param {Geometry} geometry
   * @return {String} A WKT string of representing the geometry.
   * @private
   */
  extractGeometry (geometry) {
    var type = geometry.getGeometryType().toLowerCase()
    if (!extract[type]) {
      return null
    }
    var wktType = type.toUpperCase()
    var data
    if (geometry.isEmpty()) {
      data = wktType + ' EMPTY'
    } else {
      data = wktType + '(' + extract[type].apply(this, [geometry]) + ')'
    }
    return data
  }
})

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual data extraction.
 * @private
 */
const extract = {
  coordinate (coordinate) {
    return coordinate.x + ' ' + coordinate.y
  },

  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point (point) {
    return extract.coordinate.call(this, point._coordinates._coordinates[0])
  },

  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint (multipoint) {
    var array = []
    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {
      array.push('(' + extract.point.apply(this, [multipoint._geometries[i]]) + ')')
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring (linestring) {
    var array = []
    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {
      array.push(extract.coordinate.apply(this, [linestring._points._coordinates[i]]))
    }
    return array.join(',')
  },

  linearring (linearring) {
    var array = []
    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {
      array.push(extract.coordinate.apply(this, [linearring._points._coordinates[i]]))
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring (multilinestring) {
    var array = []
    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {
      array.push('(' +
        extract.linestring.apply(this, [multilinestring._geometries[i]]) +
        ')')
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon (polygon) {
    var array = []
    array.push('(' + extract.linestring.apply(this, [polygon._shell]) + ')')
    for (let i = 0, len = polygon._holes.length; i < len; ++i) {
      array.push('(' + extract.linestring.apply(this, [polygon._holes[i]]) + ')')
    }
    return array.join(',')
  },

  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon (multipolygon) {
    var array = []
    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {
      array.push('(' + extract.polygon.apply(this, [multipolygon._geometries[i]]) + ')')
    }
    return array.join(',')
  },

  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection (collection) {
    var array = []
    for (let i = 0, len = collection._geometries.length; i < len; ++i) {
      array.push(this.extractGeometry(collection._geometries[i]))
    }
    return array.join(',')
  }
}

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual parsing.
 * @private
 */
const parse = {
  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point (str) {
    if (str === undefined) {
      return this.geometryFactory.createPoint()
    }

    var coords = str.trim().split(regExes.spaces)
    return this.geometryFactory.createPoint(new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](Number.parseFloat(coords[0]),
      Number.parseFloat(coords[1])))
  },

  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPoint()
    }

    var point
    var points = str.trim().split(',')
    var components = []
    for (let i = 0, len = points.length; i < len; ++i) {
      point = points[i].replace(regExes.trimParens, '$1')
      components.push(parse.point.apply(this, [point]))
    }
    return this.geometryFactory.createMultiPoint(components)
  },

  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring (str) {
    if (str === undefined) {
      return this.geometryFactory.createLineString()
    }

    var points = str.trim().split(',')
    var components = []
    var coords
    for (let i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(regExes.spaces)
      components.push(new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](Number.parseFloat(coords[0]), Number.parseFloat(coords[1])))
    }
    return this.geometryFactory.createLineString(components)
  },

  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring (str) {
    if (str === undefined) {
      return this.geometryFactory.createLinearRing()
    }

    var points = str.trim().split(',')
    var components = []
    var coords
    for (let i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(regExes.spaces)
      components.push(new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](Number.parseFloat(coords[0]), Number.parseFloat(coords[1])))
    }
    return this.geometryFactory.createLinearRing(components)
  },

  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiLineString()
    }

    var line
    var lines = str.trim().split(regExes.parenComma)
    var components = []
    for (let i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(regExes.trimParens, '$1')
      components.push(parse.linestring.apply(this, [line]))
    }
    return this.geometryFactory.createMultiLineString(components)
  },

  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon (str) {
    if (str === undefined) {
      return this.geometryFactory.createPolygon()
    }

    var ring, linestring, linearring
    var rings = str.trim().split(regExes.parenComma)
    var shell
    var holes = []
    for (let i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(regExes.trimParens, '$1')
      linestring = parse.linestring.apply(this, [ring])
      linearring = this.geometryFactory.createLinearRing(linestring._points)
      if (i === 0) {
        shell = linearring
      } else {
        holes.push(linearring)
      }
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPolygon()
    }

    var polygon
    var polygons = str.trim().split(regExes.doubleParenComma)
    var components = []
    for (let i = 0, len = polygons.length; i < len; ++i) {
      polygon = polygons[i].replace(regExes.trimParens, '$1')
      components.push(parse.polygon.apply(this, [polygon]))
    }
    return this.geometryFactory.createMultiPolygon(components)
  },

  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection (str) {
    if (str === undefined) {
      return this.geometryFactory.createGeometryCollection()
    }

    // separate components of the collection with |
    str = str.replace(/,\s*([A-Za-z])/g, '|$1')
    var wktArray = str.trim().split('|')
    var components = []
    for (let i = 0, len = wktArray.length; i < len; ++i) {
      components.push(this.read(wktArray[i]))
    }
    return this.geometryFactory.createGeometryCollection(components)
  }
}


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateSequenceFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CoordinateSequence__ = __webpack_require__(37);



function CoordinateSequenceFactory() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(CoordinateSequenceFactory.prototype, {
	create: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				let coordinates = arguments[0];
			} else if (Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_2__CoordinateSequence__["a" /* default */])) {
				let coordSeq = arguments[0];
			}
		} else if (arguments.length === 2) {
			let size = arguments[0], dimension = arguments[1];
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CoordinateSequenceFactory;
	}
});


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Map;
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 *
 * @constructor
 * @private
 */
function Map() {};


/**
 * Returns the value to which the specified key is mapped, or null if this map
 * contains no mapping for the key.
 * @param {Object} key
 * @return {Object}
 */
Map.prototype.get = function() {};


/**
 * Associates the specified value with the specified key in this map (optional
 * operation).
 * @param {Object} key
 * @param {Object} value
 * @return {Object}
 */
Map.prototype.put = function() {};


/**
 * Returns the number of key-value mappings in this map.
 * @return {number}
 */
Map.prototype.size = function() {};


/**
 * Returns a Collection view of the values contained in this map.
 * @return {javascript.util.Collection}
 */
Map.prototype.values = function() {};

/**
 * Returns a {@link Set} view of the mappings contained in this map.
 * The set is backed by the map, so changes to the map are
 * reflected in the set, and vice-versa.  If the map is modified
 * while an iteration over the set is in progress (except through
 * the iterator's own <tt>remove</tt> operation, or through the
 * <tt>setValue</tt> operation on a map entry returned by the
 * iterator) the results of the iteration are undefined.  The set
 * supports element removal, which removes the corresponding
 * mapping from the map, via the <tt>Iterator.remove</tt>,
 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
 * <tt>clear</tt> operations.  It does not support the
 * <tt>add</tt> or <tt>addAll</tt> operations.
 *
 * @return {Set} a set view of the mappings contained in this map
 */
Map.prototype.entrySet = function() {};


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Set;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Collection__ = __webpack_require__(24);


/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
 *
 * @extends {Collection}
 * @constructor
 * @private
 */
function Set() {};
Set.prototype = new __WEBPACK_IMPORTED_MODULE_0__Collection__["a" /* default */]();


/**
 * Returns true if this set contains the specified element. More formally,
 * returns true if and only if this set contains an element e such that (o==null ?
 * e==null : o.equals(e)).
 * @param {Object} e
 * @return {boolean}
 */
Set.prototype.contains = function() {};


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Puntal;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Puntal() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Puntal.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Puntal;
	}
});


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RayCrossingCounter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_CoordinateSequence__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__RobustDeterminant__ = __webpack_require__(124);






function RayCrossingCounter() {
	this._p = null;
	this._crossingCount = 0;
	this._isPointOnSegment = false;
	let p = arguments[0];
	this._p = p;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(RayCrossingCounter.prototype, {
	countSegment: function (p1, p2) {
		if (p1.x < this._p.x && p2.x < this._p.x) return null;
		if (this._p.x === p2.x && this._p.y === p2.y) {
			this._isPointOnSegment = true;
			return null;
		}
		if (p1.y === this._p.y && p2.y === this._p.y) {
			var minx = p1.x;
			var maxx = p2.x;
			if (minx > maxx) {
				minx = p2.x;
				maxx = p1.x;
			}
			if (this._p.x >= minx && this._p.x <= maxx) {
				this._isPointOnSegment = true;
			}
			return null;
		}
		if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
			var x1 = p1.x - this._p.x;
			var y1 = p1.y - this._p.y;
			var x2 = p2.x - this._p.x;
			var y2 = p2.y - this._p.y;
			var xIntSign = __WEBPACK_IMPORTED_MODULE_5__RobustDeterminant__["a" /* default */].signOfDet2x2(x1, y1, x2, y2);
			if (xIntSign === 0.0) {
				this._isPointOnSegment = true;
				return null;
			}
			if (y2 < y1) xIntSign = -xIntSign;
			if (xIntSign > 0.0) {
				this._crossingCount++;
			}
		}
	},
	isPointInPolygon: function () {
		return this.getLocation() !== __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
	},
	getLocation: function () {
		if (this._isPointOnSegment) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY;
		if (this._crossingCount % 2 === 1) {
			return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
		}
		return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
	},
	isOnSegment: function () {
		return this._isPointOnSegment;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RayCrossingCounter;
	}
});
RayCrossingCounter.locatePointInRing = function () {
	if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */] && Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_4__geom_CoordinateSequence__["a" /* default */])) {
		let p = arguments[0], ring = arguments[1];
		var counter = new RayCrossingCounter(p);
		var p1 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
		var p2 = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
		for (var i = 1; i < ring.size(); i++) {
			ring.getCoordinate(i, p1);
			ring.getCoordinate(i - 1, p2);
			counter.countSegment(p1, p2);
			if (counter.isOnSegment()) return counter.getLocation();
		}
		return counter.getLocation();
	} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */] && arguments[1] instanceof Array) {
		let p = arguments[0], ring = arguments[1];
		var counter = new RayCrossingCounter(p);
		for (var i = 1; i < ring.length; i++) {
			var p1 = ring[i];
			var p2 = ring[i - 1];
			counter.countSegment(p1, p2);
			if (counter.isOnSegment()) return counter.getLocation();
		}
		return counter.getLocation();
	}
};


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RobustDeterminant;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function RobustDeterminant() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(RobustDeterminant.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RobustDeterminant;
	}
});
RobustDeterminant.orientationIndex = function (p1, p2, q) {
	var dx1 = p2.x - p1.x;
	var dy1 = p2.y - p1.y;
	var dx2 = q.x - p2.x;
	var dy2 = q.y - p2.y;
	return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
};
RobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {
	var sign = null;
	var swap = null;
	var k = null;
	var count = 0;
	sign = 1;
	if (x1 === 0.0 || y2 === 0.0) {
		if (y1 === 0.0 || x2 === 0.0) {
			return 0;
		} else if (y1 > 0) {
			if (x2 > 0) {
				return -sign;
			} else {
				return sign;
			}
		} else {
			if (x2 > 0) {
				return sign;
			} else {
				return -sign;
			}
		}
	}
	if (y1 === 0.0 || x2 === 0.0) {
		if (y2 > 0) {
			if (x1 > 0) {
				return sign;
			} else {
				return -sign;
			}
		} else {
			if (x1 > 0) {
				return -sign;
			} else {
				return sign;
			}
		}
	}
	if (0.0 < y1) {
		if (0.0 < y2) {
			if (y1 <= y2) {
				;
			} else {
				sign = -sign;
				swap = x1;
				x1 = x2;
				x2 = swap;
				swap = y1;
				y1 = y2;
				y2 = swap;
			}
		} else {
			if (y1 <= -y2) {
				sign = -sign;
				x2 = -x2;
				y2 = -y2;
			} else {
				swap = x1;
				x1 = -x2;
				x2 = swap;
				swap = y1;
				y1 = -y2;
				y2 = swap;
			}
		}
	} else {
		if (0.0 < y2) {
			if (-y1 <= y2) {
				sign = -sign;
				x1 = -x1;
				y1 = -y1;
			} else {
				swap = -x1;
				x1 = x2;
				x2 = swap;
				swap = -y1;
				y1 = y2;
				y2 = swap;
			}
		} else {
			if (y1 >= y2) {
				x1 = -x1;
				y1 = -y1;
				x2 = -x2;
				y2 = -y2;
				;
			} else {
				sign = -sign;
				swap = -x1;
				x1 = -x2;
				x2 = swap;
				swap = -y1;
				y1 = -y2;
				y2 = swap;
			}
		}
	}
	if (0.0 < x1) {
		if (0.0 < x2) {
			if (x1 <= x2) {
				;
			} else {
				return sign;
			}
		} else {
			return sign;
		}
	} else {
		if (0.0 < x2) {
			return -sign;
		} else {
			if (x1 >= x2) {
				sign = -sign;
				x1 = -x1;
				x2 = -x2;
				;
			} else {
				return -sign;
			}
		}
	}
	while (true) {
		count = count + 1;
		k = Math.floor(x2 / x1);
		x2 = x2 - k * x1;
		y2 = y2 - k * y1;
		if (y2 < 0.0) {
			return -sign;
		}
		if (y2 > y1) {
			return sign;
		}
		if (x1 > x2 + x2) {
			if (y1 < y2 + y2) {
				return sign;
			}
		} else {
			if (y1 > y2 + y2) {
				return -sign;
			} else {
				x2 = x1 - x2;
				y2 = y1 - y2;
				sign = -sign;
			}
		}
		if (y2 === 0.0) {
			if (x2 === 0.0) {
				return 0;
			} else {
				return -sign;
			}
		}
		if (x2 === 0.0) {
			return sign;
		}
		k = Math.floor(x1 / x2);
		x1 = x1 - k * x2;
		y1 = y1 - k * y2;
		if (y1 < 0.0) {
			return sign;
		}
		if (y1 > y2) {
			return -sign;
		}
		if (x2 > x1 + x1) {
			if (y2 < y1 + y1) {
				return -sign;
			}
		} else {
			if (y2 > y1 + y1) {
				return sign;
			} else {
				x1 = x2 - x1;
				y1 = y2 - y1;
				sign = -sign;
			}
		}
		if (y1 === 0.0) {
			if (x1 === 0.0) {
				return 0;
			} else {
				return sign;
			}
		}
		if (x1 === 0.0) {
			return -sign;
		}
	}
};


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IntersectionMatrix;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_Cloneable__ = __webpack_require__(53);






function IntersectionMatrix() {
	this._matrix = null;
	if (arguments.length === 0) {
		this._matrix = Array(3).fill().map(() => Array(3));
		this.setAll(__WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE);
	} else if (arguments.length === 1) {
		if (typeof arguments[0] === "string") {
			let elements = arguments[0];
			IntersectionMatrix.call(this);
			this.set(elements);
		} else if (arguments[0] instanceof IntersectionMatrix) {
			let other = arguments[0];
			IntersectionMatrix.call(this);
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY];
			this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] = other._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR];
		}
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(IntersectionMatrix.prototype, {
	isIntersects: function () {
		return !this.isDisjoint();
	},
	isCovers: function () {
		var hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY]);
		return hasPointInCommon && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE;
	},
	isCoveredBy: function () {
		var hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY]);
		return hasPointInCommon && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE;
	},
	set: function () {
		if (arguments.length === 1) {
			let dimensionSymbols = arguments[0];
			for (var i = 0; i < dimensionSymbols.length; i++) {
				var row = Math.trunc(i / 3);
				var col = i % 3;
				this._matrix[row][col] = __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].toDimensionValue(dimensionSymbols.charAt(i));
			}
		} else if (arguments.length === 3) {
			let row = arguments[0], column = arguments[1], dimensionValue = arguments[2];
			this._matrix[row][column] = dimensionValue;
		}
	},
	isContains: function () {
		return IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE;
	},
	setAtLeast: function () {
		if (arguments.length === 1) {
			let minimumDimensionSymbols = arguments[0];
			for (var i = 0; i < minimumDimensionSymbols.length; i++) {
				var row = Math.trunc(i / 3);
				var col = i % 3;
				this.setAtLeast(row, col, __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].toDimensionValue(minimumDimensionSymbols.charAt(i)));
			}
		} else if (arguments.length === 3) {
			let row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];
			if (this._matrix[row][column] < minimumDimensionValue) {
				this._matrix[row][column] = minimumDimensionValue;
			}
		}
	},
	setAtLeastIfValid: function (row, column, minimumDimensionValue) {
		if (row >= 0 && column >= 0) {
			this.setAtLeast(row, column, minimumDimensionValue);
		}
	},
	isWithin: function () {
		return IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE;
	},
	isTouches: function (dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA > dimensionOfGeometryB) {
			return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
		}
		if (dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L) {
			return this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && (IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY]));
		}
		return false;
	},
	isOverlaps: function (dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A) {
			return IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]);
		}
		if (dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L) {
			return this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]);
		}
		return false;
	},
	isEquals: function (dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA !== dimensionOfGeometryB) {
			return false;
		}
		return IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE;
	},
	toString: function () {
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]("123456789");
		for (var ai = 0; ai < 3; ai++) {
			for (var bi = 0; bi < 3; bi++) {
				buf.setCharAt(3 * ai + bi, __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].toDimensionSymbol(this._matrix[ai][bi]));
			}
		}
		return buf.toString();
	},
	setAll: function (dimensionValue) {
		for (var ai = 0; ai < 3; ai++) {
			for (var bi = 0; bi < 3; bi++) {
				this._matrix[ai][bi] = dimensionValue;
			}
		}
	},
	get: function (row, column) {
		return this._matrix[row][column];
	},
	transpose: function () {
		var temp = this._matrix[1][0];
		this._matrix[1][0] = this._matrix[0][1];
		this._matrix[0][1] = temp;
		temp = this._matrix[2][0];
		this._matrix[2][0] = this._matrix[0][2];
		this._matrix[0][2] = temp;
		temp = this._matrix[2][1];
		this._matrix[2][1] = this._matrix[1][2];
		this._matrix[1][2] = temp;
		return this;
	},
	matches: function (requiredDimensionSymbols) {
		if (requiredDimensionSymbols.length !== 9) {
			throw new __WEBPACK_IMPORTED_MODULE_2__java_lang_IllegalArgumentException__["a" /* default */]("Should be length 9: " + requiredDimensionSymbols);
		}
		for (var ai = 0; ai < 3; ai++) {
			for (var bi = 0; bi < 3; bi++) {
				if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {
					return false;
				}
			}
		}
		return true;
	},
	add: function (im) {
		for (var i = 0; i < 3; i++) {
			for (var j = 0; j < 3; j++) {
				this.setAtLeast(i, j, im.get(i, j));
			}
		}
	},
	isDisjoint: function () {
		return this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE && this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].BOUNDARY] === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE;
	},
	isCrosses: function (dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A) {
			return IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR]);
		}
		if (dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P || dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L) {
			return IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].EXTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR]);
		}
		if (dimensionOfGeometryA === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L && dimensionOfGeometryB === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L) {
			return this._matrix[__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR][__WEBPACK_IMPORTED_MODULE_1__Location__["a" /* default */].INTERIOR] === 0;
		}
		return false;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_5__java_lang_Cloneable__["a" /* default */]];
	},
	getClass: function () {
		return IntersectionMatrix;
	}
});
IntersectionMatrix.matches = function () {
	if (Number.isInteger(arguments[0]) && typeof arguments[1] === "string") {
		let actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];
		if (requiredDimensionSymbol === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].SYM_DONTCARE) {
			return true;
		}
		if (requiredDimensionSymbol === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].TRUE)) {
			return true;
		}
		if (requiredDimensionSymbol === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].SYM_FALSE && actualDimensionValue === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].FALSE) {
			return true;
		}
		if (requiredDimensionSymbol === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].SYM_P && actualDimensionValue === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].P) {
			return true;
		}
		if (requiredDimensionSymbol === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].SYM_L && actualDimensionValue === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].L) {
			return true;
		}
		if (requiredDimensionSymbol === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].SYM_A && actualDimensionValue === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].A) {
			return true;
		}
		return false;
	} else if (typeof arguments[0] === "string" && typeof arguments[1] === "string") {
		let actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];
		var m = new IntersectionMatrix(actualDimensionSymbols);
		return m.matches(requiredDimensionSymbols);
	}
};
IntersectionMatrix.isTrue = function (actualDimensionValue) {
	if (actualDimensionValue >= 0 || actualDimensionValue === __WEBPACK_IMPORTED_MODULE_4__Dimension__["a" /* default */].TRUE) {
		return true;
	}
	return false;
};


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryCollectionIterator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_Iterator__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_NoSuchElementException__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__GeometryCollection__ = __webpack_require__(13);




function GeometryCollectionIterator() {
	this._parent = null;
	this._atStart = null;
	this._max = null;
	this._index = null;
	this._subcollectionIterator = null;
	let parent = arguments[0];
	this._parent = parent;
	this._atStart = true;
	this._index = 0;
	this._max = parent.getNumGeometries();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(GeometryCollectionIterator.prototype, {
	next: function () {
		if (this._atStart) {
			this._atStart = false;
			if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
			return this._parent;
		}
		if (this._subcollectionIterator !== null) {
			if (this._subcollectionIterator.hasNext()) {
				return this._subcollectionIterator.next();
			} else {
				this._subcollectionIterator = null;
			}
		}
		if (this._index >= this._max) {
			throw new __WEBPACK_IMPORTED_MODULE_1__java_util_NoSuchElementException__["a" /* default */]();
		}
		var obj = this._parent.getGeometryN(this._index++);
		if (obj instanceof __WEBPACK_IMPORTED_MODULE_3__GeometryCollection__["a" /* default */]) {
			this._subcollectionIterator = new GeometryCollectionIterator(obj);
			return this._subcollectionIterator.next();
		}
		return obj;
	},
	remove: function () {
		throw new UnsupportedOperationException(this.getClass().getName());
	},
	hasNext: function () {
		if (this._atStart) {
			return true;
		}
		if (this._subcollectionIterator !== null) {
			if (this._subcollectionIterator.hasNext()) {
				return true;
			}
			this._subcollectionIterator = null;
		}
		if (this._index >= this._max) {
			return false;
		}
		return true;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_0__java_util_Iterator__["a" /* default */]];
	},
	getClass: function () {
		return GeometryCollectionIterator;
	}
});
GeometryCollectionIterator.isAtomic = function (geom) {
	return !(geom instanceof __WEBPACK_IMPORTED_MODULE_3__GeometryCollection__["a" /* default */]);
};


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Octant;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);



function Octant() {}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Octant.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Octant;
	}
});
Octant.octant = function () {
	if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
		let dx = arguments[0], dy = arguments[1];
		if (dx === 0.0 && dy === 0.0) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Cannot compute the octant for point ( " + dx + ", " + dy + " )");
		var adx = Math.abs(dx);
		var ady = Math.abs(dy);
		if (dx >= 0) {
			if (dy >= 0) {
				if (adx >= ady) return 0; else return 1;
			} else {
				if (adx >= ady) return 7; else return 6;
			}
		} else {
			if (dy >= 0) {
				if (adx >= ady) return 3; else return 2;
			} else {
				if (adx >= ady) return 4; else return 5;
			}
		}
	} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]) {
		let p0 = arguments[0], p1 = arguments[1];
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		if (dx === 0.0 && dy === 0.0) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Cannot compute the octant for two identical points " + p0);
		return Octant.octant(dx, dy);
	}
};


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ItemBoundable;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Boundable__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_io_Serializable__ = __webpack_require__(21);



function ItemBoundable() {
	this._bounds = null;
	this._item = null;
	let bounds = arguments[0], item = arguments[1];
	this._bounds = bounds;
	this._item = item;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(ItemBoundable.prototype, {
	getItem: function () {
		return this._item;
	},
	getBounds: function () {
		return this._bounds;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_0__Boundable__["a" /* default */], __WEBPACK_IMPORTED_MODULE_2__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return ItemBoundable;
	}
});


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Boundable;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function Boundable() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(Boundable.prototype, {
	getBounds: function () {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Boundable;
	}
});


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SpatialIndex;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function SpatialIndex() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(SpatialIndex.prototype, {
	insert: function (itemEnv, item) {},
	remove: function (itemEnv, item) {},
	query: function () {
		if (arguments.length === 1) {
			let searchEnv = arguments[0];
		} else if (arguments.length === 2) {
			let searchEnv = arguments[0], visitor = arguments[1];
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SpatialIndex;
	}
});


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChainBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MonotoneChain__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Integer__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geomgraph_Quadrant__ = __webpack_require__(47);





function MonotoneChainBuilder() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(MonotoneChainBuilder.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChainBuilder;
	}
});
MonotoneChainBuilder.getChainStartIndices = function (pts) {
	var start = 0;
	var startIndexList = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
	startIndexList.add(new __WEBPACK_IMPORTED_MODULE_2__java_lang_Integer__["a" /* default */](start));
	do {
		var last = MonotoneChainBuilder.findChainEnd(pts, start);
		startIndexList.add(new __WEBPACK_IMPORTED_MODULE_2__java_lang_Integer__["a" /* default */](last));
		start = last;
	} while (start < pts.length - 1);
	var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
	return startIndex;
};
MonotoneChainBuilder.findChainEnd = function (pts, start) {
	var safeStart = start;
	while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
		safeStart++;
	}
	if (safeStart >= pts.length - 1) {
		return pts.length - 1;
	}
	var chainQuad = __WEBPACK_IMPORTED_MODULE_4__geomgraph_Quadrant__["a" /* default */].quadrant(pts[safeStart], pts[safeStart + 1]);
	var last = start + 1;
	while (last < pts.length) {
		if (!pts[last - 1].equals2D(pts[last])) {
			var quad = __WEBPACK_IMPORTED_MODULE_4__geomgraph_Quadrant__["a" /* default */].quadrant(pts[last - 1], pts[last]);
			if (quad !== chainQuad) break;
		}
		last++;
	}
	return last - 1;
};
MonotoneChainBuilder.getChains = function () {
	if (arguments.length === 1) {
		let pts = arguments[0];
		return MonotoneChainBuilder.getChains(pts, null);
	} else if (arguments.length === 2) {
		let pts = arguments[0], context = arguments[1];
		var mcList = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
		var startIndex = MonotoneChainBuilder.getChainStartIndices(pts);
		for (var i = 0; i < startIndex.length - 1; i++) {
			var mc = new __WEBPACK_IMPORTED_MODULE_0__MonotoneChain__["a" /* default */](pts, startIndex[i], startIndex[i + 1], context);
			mcList.add(mc);
		}
		return mcList;
	}
};
MonotoneChainBuilder.toIntArray = function (list) {
	var array = new Array(list.size()).fill(null);
	for (var i = 0; i < array.length; i++) {
		array[i] = list.get(i).intValue();
	}
	return array;
};


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MaximalEdgeRing__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geomgraph_PlanarGraph__ = __webpack_require__(64);







function PolygonBuilder() {
	this._geometryFactory = null;
	this._shellList = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
	let geometryFactory = arguments[0];
	this._geometryFactory = geometryFactory;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(PolygonBuilder.prototype, {
	sortShellsAndHoles: function (edgeRings, shellList, freeHoleList) {
		for (var it = edgeRings.iterator(); it.hasNext(); ) {
			var er = it.next();
			if (er.isHole()) {
				freeHoleList.add(er);
			} else {
				shellList.add(er);
			}
		}
	},
	computePolygons: function (shellList) {
		var resultPolyList = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
		for (var it = shellList.iterator(); it.hasNext(); ) {
			var er = it.next();
			var poly = er.toPolygon(this._geometryFactory);
			resultPolyList.add(poly);
		}
		return resultPolyList;
	},
	placeFreeHoles: function (shellList, freeHoleList) {
		for (var it = freeHoleList.iterator(); it.hasNext(); ) {
			var hole = it.next();
			if (hole.getShell() === null) {
				var shell = this.findEdgeRingContaining(hole, shellList);
				if (shell === null) throw new __WEBPACK_IMPORTED_MODULE_1__geom_TopologyException__["a" /* default */]("unable to assign hole to a shell", hole.getCoordinate(0));
				hole.setShell(shell);
			}
		}
	},
	buildMinimalEdgeRings: function (maxEdgeRings, shellList, freeHoleList) {
		var edgeRings = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
		for (var it = maxEdgeRings.iterator(); it.hasNext(); ) {
			var er = it.next();
			if (er.getMaxNodeDegree() > 2) {
				er.linkDirectedEdgesForMinimalEdgeRings();
				var minEdgeRings = er.buildMinimalRings();
				var shell = this.findShell(minEdgeRings);
				if (shell !== null) {
					this.placePolygonHoles(shell, minEdgeRings);
					shellList.add(shell);
				} else {
					freeHoleList.addAll(minEdgeRings);
				}
			} else {
				edgeRings.add(er);
			}
		}
		return edgeRings;
	},
	containsPoint: function (p) {
		for (var it = this._shellList.iterator(); it.hasNext(); ) {
			var er = it.next();
			if (er.containsPoint(p)) return true;
		}
		return false;
	},
	buildMaximalEdgeRings: function (dirEdges) {
		var maxEdgeRings = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
		for (var it = dirEdges.iterator(); it.hasNext(); ) {
			var de = it.next();
			if (de.isInResult() && de.getLabel().isArea()) {
				if (de.getEdgeRing() === null) {
					var er = new __WEBPACK_IMPORTED_MODULE_3__MaximalEdgeRing__["a" /* default */](de, this._geometryFactory);
					maxEdgeRings.add(er);
					er.setInResult();
				}
			}
		}
		return maxEdgeRings;
	},
	placePolygonHoles: function (shell, minEdgeRings) {
		for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
			var er = it.next();
			if (er.isHole()) {
				er.setShell(shell);
			}
		}
	},
	getPolygons: function () {
		var resultPolyList = this.computePolygons(this._shellList);
		return resultPolyList;
	},
	findEdgeRingContaining: function (testEr, shellList) {
		var testRing = testEr.getLinearRing();
		var testEnv = testRing.getEnvelopeInternal();
		var testPt = testRing.getCoordinateN(0);
		var minShell = null;
		var minEnv = null;
		for (var it = shellList.iterator(); it.hasNext(); ) {
			var tryShell = it.next();
			var tryRing = tryShell.getLinearRing();
			var tryEnv = tryRing.getEnvelopeInternal();
			if (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();
			var isContained = false;
			if (tryEnv.contains(testEnv) && __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;
			if (isContained) {
				if (minShell === null || minEnv.contains(tryEnv)) {
					minShell = tryShell;
				}
			}
		}
		return minShell;
	},
	findShell: function (minEdgeRings) {
		var shellCount = 0;
		var shell = null;
		for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
			var er = it.next();
			if (!er.isHole()) {
				shell = er;
				shellCount++;
			}
		}
		__WEBPACK_IMPORTED_MODULE_5__util_Assert__["a" /* default */].isTrue(shellCount <= 1, "found two shells in MinimalEdgeRing list");
		return shell;
	},
	add: function () {
		if (arguments.length === 1) {
			let graph = arguments[0];
			this.add(graph.getEdgeEnds(), graph.getNodes());
		} else if (arguments.length === 2) {
			let dirEdges = arguments[0], nodes = arguments[1];
			__WEBPACK_IMPORTED_MODULE_6__geomgraph_PlanarGraph__["a" /* default */].linkResultDirectedEdges(nodes);
			var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
			var freeHoleList = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
			var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
			this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
			this.placeFreeHoles(this._shellList, freeHoleList);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PolygonBuilder;
	}
});


/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MaximalEdgeRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MinimalEdgeRing__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_EdgeRing__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__inherits__ = __webpack_require__(3);





function MaximalEdgeRing() {
	let start = arguments[0], geometryFactory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_2__geomgraph_EdgeRing__["a" /* default */].call(this, start, geometryFactory);
}
Object(__WEBPACK_IMPORTED_MODULE_4__inherits__["a" /* default */])(MaximalEdgeRing, __WEBPACK_IMPORTED_MODULE_2__geomgraph_EdgeRing__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(MaximalEdgeRing.prototype, {
	buildMinimalRings: function () {
		var minEdgeRings = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
		var de = this._startDe;
		do {
			if (de.getMinEdgeRing() === null) {
				var minEr = new __WEBPACK_IMPORTED_MODULE_0__MinimalEdgeRing__["a" /* default */](de, this._geometryFactory);
				minEdgeRings.add(minEr);
			}
			de = de.getNext();
		} while (de !== this._startDe);
		return minEdgeRings;
	},
	setEdgeRing: function (de, er) {
		de.setEdgeRing(er);
	},
	linkDirectedEdgesForMinimalEdgeRings: function () {
		var de = this._startDe;
		do {
			var node = de.getNode();
			node.getEdges().linkMinimalDirectedEdges(this);
			de = de.getNext();
		} while (de !== this._startDe);
	},
	getNext: function (de) {
		return de.getNext();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MaximalEdgeRing;
	}
});


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_Assert__ = __webpack_require__(4);








function EdgeRing() {
	this._startDe = null;
	this._maxNodeDegree = -1;
	this._edges = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._pts = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._label = new __WEBPACK_IMPORTED_MODULE_5__Label__["a" /* default */](__WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE);
	this._ring = null;
	this._isHole = null;
	this._shell = null;
	this._holes = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._geometryFactory = null;
	let start = arguments[0], geometryFactory = arguments[1];
	this._geometryFactory = geometryFactory;
	this.computePoints(start);
	this.computeRing();
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(EdgeRing.prototype, {
	computeRing: function () {
		if (this._ring !== null) return null;
		var coord = new Array(this._pts.size()).fill(null);
		for (var i = 0; i < this._pts.size(); i++) {
			coord[i] = this._pts.get(i);
		}
		this._ring = this._geometryFactory.createLinearRing(coord);
		this._isHole = __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].isCCW(this._ring.getCoordinates());
	},
	isIsolated: function () {
		return this._label.getGeometryCount() === 1;
	},
	computePoints: function (start) {
		this._startDe = start;
		var de = start;
		var isFirstEdge = true;
		do {
			if (de === null) throw new __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__["a" /* default */]("Found null DirectedEdge");
			if (de.getEdgeRing() === this) throw new __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__["a" /* default */]("Directed Edge visited twice during ring-building at " + de.getCoordinate());
			this._edges.add(de);
			var label = de.getLabel();
			__WEBPACK_IMPORTED_MODULE_7__util_Assert__["a" /* default */].isTrue(label.isArea());
			this.mergeLabel(label);
			this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
			isFirstEdge = false;
			this.setEdgeRing(de, this);
			de = this.getNext(de);
		} while (de !== this._startDe);
	},
	getLinearRing: function () {
		return this._ring;
	},
	getCoordinate: function (i) {
		return this._pts.get(i);
	},
	computeMaxNodeDegree: function () {
		this._maxNodeDegree = 0;
		var de = this._startDe;
		do {
			var node = de.getNode();
			var degree = node.getEdges().getOutgoingDegree(this);
			if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
			de = this.getNext(de);
		} while (de !== this._startDe);
		this._maxNodeDegree *= 2;
	},
	addPoints: function (edge, isForward, isFirstEdge) {
		var edgePts = edge.getCoordinates();
		if (isForward) {
			var startIndex = 1;
			if (isFirstEdge) startIndex = 0;
			for (var i = startIndex; i < edgePts.length; i++) {
				this._pts.add(edgePts[i]);
			}
		} else {
			var startIndex = edgePts.length - 2;
			if (isFirstEdge) startIndex = edgePts.length - 1;
			for (var i = startIndex; i >= 0; i--) {
				this._pts.add(edgePts[i]);
			}
		}
	},
	isHole: function () {
		return this._isHole;
	},
	setInResult: function () {
		var de = this._startDe;
		do {
			de.getEdge().setInResult(true);
			de = de.getNext();
		} while (de !== this._startDe);
	},
	containsPoint: function (p) {
		var shell = this.getLinearRing();
		var env = shell.getEnvelopeInternal();
		if (!env.contains(p)) return false;
		if (!__WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(p, shell.getCoordinates())) return false;
		for (var i = this._holes.iterator(); i.hasNext(); ) {
			var hole = i.next();
			if (hole.containsPoint(p)) return false;
		}
		return true;
	},
	addHole: function (ring) {
		this._holes.add(ring);
	},
	isShell: function () {
		return this._shell === null;
	},
	getLabel: function () {
		return this._label;
	},
	getEdges: function () {
		return this._edges;
	},
	getMaxNodeDegree: function () {
		if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
		return this._maxNodeDegree;
	},
	getShell: function () {
		return this._shell;
	},
	mergeLabel: function () {
		if (arguments.length === 1) {
			let deLabel = arguments[0];
			this.mergeLabel(deLabel, 0);
			this.mergeLabel(deLabel, 1);
		} else if (arguments.length === 2) {
			let deLabel = arguments[0], geomIndex = arguments[1];
			var loc = deLabel.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT);
			if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE) return null;
			if (this._label.getLocation(geomIndex) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE) {
				this._label.setLocation(geomIndex, loc);
				return null;
			}
		}
	},
	setShell: function (shell) {
		this._shell = shell;
		if (shell !== null) shell.addHole(this);
	},
	toPolygon: function (geometryFactory) {
		var holeLR = new Array(this._holes.size()).fill(null);
		for (var i = 0; i < this._holes.size(); i++) {
			holeLR[i] = this._holes.get(i).getLinearRing();
		}
		var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
		return poly;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeRing;
	}
});


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GraphComponent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_Assert__ = __webpack_require__(4);


function GraphComponent() {
	this._label = null;
	this._isInResult = false;
	this._isCovered = false;
	this._isCoveredSet = false;
	this._isVisited = false;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let label = arguments[0];
		this._label = label;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GraphComponent.prototype, {
	setVisited: function (isVisited) {
		this._isVisited = isVisited;
	},
	setInResult: function (isInResult) {
		this._isInResult = isInResult;
	},
	isCovered: function () {
		return this._isCovered;
	},
	isCoveredSet: function () {
		return this._isCoveredSet;
	},
	setLabel: function (label) {
		this._label = label;
	},
	getLabel: function () {
		return this._label;
	},
	setCovered: function (isCovered) {
		this._isCovered = isCovered;
		this._isCoveredSet = true;
	},
	updateIM: function (im) {
		__WEBPACK_IMPORTED_MODULE_1__util_Assert__["a" /* default */].isTrue(this._label.getGeometryCount() >= 2, "found partial label");
		this.computeIM(im);
	},
	isInResult: function () {
		return this._isInResult;
	},
	isVisited: function () {
		return this._isVisited;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GraphComponent;
	}
});


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DirectedEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EdgeEnd__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__inherits__ = __webpack_require__(3);







function DirectedEdge() {
	this._isForward = null;
	this._isInResult = false;
	this._isVisited = false;
	this._sym = null;
	this._next = null;
	this._nextMin = null;
	this._edgeRing = null;
	this._minEdgeRing = null;
	this._depth = [0, -999, -999];
	let edge = arguments[0], isForward = arguments[1];
	__WEBPACK_IMPORTED_MODULE_1__EdgeEnd__["a" /* default */].call(this, edge);
	this._isForward = isForward;
	if (isForward) {
		this.init(edge.getCoordinate(0), edge.getCoordinate(1));
	} else {
		var n = edge.getNumPoints() - 1;
		this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
	}
	this.computeDirectedLabel();
}
Object(__WEBPACK_IMPORTED_MODULE_6__inherits__["a" /* default */])(DirectedEdge, __WEBPACK_IMPORTED_MODULE_1__EdgeEnd__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(DirectedEdge.prototype, {
	getNextMin: function () {
		return this._nextMin;
	},
	getDepth: function (position) {
		return this._depth[position];
	},
	setVisited: function (isVisited) {
		this._isVisited = isVisited;
	},
	computeDirectedLabel: function () {
		this._label = new __WEBPACK_IMPORTED_MODULE_5__Label__["a" /* default */](this._edge.getLabel());
		if (!this._isForward) this._label.flip();
	},
	getNext: function () {
		return this._next;
	},
	setDepth: function (position, depthVal) {
		if (this._depth[position] !== -999) {
			if (this._depth[position] !== depthVal) throw new __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__["a" /* default */]("assigned depths do not match", this.getCoordinate());
		}
		this._depth[position] = depthVal;
	},
	isInteriorAreaEdge: function () {
		var isInteriorAreaEdge = true;
		for (var i = 0; i < 2; i++) {
			if (!(this._label.isArea(i) && this._label.getLocation(i, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR && this._label.getLocation(i, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR)) {
				isInteriorAreaEdge = false;
			}
		}
		return isInteriorAreaEdge;
	},
	setNextMin: function (nextMin) {
		this._nextMin = nextMin;
	},
	print: function (out) {
		__WEBPACK_IMPORTED_MODULE_1__EdgeEnd__["a" /* default */].prototype.print.call(this, out);
		out.print(" " + this._depth[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT] + "/" + this._depth[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT]);
		out.print(" (" + this.getDepthDelta() + ")");
		if (this._isInResult) out.print(" inResult");
	},
	setMinEdgeRing: function (minEdgeRing) {
		this._minEdgeRing = minEdgeRing;
	},
	isLineEdge: function () {
		var isLine = this._label.isLine(0) || this._label.isLine(1);
		var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR);
		var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR);
		return isLine && isExteriorIfArea0 && isExteriorIfArea1;
	},
	setEdgeRing: function (edgeRing) {
		this._edgeRing = edgeRing;
	},
	getMinEdgeRing: function () {
		return this._minEdgeRing;
	},
	getDepthDelta: function () {
		var depthDelta = this._edge.getDepthDelta();
		if (!this._isForward) depthDelta = -depthDelta;
		return depthDelta;
	},
	setInResult: function (isInResult) {
		this._isInResult = isInResult;
	},
	getSym: function () {
		return this._sym;
	},
	isForward: function () {
		return this._isForward;
	},
	getEdge: function () {
		return this._edge;
	},
	printEdge: function (out) {
		this.print(out);
		out.print(" ");
		if (this._isForward) this._edge.print(out); else this._edge.printReverse(out);
	},
	setSym: function (de) {
		this._sym = de;
	},
	setVisitedEdge: function (isVisited) {
		this.setVisited(isVisited);
		this._sym.setVisited(isVisited);
	},
	setEdgeDepths: function (position, depth) {
		var depthDelta = this.getEdge().getDepthDelta();
		if (!this._isForward) depthDelta = -depthDelta;
		var directionFactor = 1;
		if (position === __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT) directionFactor = -1;
		var oppositePos = __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].opposite(position);
		var delta = depthDelta * directionFactor;
		var oppositeDepth = depth + delta;
		this.setDepth(position, depth);
		this.setDepth(oppositePos, oppositeDepth);
	},
	getEdgeRing: function () {
		return this._edgeRing;
	},
	isInResult: function () {
		return this._isInResult;
	},
	setNext: function (next) {
		this._next = next;
	},
	isVisited: function () {
		return this._isVisited;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DirectedEdge;
	}
});
DirectedEdge.depthFactor = function (currLocation, nextLocation) {
	if (currLocation === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR && nextLocation === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) return 1; else if (currLocation === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR && nextLocation === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR) return -1;
	return 0;
};


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeEndStar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__algorithm_locate_SimplePointInAreaLocator__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_util_TreeMap__ = __webpack_require__(35);










function EdgeEndStar() {
	this._edgeMap = new __WEBPACK_IMPORTED_MODULE_9__java_util_TreeMap__["a" /* default */]();
	this._edgeList = null;
	this._ptInAreaLocation = [__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE];
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(EdgeEndStar.prototype, {
	getNextCW: function (ee) {
		this.getEdges();
		var i = this._edgeList.indexOf(ee);
		var iNextCW = i - 1;
		if (i === 0) iNextCW = this._edgeList.size() - 1;
		return this._edgeList.get(iNextCW);
	},
	propagateSideLabels: function (geomIndex) {
		var startLoc = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE;
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			if (label.isArea(geomIndex) && label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT) !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) startLoc = label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT);
		}
		if (startLoc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) return null;
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			if (label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON) === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) label.setLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON, currLoc);
			if (label.isArea(geomIndex)) {
				var leftLoc = label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT);
				var rightLoc = label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT);
				if (rightLoc !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) {
					if (rightLoc !== currLoc) throw new __WEBPACK_IMPORTED_MODULE_3__geom_TopologyException__["a" /* default */]("side location conflict", e.getCoordinate());
					if (leftLoc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) {
						__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].shouldNeverReachHere("found single null side (at " + e.getCoordinate() + ")");
					}
					currLoc = leftLoc;
				} else {
					__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT) === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, "found single null side");
					label.setLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT, currLoc);
					label.setLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT, currLoc);
				}
			}
		}
	},
	getCoordinate: function () {
		var it = this.iterator();
		if (!it.hasNext()) return null;
		var e = it.next();
		return e.getCoordinate();
	},
	print: function (out) {
		__WEBPACK_IMPORTED_MODULE_5__java_lang_System__["a" /* default */].out.println("EdgeEndStar:   " + this.getCoordinate());
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			e.print(out);
		}
	},
	isAreaLabelsConsistent: function (geomGraph) {
		this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
		return this.checkAreaLabelsConsistent(0);
	},
	checkAreaLabelsConsistent: function (geomIndex) {
		var edges = this.getEdges();
		if (edges.size() <= 0) return true;
		var lastEdgeIndex = edges.size() - 1;
		var startLabel = edges.get(lastEdgeIndex).getLabel();
		var startLoc = startLabel.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT);
		__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(startLoc !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE, "Found unlabelled area edge");
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(label.isArea(geomIndex), "Found non-area edge");
			var leftLoc = label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT);
			var rightLoc = label.getLocation(geomIndex, __WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT);
			if (leftLoc === rightLoc) {
				return false;
			}
			if (rightLoc !== currLoc) {
				return false;
			}
			currLoc = leftLoc;
		}
		return true;
	},
	findIndex: function (eSearch) {
		this.iterator();
		for (var i = 0; i < this._edgeList.size(); i++) {
			var e = this._edgeList.get(i);
			if (e === eSearch) return i;
		}
		return -1;
	},
	iterator: function () {
		return this.getEdges().iterator();
	},
	getEdges: function () {
		if (this._edgeList === null) {
			this._edgeList = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */](this._edgeMap.values());
		}
		return this._edgeList;
	},
	getLocation: function (geomIndex, p, geom) {
		if (this._ptInAreaLocation[geomIndex] === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) {
			this._ptInAreaLocation[geomIndex] = __WEBPACK_IMPORTED_MODULE_6__algorithm_locate_SimplePointInAreaLocator__["a" /* default */].locate(p, geom[geomIndex].getGeometry());
		}
		return this._ptInAreaLocation[geomIndex];
	},
	toString: function () {
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		buf.append("EdgeEndStar:   " + this.getCoordinate());
		buf.append("\n");
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			buf.append(e);
			buf.append("\n");
		}
		return buf.toString();
	},
	computeEdgeEndLabels: function (boundaryNodeRule) {
		for (var it = this.iterator(); it.hasNext(); ) {
			var ee = it.next();
			ee.computeLabel(boundaryNodeRule);
		}
	},
	computeLabelling: function (geomGraph) {
		this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
		this.propagateSideLabels(0);
		this.propagateSideLabels(1);
		var hasDimensionalCollapseEdge = [false, false];
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			for (var geomi = 0; geomi < 2; geomi++) {
				if (label.isLine(geomi) && label.getLocation(geomi) === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
			}
		}
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			for (var geomi = 0; geomi < 2; geomi++) {
				if (label.isAnyNull(geomi)) {
					var loc = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE;
					if (hasDimensionalCollapseEdge[geomi]) {
						loc = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR;
					} else {
						var p = e.getCoordinate();
						loc = this.getLocation(geomi, p, geomGraph);
					}
					label.setAllLocationsIfNull(geomi, loc);
				}
			}
		}
	},
	getDegree: function () {
		return this._edgeMap.size();
	},
	insertEdgeEnd: function (e, obj) {
		this._edgeMap.put(e, obj);
		this._edgeList = null;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeEndStar;
	}
});


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SimplePointInAreaLocator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PointOnGeometryLocator__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollectionIterator__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__ = __webpack_require__(13);







function SimplePointInAreaLocator() {
	this._geom = null;
	let geom = arguments[0];
	this._geom = geom;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(SimplePointInAreaLocator.prototype, {
	locate: function (p) {
		return SimplePointInAreaLocator.locate(p, this._geom);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__PointOnGeometryLocator__["a" /* default */]];
	},
	getClass: function () {
		return SimplePointInAreaLocator;
	}
});
SimplePointInAreaLocator.isPointInRing = function (p, ring) {
	if (!ring.getEnvelopeInternal().intersects(p)) return false;
	return __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].isPointInRing(p, ring.getCoordinates());
};
SimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {
	if (poly.isEmpty()) return false;
	var shell = poly.getExteriorRing();
	if (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false;
	for (var i = 0; i < poly.getNumInteriorRing(); i++) {
		var hole = poly.getInteriorRingN(i);
		if (SimplePointInAreaLocator.isPointInRing(p, hole)) return false;
	}
	return true;
};
SimplePointInAreaLocator.containsPoint = function (p, geom) {
	if (geom instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Polygon__["a" /* default */]) {
		return SimplePointInAreaLocator.containsPointInPolygon(p, geom);
	} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__["a" /* default */]) {
		var geomi = new __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollectionIterator__["a" /* default */](geom);
		while (geomi.hasNext()) {
			var g2 = geomi.next();
			if (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true;
		}
	}
	return false;
};
SimplePointInAreaLocator.locate = function (p, geom) {
	if (geom.isEmpty()) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
	if (SimplePointInAreaLocator.containsPoint(p, geom)) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
	return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
};


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PointOnGeometryLocator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function PointOnGeometryLocator() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(PointOnGeometryLocator.prototype, {
	locate: function (p) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PointOnGeometryLocator;
	}
});


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SegmentIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function SegmentIntersector() {
	this._hasIntersection = false;
	this._hasProper = false;
	this._hasProperInterior = false;
	this._properIntersectionPoint = null;
	this._li = null;
	this._includeProper = null;
	this._recordIsolated = null;
	this._isSelfIntersection = null;
	this._numIntersections = 0;
	this.numTests = 0;
	this._bdyNodes = null;
	this._isDone = false;
	this._isDoneWhenProperInt = false;
	let li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];
	this._li = li;
	this._includeProper = includeProper;
	this._recordIsolated = recordIsolated;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(SegmentIntersector.prototype, {
	isTrivialIntersection: function (e0, segIndex0, e1, segIndex1) {
		if (e0 === e1) {
			if (this._li.getIntersectionNum() === 1) {
				if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;
				if (e0.isClosed()) {
					var maxSegIndex = e0.getNumPoints() - 1;
					if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
						return true;
					}
				}
			}
		}
		return false;
	},
	getProperIntersectionPoint: function () {
		return this._properIntersectionPoint;
	},
	setIsDoneIfProperInt: function (isDoneWhenProperInt) {
		this._isDoneWhenProperInt = isDoneWhenProperInt;
	},
	hasProperInteriorIntersection: function () {
		return this._hasProperInterior;
	},
	isBoundaryPointInternal: function (li, bdyNodes) {
		for (var i = bdyNodes.iterator(); i.hasNext(); ) {
			var node = i.next();
			var pt = node.getCoordinate();
			if (li.isIntersection(pt)) return true;
		}
		return false;
	},
	hasProperIntersection: function () {
		return this._hasProper;
	},
	hasIntersection: function () {
		return this._hasIntersection;
	},
	isDone: function () {
		return this._isDone;
	},
	isBoundaryPoint: function (li, bdyNodes) {
		if (bdyNodes === null) return false;
		if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;
		if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;
		return false;
	},
	setBoundaryNodes: function (bdyNodes0, bdyNodes1) {
		this._bdyNodes = new Array(2).fill(null);
		this._bdyNodes[0] = bdyNodes0;
		this._bdyNodes[1] = bdyNodes1;
	},
	addIntersections: function (e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		this.numTests++;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._recordIsolated) {
				e0.setIsolated(false);
				e1.setIsolated(false);
			}
			this._numIntersections++;
			if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
				this._hasIntersection = true;
				if (this._includeProper || !this._li.isProper()) {
					e0.addIntersections(this._li, segIndex0, 0);
					e1.addIntersections(this._li, segIndex1, 1);
				}
				if (this._li.isProper()) {
					this._properIntersectionPoint = this._li.getIntersection(0).copy();
					this._hasProper = true;
					if (this._isDoneWhenProperInt) {
						this._isDone = true;
					}
					if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;
				}
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SegmentIntersector;
	}
});
SegmentIntersector.isAdjacentSegments = function (i1, i2) {
	return Math.abs(i1 - i2) === 1;
};


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IntervalRTreeNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_Comparator__ = __webpack_require__(48);





function IntervalRTreeNode() {
	this._min = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].POSITIVE_INFINITY;
	this._max = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].NEGATIVE_INFINITY;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(IntervalRTreeNode.prototype, {
	getMin: function () {
		return this._min;
	},
	intersects: function (queryMin, queryMax) {
		if (this._min > queryMax || this._max < queryMin) return false;
		return true;
	},
	getMax: function () {
		return this._max;
	},
	toString: function () {
		return __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](this._min, 0), new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](this._max, 0));
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IntervalRTreeNode;
	}
});
function NodeComparator() {}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(NodeComparator.prototype, {
	compare: function (o1, o2) {
		var n1 = o1;
		var n2 = o2;
		var mid1 = (n1._min + n1._max) / 2;
		var mid2 = (n2._min + n2._max) / 2;
		if (mid1 < mid2) return -1;
		if (mid1 > mid2) return 1;
		return 0;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__java_util_Comparator__["a" /* default */]];
	},
	getClass: function () {
		return NodeComparator;
	}
});
IntervalRTreeNode.NodeComparator = NodeComparator;


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ArrayListVisitor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ItemVisitor__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);



function ArrayListVisitor() {
	this._items = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(ArrayListVisitor.prototype, {
	visitItem: function (item) {
		this._items.add(item);
	},
	getItems: function () {
		return this._items;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_0__ItemVisitor__["a" /* default */]];
	},
	getClass: function () {
		return ArrayListVisitor;
	}
});


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeList;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noding_OrientedCoordinateArray__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_TreeMap__ = __webpack_require__(35);




function EdgeList() {
	this._edges = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
	this._ocaMap = new __WEBPACK_IMPORTED_MODULE_3__java_util_TreeMap__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeList.prototype, {
	print: function (out) {
		out.print("MULTILINESTRING ( ");
		for (var j = 0; j < this._edges.size(); j++) {
			var e = this._edges.get(j);
			if (j > 0) out.print(",");
			out.print("(");
			var pts = e.getCoordinates();
			for (var i = 0; i < pts.length; i++) {
				if (i > 0) out.print(",");
				out.print(pts[i].x + " " + pts[i].y);
			}
			out.println(")");
		}
		out.print(")  ");
	},
	addAll: function (edgeColl) {
		for (var i = edgeColl.iterator(); i.hasNext(); ) {
			this.add(i.next());
		}
	},
	findEdgeIndex: function (e) {
		for (var i = 0; i < this._edges.size(); i++) {
			if (this._edges.get(i).equals(e)) return i;
		}
		return -1;
	},
	iterator: function () {
		return this._edges.iterator();
	},
	getEdges: function () {
		return this._edges;
	},
	get: function (i) {
		return this._edges.get(i);
	},
	findEqualEdge: function (e) {
		var oca = new __WEBPACK_IMPORTED_MODULE_0__noding_OrientedCoordinateArray__["a" /* default */](e.getCoordinates());
		var matchEdge = this._ocaMap.get(oca);
		return matchEdge;
	},
	add: function (e) {
		this._edges.add(e);
		var oca = new __WEBPACK_IMPORTED_MODULE_0__noding_OrientedCoordinateArray__["a" /* default */](e.getCoordinates());
		this._ocaMap.put(oca, e);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeList;
	}
});


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MCPointInRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_bintree_Bintree__ = __webpack_require__(268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_bintree_Interval__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__index_chain_MonotoneChainBuilder__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__RobustDeterminant__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__PointInRing__ = __webpack_require__(272);











function MCPointInRing() {
	this._ring = null;
	this._tree = null;
	this._crossings = 0;
	this._interval = new __WEBPACK_IMPORTED_MODULE_2__index_bintree_Interval__["a" /* default */]();
	let ring = arguments[0];
	this._ring = ring;
	this.buildIndex();
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(MCPointInRing.prototype, {
	testLineSegment: function (p, seg) {
		var xInt = null;
		var x1 = null;
		var y1 = null;
		var x2 = null;
		var y2 = null;
		var p1 = seg.p0;
		var p2 = seg.p1;
		x1 = p1.x - p.x;
		y1 = p1.y - p.y;
		x2 = p2.x - p.x;
		y2 = p2.y - p.y;
		if (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {
			xInt = __WEBPACK_IMPORTED_MODULE_7__RobustDeterminant__["a" /* default */].signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);
			if (0.0 < xInt) {
				this._crossings++;
			}
		}
	},
	buildIndex: function () {
		this._tree = new __WEBPACK_IMPORTED_MODULE_1__index_bintree_Bintree__["a" /* default */]();
		var pts = __WEBPACK_IMPORTED_MODULE_6__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(this._ring.getCoordinates());
		var mcList = __WEBPACK_IMPORTED_MODULE_5__index_chain_MonotoneChainBuilder__["a" /* default */].getChains(pts);
		for (var i = 0; i < mcList.size(); i++) {
			var mc = mcList.get(i);
			var mcEnv = mc.getEnvelope();
			this._interval.min = mcEnv.getMinY();
			this._interval.max = mcEnv.getMaxY();
			this._tree.insert(this._interval, mc);
		}
	},
	testMonotoneChain: function (rayEnv, mcSelecter, mc) {
		mc.select(rayEnv, mcSelecter);
	},
	isInside: function (pt) {
		this._crossings = 0;
		var rayEnv = new __WEBPACK_IMPORTED_MODULE_8__geom_Envelope__["a" /* default */](__WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].NEGATIVE_INFINITY, __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].POSITIVE_INFINITY, pt.y, pt.y);
		this._interval.min = pt.y;
		this._interval.max = pt.y;
		var segs = this._tree.query(this._interval);
		var mcSelecter = new MCSelecter(this, pt);
		for (var i = segs.iterator(); i.hasNext(); ) {
			var mc = i.next();
			this.testMonotoneChain(rayEnv, mcSelecter, mc);
		}
		if (this._crossings % 2 === 1) {
			return true;
		}
		return false;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_10__PointInRing__["a" /* default */]];
	},
	getClass: function () {
		return MCPointInRing;
	}
});
function MCSelecter() {
	__WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__["a" /* default */].apply(this);
	this.mcp = null;
	this.p = null;
	let mcp = arguments[0], p = arguments[1];
	this.mcp = mcp;
	this.p = p;
}
Object(__WEBPACK_IMPORTED_MODULE_9__inherits__["a" /* default */])(MCSelecter, __WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(MCSelecter.prototype, {
	select: function () {
		if (arguments.length === 1) {
			let ls = arguments[0];
			this.mcp.testLineSegment(this.p, ls);
		} else return __WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__["a" /* default */].prototype.select.apply(this, arguments);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MCSelecter;
	}
});
MCPointInRing.MCSelecter = MCSelecter;


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChainSelectAction;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__ = __webpack_require__(7);



function MonotoneChainSelectAction() {
	this.tempEnv1 = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */]();
	this.selectedSegment = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonotoneChainSelectAction.prototype, {
	select: function () {
		if (arguments.length === 1) {
			let seg = arguments[0];
		} else if (arguments.length === 2) {
			let mc = arguments[0], startIndex = arguments[1];
			mc.getLineSegment(startIndex, this.selectedSegment);
			this.select(this.selectedSegment);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChainSelectAction;
	}
});


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodeBase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__ = __webpack_require__(1);


function NodeBase() {
	this._items = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
	this._subnode = [null, null];
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NodeBase.prototype, {
	hasChildren: function () {
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) return true;
		}
		return false;
	},
	isPrunable: function () {
		return !(this.hasChildren() || this.hasItems());
	},
	addAllItems: function (items) {
		items.addAll(this._items);
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].addAllItems(items);
			}
		}
		return items;
	},
	size: function () {
		var subSize = 0;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].size();
			}
		}
		return subSize + this._items.size();
	},
	addAllItemsFromOverlapping: function (interval, resultItems) {
		if (interval !== null && !this.isSearchMatch(interval)) return null;
		resultItems.addAll(this._items);
		if (this._subnode[0] !== null) this._subnode[0].addAllItemsFromOverlapping(interval, resultItems);
		if (this._subnode[1] !== null) this._subnode[1].addAllItemsFromOverlapping(interval, resultItems);
	},
	hasItems: function () {
		return !this._items.isEmpty();
	},
	remove: function (itemInterval, item) {
		if (!this.isSearchMatch(itemInterval)) return false;
		var found = false;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				found = this._subnode[i].remove(itemInterval, item);
				if (found) {
					if (this._subnode[i].isPrunable()) this._subnode[i] = null;
					break;
				}
			}
		}
		if (found) return found;
		found = this._items.remove(item);
		return found;
	},
	getItems: function () {
		return this._items;
	},
	depth: function () {
		var maxSubDepth = 0;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				var sqd = this._subnode[i].depth();
				if (sqd > maxSubDepth) maxSubDepth = sqd;
			}
		}
		return maxSubDepth + 1;
	},
	nodeSize: function () {
		var subSize = 0;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].nodeSize();
			}
		}
		return subSize + 1;
	},
	add: function (item) {
		this._items.add(item);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NodeBase;
	}
});
NodeBase.getSubnodeIndex = function (interval, centre) {
	var subnodeIndex = -1;
	if (interval.min >= centre) subnodeIndex = 1;
	if (interval.max <= centre) subnodeIndex = 0;
	return subnodeIndex;
};


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IntervalSize;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__DoubleBits__ = __webpack_require__(103);


function IntervalSize() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(IntervalSize.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IntervalSize;
	}
});
IntervalSize.isZeroWidth = function (min, max) {
	var width = max - min;
	if (width === 0.0) return true;
	var maxAbs = Math.max(Math.abs(min), Math.abs(max));
	var scaledInterval = width / maxAbs;
	var level = __WEBPACK_IMPORTED_MODULE_1__DoubleBits__["a" /* default */].exponent(scaledInterval);
	return level <= IntervalSize.MIN_BINARY_EXPONENT;
};
IntervalSize.MIN_BINARY_EXPONENT = -50;


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MarkHalfEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__HalfEdge__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function MarkHalfEdge() {
	this._isMarked = false;
	let orig = arguments[0];
	__WEBPACK_IMPORTED_MODULE_1__HalfEdge__["a" /* default */].call(this, orig);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(MarkHalfEdge, __WEBPACK_IMPORTED_MODULE_1__HalfEdge__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MarkHalfEdge.prototype, {
	mark: function () {
		this._isMarked = true;
	},
	setMark: function (isMarked) {
		this._isMarked = isMarked;
	},
	isMarked: function () {
		return this._isMarked;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MarkHalfEdge;
	}
});
MarkHalfEdge.setMarkBoth = function (e, isMarked) {
	e.setMark(isMarked);
	e.sym().setMark(isMarked);
};
MarkHalfEdge.isMarked = function (e) {
	return e.isMarked();
};
MarkHalfEdge.setMark = function (e, isMarked) {
	e.setMark(isMarked);
};
MarkHalfEdge.markBoth = function (e) {
	e.mark();
	e.sym().mark();
};
MarkHalfEdge.mark = function (e) {
	e.mark();
};


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = HalfEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_Quadrant__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_Assert__ = __webpack_require__(4);




function HalfEdge() {
	this._orig = null;
	this._sym = null;
	this._next = null;
	let orig = arguments[0];
	this._orig = orig;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(HalfEdge.prototype, {
	find: function (dest) {
		var oNext = this;
		do {
			if (oNext === null) return null;
			if (oNext.dest().equals2D(dest)) return oNext;
			oNext = oNext.oNext();
		} while (oNext !== this);
		return null;
	},
	dest: function () {
		return this._sym._orig;
	},
	oNext: function () {
		return this._sym._next;
	},
	insert: function (e) {
		if (this.oNext() === this) {
			this.insertAfter(e);
			return null;
		}
		var ecmp = this.compareTo(e);
		var ePrev = this;
		do {
			var oNext = ePrev.oNext();
			var cmp = oNext.compareTo(e);
			if (cmp !== ecmp || oNext === this) {
				ePrev.insertAfter(e);
				return null;
			}
			ePrev = oNext;
		} while (ePrev !== this);
		__WEBPACK_IMPORTED_MODULE_3__util_Assert__["a" /* default */].shouldNeverReachHere();
	},
	insertAfter: function (e) {
		__WEBPACK_IMPORTED_MODULE_3__util_Assert__["a" /* default */].equals(this._orig, e.orig());
		var save = this.oNext();
		this._sym.setNext(e);
		e.sym().setNext(save);
	},
	degree: function () {
		var degree = 0;
		var e = this;
		do {
			degree++;
			e = e.oNext();
		} while (e !== this);
		return degree;
	},
	equals: function () {
		if (arguments.length === 2) {
			let p0 = arguments[0], p1 = arguments[1];
			return this._orig.equals2D(p0) && this._sym._orig.equals(p1);
		}
	},
	deltaY: function () {
		return this._sym._orig.y - this._orig.y;
	},
	sym: function () {
		return this._sym;
	},
	prev: function () {
		return this._sym.next()._sym;
	},
	compareAngularDirection: function (e) {
		var dx = this.deltaX();
		var dy = this.deltaY();
		var dx2 = e.deltaX();
		var dy2 = e.deltaY();
		if (dx === dx2 && dy === dy2) return 0;
		var quadrant = __WEBPACK_IMPORTED_MODULE_2__geomgraph_Quadrant__["a" /* default */].quadrant(dx, dy);
		var quadrant2 = __WEBPACK_IMPORTED_MODULE_2__geomgraph_Quadrant__["a" /* default */].quadrant(dx2, dy2);
		if (quadrant > quadrant2) return 1;
		if (quadrant < quadrant2) return -1;
		return __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(e._orig, e.dest(), this.dest());
	},
	prevNode: function () {
		var e = this;
		while (e.degree() === 2) {
			e = e.prev();
			if (e === this) return null;
		}
		return e;
	},
	compareTo: function (obj) {
		var e = obj;
		var comp = this.compareAngularDirection(e);
		return comp;
	},
	next: function () {
		return this._next;
	},
	setSym: function (e) {
		this._sym = e;
	},
	orig: function () {
		return this._orig;
	},
	toString: function () {
		return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")";
	},
	setNext: function (e) {
		this._next = e;
	},
	init: function (e) {
		this.setSym(e);
		e.setSym(this);
		this.setNext(e);
		e.setNext(this);
	},
	deltaX: function () {
		return this._sym._orig.x - this._orig.x;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return HalfEdge;
	}
});
HalfEdge.init = function (e0, e1) {
	if (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException("Edges are already initialized");
	e0.init(e1);
	return e0;
};
HalfEdge.create = function (p0, p1) {
	var e0 = new HalfEdge(p0);
	var e1 = new HalfEdge(p1);
	e0.init(e1);
	return e0;
};


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Quadtree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Root__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SpatialIndex__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ArrayListVisitor__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_Envelope__ = __webpack_require__(7);







function Quadtree() {
	this._root = null;
	this._minExtent = 1.0;
	this._root = new __WEBPACK_IMPORTED_MODULE_0__Root__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Quadtree.prototype, {
	size: function () {
		if (this._root !== null) return this._root.size();
		return 0;
	},
	insert: function (itemEnv, item) {
		this.collectStats(itemEnv);
		var insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);
		this._root.insert(insertEnv, item);
	},
	query: function () {
		if (arguments.length === 1) {
			let searchEnv = arguments[0];
			var visitor = new __WEBPACK_IMPORTED_MODULE_4__ArrayListVisitor__["a" /* default */]();
			this.query(searchEnv, visitor);
			return visitor.getItems();
		} else if (arguments.length === 2) {
			let searchEnv = arguments[0], visitor = arguments[1];
			this._root.visit(searchEnv, visitor);
		}
	},
	queryAll: function () {
		var foundItems = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
		this._root.addAllItems(foundItems);
		return foundItems;
	},
	remove: function (itemEnv, item) {
		var posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);
		return this._root.remove(posEnv, item);
	},
	collectStats: function (itemEnv) {
		var delX = itemEnv.getWidth();
		if (delX < this._minExtent && delX > 0.0) this._minExtent = delX;
		var delY = itemEnv.getHeight();
		if (delY < this._minExtent && delY > 0.0) this._minExtent = delY;
	},
	depth: function () {
		if (this._root !== null) return this._root.depth();
		return 0;
	},
	isEmpty: function () {
		if (this._root === null) return true;
		return false;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__SpatialIndex__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return Quadtree;
	}
});
Quadtree.ensureExtent = function (itemEnv, minExtent) {
	var minx = itemEnv.getMinX();
	var maxx = itemEnv.getMaxX();
	var miny = itemEnv.getMinY();
	var maxy = itemEnv.getMaxY();
	if (minx !== maxx && miny !== maxy) return itemEnv;
	if (minx === maxx) {
		minx = minx - minExtent / 2.0;
		maxx = minx + minExtent / 2.0;
	}
	if (miny === maxy) {
		miny = miny - minExtent / 2.0;
		maxy = miny + minExtent / 2.0;
	}
	return new __WEBPACK_IMPORTED_MODULE_6__geom_Envelope__["a" /* default */](minx, maxx, miny, maxy);
};
Quadtree.serialVersionUID = -7461163625812743604;


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodeBase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_io_Serializable__ = __webpack_require__(21);



function NodeBase() {
	this._items = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
	this._subnode = new Array(4).fill(null);
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NodeBase.prototype, {
	hasChildren: function () {
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) return true;
		}
		return false;
	},
	isPrunable: function () {
		return !(this.hasChildren() || this.hasItems());
	},
	addAllItems: function (resultItems) {
		resultItems.addAll(this._items);
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].addAllItems(resultItems);
			}
		}
		return resultItems;
	},
	getNodeCount: function () {
		var subSize = 0;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].size();
			}
		}
		return subSize + 1;
	},
	size: function () {
		var subSize = 0;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].size();
			}
		}
		return subSize + this._items.size();
	},
	addAllItemsFromOverlapping: function (searchEnv, resultItems) {
		if (!this.isSearchMatch(searchEnv)) return null;
		resultItems.addAll(this._items);
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);
			}
		}
	},
	visitItems: function (searchEnv, visitor) {
		for (var i = this._items.iterator(); i.hasNext(); ) {
			visitor.visitItem(i.next());
		}
	},
	hasItems: function () {
		return !this._items.isEmpty();
	},
	remove: function (itemEnv, item) {
		if (!this.isSearchMatch(itemEnv)) return false;
		var found = false;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				found = this._subnode[i].remove(itemEnv, item);
				if (found) {
					if (this._subnode[i].isPrunable()) this._subnode[i] = null;
					break;
				}
			}
		}
		if (found) return found;
		found = this._items.remove(item);
		return found;
	},
	visit: function (searchEnv, visitor) {
		if (!this.isSearchMatch(searchEnv)) return null;
		this.visitItems(searchEnv, visitor);
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].visit(searchEnv, visitor);
			}
		}
	},
	getItems: function () {
		return this._items;
	},
	depth: function () {
		var maxSubDepth = 0;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				var sqd = this._subnode[i].depth();
				if (sqd > maxSubDepth) maxSubDepth = sqd;
			}
		}
		return maxSubDepth + 1;
	},
	isEmpty: function () {
		var isEmpty = true;
		if (!this._items.isEmpty()) isEmpty = false;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				if (!this._subnode[i].isEmpty()) isEmpty = false;
			}
		}
		return isEmpty;
	},
	add: function (item) {
		this._items.add(item);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return NodeBase;
	}
});
NodeBase.getSubnodeIndex = function (env, centrex, centrey) {
	var subnodeIndex = -1;
	if (env.getMinX() >= centrex) {
		if (env.getMinY() >= centrey) subnodeIndex = 3;
		if (env.getMaxY() <= centrey) subnodeIndex = 1;
	}
	if (env.getMaxX() <= centrex) {
		if (env.getMinY() >= centrey) subnodeIndex = 2;
		if (env.getMaxY() <= centrey) subnodeIndex = 0;
	}
	return subnodeIndex;
};


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeoJSONParser;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);




const geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']

/**
 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/**
 * Create a new parser for GeoJSON
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of GeoJsonParser.
 * @constructor
 * @private
 */
function GeoJSONParser (geometryFactory) {
  this.geometryFactory = geometryFactory || new __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__["a" /* default */]()
}

Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(GeoJSONParser.prototype, {
  /**
   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
   *
   * @param {}
   *          A GeoJSON object.
   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
   * @private
   */
  read (json) {
    let obj
    if (typeof json === 'string') {
      obj = JSON.parse(json)
    } else {
      obj = json
    }

    const type = obj.type

    if (!parse[type]) {
      throw new Error('Unknown GeoJSON type: ' + obj.type)
    }

    if (geometryTypes.indexOf(type) !== -1) {
      return parse[type].apply(this, [obj.coordinates])
    } else if (type === 'GeometryCollection') {
      return parse[type].apply(this, [obj.geometries])
    }

    // feature or feature collection
    return parse[type].apply(this, [obj])
  },

  /**
   * Serialize a Geometry object into GeoJSON
   *
   * @param {Geometry}
   *          geometry A Geometry or array of Geometries.
   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
   * @private
   */
  write (geometry) {
    const type = geometry.getGeometryType()

    if (!extract[type]) {
      throw new Error('Geometry is not supported')
    }

    return extract[type].apply(this, [geometry])
  }
})

const parse = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function (obj) {
    const feature = {}

    // copy features
    for (let key in obj) {
      feature[key] = obj[key]
    }

    // parse geometry
    if (obj.geometry) {
      const type = obj.geometry.type
      if (!parse[type]) {
        throw new Error('Unknown GeoJSON type: ' + obj.type)
      }
      feature.geometry = this.read(obj.geometry)
    }

    // bbox
    if (obj.bbox) {
      feature.bbox = parse.bbox.apply(this, [obj.bbox])
    }

    return feature
  },

  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function (obj) {
    const featureCollection = {}

    if (obj.features) {
      featureCollection.features = []

      for (let i = 0; i < obj.features.length; ++i) {
        featureCollection.features.push(this.read(obj.features[i]))
      }
    }

    if (obj.bbox) {
      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox])
    }

    return featureCollection
  },

  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function (array) {
    const coordinates = []
    for (let i = 0; i < array.length; ++i) {
      const sub = array[i]
      coordinates.push(new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](sub[0], sub[1]))
    }
    return coordinates
  },

  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function (array) {
    return this.geometryFactory.createLinearRing([
      new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](array[0], array[1]),
      new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](array[2], array[1]),
      new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](array[2], array[3]),
      new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](array[0], array[3]),
      new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](array[0], array[1])
    ])
  },

  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function (array) {
    const coordinate = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](array[0], array[1])
    return this.geometryFactory.createPoint(coordinate)
  },

  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function (array) {
    const points = []
    for (let i = 0; i < array.length; ++i) {
      points.push(parse.Point.apply(this, [array[i]]))
    }
    return this.geometryFactory.createMultiPoint(points)
  },

  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function (array) {
    const coordinates = parse.coordinates.apply(this, [array])
    return this.geometryFactory.createLineString(coordinates)
  },

  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function (array) {
    const lineStrings = []
    for (let i = 0; i < array.length; ++i) {
      lineStrings.push(parse.LineString.apply(this, [array[i]]))
    }
    return this.geometryFactory.createMultiLineString(lineStrings)
  },

  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function (array) {
    const shellCoordinates = parse.coordinates.apply(this, [array[0]])
    const shell = this.geometryFactory.createLinearRing(shellCoordinates)
    const holes = []
    for (let i = 1; i < array.length; ++i) {
      var hole = array[i]
      var coordinates = parse.coordinates.apply(this, [hole])
      var linearRing = this.geometryFactory.createLinearRing(coordinates)
      holes.push(linearRing)
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function (array) {
    const polygons = []
    for (let i = 0; i < array.length; ++i) {
      const polygon = array[i]
      polygons.push(parse.Polygon.apply(this, [polygon]))
    }
    return this.geometryFactory.createMultiPolygon(polygons)
  },

  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function (array) {
    const geometries = []
    for (let i = 0; i < array.length; ++i) {
      const geometry = array[i]
      geometries.push(this.read(geometry))
    }
    return this.geometryFactory.createGeometryCollection(geometries)
  }
}

const extract = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function (coordinate) {
    return [coordinate.x, coordinate.y]
  },

  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function (point) {
    const array = extract.coordinate.apply(this, [point.getCoordinate()])
    return {
      type: 'Point',
      coordinates: array
    }
  },

  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function (multipoint) {
    const array = []
    for (let i = 0; i < multipoint._geometries.length; ++i) {
      const point = multipoint._geometries[i]
      const geoJson = extract.Point.apply(this, [point])
      array.push(geoJson.coordinates)
    }
    return {
      type: 'MultiPoint',
      coordinates: array
    }
  },

  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function (linestring) {
    const array = []
    const coordinates = linestring.getCoordinates()
    for (let i = 0; i < coordinates.length; ++i) {
      const coordinate = coordinates[i]
      array.push(extract.coordinate.apply(this, [coordinate]))
    }
    return {
      type: 'LineString',
      coordinates: array
    }
  },

  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function (multilinestring) {
    const array = []
    for (let i = 0; i < multilinestring._geometries.length; ++i) {
      const linestring = multilinestring._geometries[i]
      const geoJson = extract.LineString.apply(this, [linestring])
      array.push(geoJson.coordinates)
    }
    return {
      type: 'MultiLineString',
      coordinates: array
    }
  },

  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function (polygon) {
    const array = []
    const shellGeoJson = extract.LineString.apply(this, [polygon._shell])
    array.push(shellGeoJson.coordinates)
    for (let i = 0; i < polygon._holes.length; ++i) {
      const hole = polygon._holes[i]
      const holeGeoJson = extract.LineString.apply(this, [hole])
      array.push(holeGeoJson.coordinates)
    }
    return {
      type: 'Polygon',
      coordinates: array
    }
  },

  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function (multipolygon) {
    const array = []
    for (let i = 0; i < multipolygon._geometries.length; ++i) {
      const polygon = multipolygon._geometries[i]
      const geoJson = extract.Polygon.apply(this, [polygon])
      array.push(geoJson.coordinates)
    }
    return {
      type: 'MultiPolygon',
      coordinates: array
    }
  },

  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function (collection) {
    const array = []
    for (let i = 0; i < collection._geometries.length; ++i) {
      const geometry = collection._geometries[i]
      const type = geometry.getGeometryType()
      array.push(extract[type].apply(this, [geometry]))
    }
    return {
      type: 'GeometryCollection',
      geometries: array
    }
  }
}


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ScaledNoder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Noder__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NodedSegmentString__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);









function ScaledNoder() {
	this._noder = null;
	this._scaleFactor = null;
	this._offsetX = null;
	this._offsetY = null;
	this._isScaled = false;
	if (arguments.length === 2) {
		let noder = arguments[0], scaleFactor = arguments[1];
		ScaledNoder.call(this, noder, scaleFactor, 0, 0);
	} else if (arguments.length === 4) {
		let noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3];
		this._noder = noder;
		this._scaleFactor = scaleFactor;
		this._isScaled = !this.isIntegerPrecision();
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(ScaledNoder.prototype, {
	rescale: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_1__java_util_Collection__["a" /* default */])) {
			let segStrings = arguments[0];
			for (var i = segStrings.iterator(); i.hasNext(); ) {
				var ss = i.next();
				this.rescale(ss.getCoordinates());
			}
		} else if (arguments[0] instanceof Array) {
			let pts = arguments[0];
			var p0 = null;
			var p1 = null;
			if (pts.length === 2) {
				p0 = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](pts[0]);
				p1 = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](pts[1]);
			}
			for (var i = 0; i < pts.length; i++) {
				pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;
				pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;
			}
			if (pts.length === 2 && pts[0].equals2D(pts[1])) {
				__WEBPACK_IMPORTED_MODULE_6__java_lang_System__["a" /* default */].out.println(pts);
			}
		}
	},
	scale: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_1__java_util_Collection__["a" /* default */])) {
			let segStrings = arguments[0];
			var nodedSegmentStrings = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
			for (var i = segStrings.iterator(); i.hasNext(); ) {
				var ss = i.next();
				nodedSegmentStrings.add(new __WEBPACK_IMPORTED_MODULE_4__NodedSegmentString__["a" /* default */](this.scale(ss.getCoordinates()), ss.getData()));
			}
			return nodedSegmentStrings;
		} else if (arguments[0] instanceof Array) {
			let pts = arguments[0];
			var roundPts = new Array(pts.length).fill(null);
			for (var i = 0; i < pts.length; i++) {
				roundPts[i] = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);
			}
			var roundPtsNoDup = __WEBPACK_IMPORTED_MODULE_7__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(roundPts);
			return roundPtsNoDup;
		}
	},
	isIntegerPrecision: function () {
		return this._scaleFactor === 1.0;
	},
	getNodedSubstrings: function () {
		var splitSS = this._noder.getNodedSubstrings();
		if (this._isScaled) this.rescale(splitSS);
		return splitSS;
	},
	computeNodes: function (inputSegStrings) {
		var intSegStrings = inputSegStrings;
		if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
		this._noder.computeNodes(intSegStrings);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__Noder__["a" /* default */]];
	},
	getClass: function () {
		return ScaledNoder;
	}
});


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonExtracter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__GeometryFilter__ = __webpack_require__(39);





function PolygonExtracter() {
	this._comps = null;
	let comps = arguments[0];
	this._comps = comps;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(PolygonExtracter.prototype, {
	filter: function (geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__Polygon__["a" /* default */]) this._comps.add(geom);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__GeometryFilter__["a" /* default */]];
	},
	getClass: function () {
		return PolygonExtracter;
	}
});
PolygonExtracter.getPolygons = function () {
	if (arguments.length === 1) {
		let geom = arguments[0];
		return PolygonExtracter.getPolygons(geom, new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]());
	} else if (arguments.length === 2) {
		let geom = arguments[0], list = arguments[1];
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__Polygon__["a" /* default */]) {
			list.add(geom);
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_2__GeometryCollection__["a" /* default */]) {
			geom.apply(new PolygonExtracter(list));
		}
		return list;
	}
};


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryLocation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function GeometryLocation() {
	this._component = null;
	this._segIndex = null;
	this._pt = null;
	if (arguments.length === 2) {
		let component = arguments[0], pt = arguments[1];
		GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);
	} else if (arguments.length === 3) {
		let component = arguments[0], segIndex = arguments[1], pt = arguments[2];
		this._component = component;
		this._segIndex = segIndex;
		this._pt = pt;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GeometryLocation.prototype, {
	isInsideArea: function () {
		return this._segIndex === GeometryLocation.INSIDE_AREA;
	},
	getCoordinate: function () {
		return this._pt;
	},
	getGeometryComponent: function () {
		return this._component;
	},
	getSegmentIndex: function () {
		return this._segIndex;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryLocation;
	}
});
GeometryLocation.INSIDE_AREA = -1;


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PlanarGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_HashSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Node__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__NodeMap__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DirectedEdge__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Edge__ = __webpack_require__(83);







function PlanarGraph() {
	this._edges = new __WEBPACK_IMPORTED_MODULE_0__java_util_HashSet__["a" /* default */]();
	this._dirEdges = new __WEBPACK_IMPORTED_MODULE_0__java_util_HashSet__["a" /* default */]();
	this._nodeMap = new __WEBPACK_IMPORTED_MODULE_3__NodeMap__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(PlanarGraph.prototype, {
	findNodesOfDegree: function (degree) {
		var nodesFound = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
		for (var i = this.nodeIterator(); i.hasNext(); ) {
			var node = i.next();
			if (node.getDegree() === degree) nodesFound.add(node);
		}
		return nodesFound;
	},
	dirEdgeIterator: function () {
		return this._dirEdges.iterator();
	},
	edgeIterator: function () {
		return this._edges.iterator();
	},
	remove: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_6__Edge__["a" /* default */]) {
			let edge = arguments[0];
			this.remove(edge.getDirEdge(0));
			this.remove(edge.getDirEdge(1));
			this._edges.remove(edge);
			edge.remove();
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_4__DirectedEdge__["a" /* default */]) {
			let de = arguments[0];
			var sym = de.getSym();
			if (sym !== null) sym.setSym(null);
			de.getFromNode().remove(de);
			de.remove();
			this._dirEdges.remove(de);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* default */]) {
			let node = arguments[0];
			var outEdges = node.getOutEdges().getEdges();
			for (var i = outEdges.iterator(); i.hasNext(); ) {
				var de = i.next();
				var sym = de.getSym();
				if (sym !== null) this.remove(sym);
				this._dirEdges.remove(de);
				var edge = de.getEdge();
				if (edge !== null) {
					this._edges.remove(edge);
				}
			}
			this._nodeMap.remove(node.getCoordinate());
			node.remove();
		}
	},
	findNode: function (pt) {
		return this._nodeMap.find(pt);
	},
	getEdges: function () {
		return this._edges;
	},
	nodeIterator: function () {
		return this._nodeMap.iterator();
	},
	contains: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_6__Edge__["a" /* default */]) {
			let e = arguments[0];
			return this._edges.contains(e);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_4__DirectedEdge__["a" /* default */]) {
			let de = arguments[0];
			return this._dirEdges.contains(de);
		}
	},
	add: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* default */]) {
			let node = arguments[0];
			this._nodeMap.add(node);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_6__Edge__["a" /* default */]) {
			let edge = arguments[0];
			this._edges.add(edge);
			this.add(edge.getDirEdge(0));
			this.add(edge.getDirEdge(1));
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_4__DirectedEdge__["a" /* default */]) {
			let dirEdge = arguments[0];
			this._dirEdges.add(dirEdge);
		}
	},
	getNodes: function () {
		return this._nodeMap.values();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PlanarGraph;
	}
});


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_impl_CoordinateArraySequence__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__valid_IsValidOp__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_lang_Exception__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__java_util_Comparator__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__util_Assert__ = __webpack_require__(4);













function EdgeRing() {
	this._factory = null;
	this._deList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	this._lowestEdge = null;
	this._ring = null;
	this._ringPts = null;
	this._holes = null;
	this._shell = null;
	this._isHole = null;
	this._isProcessed = false;
	this._isIncludedSet = false;
	this._isIncluded = false;
	let factory = arguments[0];
	this._factory = factory;
}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(EdgeRing.prototype, {
	isIncluded: function () {
		return this._isIncluded;
	},
	getCoordinates: function () {
		if (this._ringPts === null) {
			var coordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
			for (var i = this._deList.iterator(); i.hasNext(); ) {
				var de = i.next();
				var edge = de.getEdge();
				EdgeRing.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);
			}
			this._ringPts = coordList.toCoordinateArray();
		}
		return this._ringPts;
	},
	isIncludedSet: function () {
		return this._isIncludedSet;
	},
	isValid: function () {
		this.getCoordinates();
		if (this._ringPts.length <= 3) return false;
		this.getRing();
		return __WEBPACK_IMPORTED_MODULE_4__valid_IsValidOp__["a" /* default */].isValid(this._ring);
	},
	build: function (startDE) {
		var de = startDE;
		do {
			this.add(de);
			de.setRing(this);
			de = de.getNext();
			__WEBPACK_IMPORTED_MODULE_12__util_Assert__["a" /* default */].isTrue(de !== null, "found null DE in ring");
			__WEBPACK_IMPORTED_MODULE_12__util_Assert__["a" /* default */].isTrue(de === startDE || !de.isInRing(), "found DE already in ring");
		} while (de !== startDE);
	},
	isOuterHole: function () {
		if (!this._isHole) return false;
		return !this.hasShell();
	},
	getPolygon: function () {
		var holeLR = null;
		if (this._holes !== null) {
			holeLR = new Array(this._holes.size()).fill(null);
			for (var i = 0; i < this._holes.size(); i++) {
				holeLR[i] = this._holes.get(i);
			}
		}
		var poly = this._factory.createPolygon(this._ring, holeLR);
		return poly;
	},
	isHole: function () {
		return this._isHole;
	},
	isProcessed: function () {
		return this._isProcessed;
	},
	addHole: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_LinearRing__["a" /* default */]) {
			let hole = arguments[0];
			if (this._holes === null) this._holes = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
			this._holes.add(hole);
		} else if (arguments[0] instanceof EdgeRing) {
			let holeER = arguments[0];
			holeER.setShell(this);
			var hole = holeER.getRing();
			if (this._holes === null) this._holes = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
			this._holes.add(hole);
		}
	},
	setIncluded: function (isIncluded) {
		this._isIncluded = isIncluded;
		this._isIncludedSet = true;
	},
	getOuterHole: function () {
		if (this.isHole()) return null;
		for (var i = 0; i < this._deList.size(); i++) {
			var de = this._deList.get(i);
			var adjRing = de.getSym().getRing();
			if (adjRing.isOuterHole()) return adjRing;
		}
		return null;
	},
	computeHole: function () {
		var ring = this.getRing();
		this._isHole = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].isCCW(ring.getCoordinates());
	},
	hasShell: function () {
		return this._shell !== null;
	},
	isOuterShell: function () {
		return this.getOuterHole() !== null;
	},
	getLineString: function () {
		this.getCoordinates();
		return this._factory.createLineString(this._ringPts);
	},
	toString: function () {
		return __WEBPACK_IMPORTED_MODULE_2__io_WKTWriter__["a" /* default */].toLineString(new __WEBPACK_IMPORTED_MODULE_3__geom_impl_CoordinateArraySequence__["a" /* default */](this.getCoordinates()));
	},
	getShell: function () {
		if (this.isHole()) return this._shell;
		return this;
	},
	add: function (de) {
		this._deList.add(de);
	},
	getRing: function () {
		if (this._ring !== null) return this._ring;
		this.getCoordinates();
		if (this._ringPts.length < 3) __WEBPACK_IMPORTED_MODULE_8__java_lang_System__["a" /* default */].out.println(this._ringPts);
		try {
			this._ring = this._factory.createLinearRing(this._ringPts);
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_7__java_lang_Exception__["a" /* default */]) {
				__WEBPACK_IMPORTED_MODULE_8__java_lang_System__["a" /* default */].out.println(this._ringPts);
			} else throw ex;
		} finally {}
		return this._ring;
	},
	updateIncluded: function () {
		if (this.isHole()) return null;
		for (var i = 0; i < this._deList.size(); i++) {
			var de = this._deList.get(i);
			var adjShell = de.getSym().getRing().getShell();
			if (adjShell !== null && adjShell.isIncludedSet()) {
				this.setIncluded(!adjShell.isIncluded());
				return null;
			}
		}
	},
	setShell: function (shell) {
		this._shell = shell;
	},
	setProcessed: function (isProcessed) {
		this._isProcessed = isProcessed;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeRing;
	}
});
EdgeRing.findDirEdgesInRing = function (startDE) {
	var de = startDE;
	var edges = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	do {
		edges.add(de);
		de = de.getNext();
		__WEBPACK_IMPORTED_MODULE_12__util_Assert__["a" /* default */].isTrue(de !== null, "found null DE in ring");
		__WEBPACK_IMPORTED_MODULE_12__util_Assert__["a" /* default */].isTrue(de === startDE || !de.isInRing(), "found DE already in ring");
	} while (de !== startDE);
	return edges;
};
EdgeRing.addEdge = function (coords, isForward, coordList) {
	if (isForward) {
		for (var i = 0; i < coords.length; i++) {
			coordList.add(coords[i], false);
		}
	} else {
		for (var i = coords.length - 1; i >= 0; i--) {
			coordList.add(coords[i], false);
		}
	}
};
EdgeRing.findEdgeRingContaining = function (testEr, shellList) {
	var testRing = testEr.getRing();
	var testEnv = testRing.getEnvelopeInternal();
	var testPt = testRing.getCoordinateN(0);
	var minShell = null;
	var minShellEnv = null;
	for (var it = shellList.iterator(); it.hasNext(); ) {
		var tryShell = it.next();
		var tryShellRing = tryShell.getRing();
		var tryShellEnv = tryShellRing.getEnvelopeInternal();
		if (tryShellEnv.equals(testEnv)) continue;
		if (!tryShellEnv.contains(testEnv)) continue;
		testPt = __WEBPACK_IMPORTED_MODULE_9__geom_CoordinateArrays__["a" /* default */].ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());
		var isContained = false;
		if (__WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(testPt, tryShellRing.getCoordinates())) isContained = true;
		if (isContained) {
			if (minShell === null || minShellEnv.contains(tryShellEnv)) {
				minShell = tryShell;
				minShellEnv = minShell.getRing().getEnvelopeInternal();
			}
		}
	}
	return minShell;
};
function EnvelopeComparator() {}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(EnvelopeComparator.prototype, {
	compare: function (obj0, obj1) {
		var r0 = obj0;
		var r1 = obj1;
		return r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_11__java_util_Comparator__["a" /* default */]];
	},
	getClass: function () {
		return EnvelopeComparator;
	}
});
EdgeRing.EnvelopeComparator = EnvelopeComparator;


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConsistentAreaTester;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__relate_RelateNodeGraph__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_RobustLineIntersector__ = __webpack_require__(22);



function ConsistentAreaTester() {
	this._li = new __WEBPACK_IMPORTED_MODULE_2__algorithm_RobustLineIntersector__["a" /* default */]();
	this._geomGraph = null;
	this._nodeGraph = new __WEBPACK_IMPORTED_MODULE_0__relate_RelateNodeGraph__["a" /* default */]();
	this._invalidPoint = null;
	let geomGraph = arguments[0];
	this._geomGraph = geomGraph;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(ConsistentAreaTester.prototype, {
	isNodeEdgeAreaLabelsConsistent: function () {
		for (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext(); ) {
			var node = nodeIt.next();
			if (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {
				this._invalidPoint = node.getCoordinate().copy();
				return false;
			}
		}
		return true;
	},
	getInvalidPoint: function () {
		return this._invalidPoint;
	},
	hasDuplicateRings: function () {
		for (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext(); ) {
			var node = nodeIt.next();
			for (var i = node.getEdges().iterator(); i.hasNext(); ) {
				var eeb = i.next();
				if (eeb.getEdgeEnds().size() > 1) {
					this._invalidPoint = eeb.getEdge().getCoordinate(0);
					return true;
				}
			}
		}
		return false;
	},
	isNodeConsistentArea: function () {
		var intersector = this._geomGraph.computeSelfNodes(this._li, true, true);
		if (intersector.hasProperIntersection()) {
			this._invalidPoint = intersector.getProperIntersectionPoint();
			return false;
		}
		this._nodeGraph.build(this._geomGraph);
		return this.isNodeEdgeAreaLabelsConsistent();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConsistentAreaTester;
	}
});


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeEndBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geomgraph_EdgeEnd__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function EdgeEndBuilder() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeEndBuilder.prototype, {
	createEdgeEndForNext: function (edge, l, eiCurr, eiNext) {
		var iNext = eiCurr.segmentIndex + 1;
		if (iNext >= edge.getNumPoints() && eiNext === null) return null;
		var pNext = edge.getCoordinate(iNext);
		if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;
		var e = new __WEBPACK_IMPORTED_MODULE_0__geomgraph_EdgeEnd__["a" /* default */](edge, eiCurr.coord, pNext, new __WEBPACK_IMPORTED_MODULE_2__geomgraph_Label__["a" /* default */](edge.getLabel()));
		l.add(e);
	},
	createEdgeEndForPrev: function (edge, l, eiCurr, eiPrev) {
		var iPrev = eiCurr.segmentIndex;
		if (eiCurr.dist === 0.0) {
			if (iPrev === 0) return null;
			iPrev--;
		}
		var pPrev = edge.getCoordinate(iPrev);
		if (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;
		var label = new __WEBPACK_IMPORTED_MODULE_2__geomgraph_Label__["a" /* default */](edge.getLabel());
		label.flip();
		var e = new __WEBPACK_IMPORTED_MODULE_0__geomgraph_EdgeEnd__["a" /* default */](edge, eiCurr.coord, pPrev, label);
		l.add(e);
	},
	computeEdgeEnds: function () {
		if (arguments.length === 1) {
			let edges = arguments[0];
			var l = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
			for (var i = edges; i.hasNext(); ) {
				var e = i.next();
				this.computeEdgeEnds(e, l);
			}
			return l;
		} else if (arguments.length === 2) {
			let edge = arguments[0], l = arguments[1];
			var eiList = edge.getEdgeIntersectionList();
			eiList.addEndpoints();
			var it = eiList.iterator();
			var eiPrev = null;
			var eiCurr = null;
			if (!it.hasNext()) return null;
			var eiNext = it.next();
			do {
				eiPrev = eiCurr;
				eiCurr = eiNext;
				eiNext = null;
				if (it.hasNext()) eiNext = it.next();
				if (eiCurr !== null) {
					this.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);
					this.createEdgeEndForNext(edge, l, eiCurr, eiNext);
				}
			} while (eiCurr !== null);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeEndBuilder;
	}
});


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RelateNodeFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__EdgeEndBundleStar__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RelateNode__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geomgraph_NodeFactory__ = __webpack_require__(100);





function RelateNodeFactory() {
	__WEBPACK_IMPORTED_MODULE_4__geomgraph_NodeFactory__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(RelateNodeFactory, __WEBPACK_IMPORTED_MODULE_4__geomgraph_NodeFactory__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(RelateNodeFactory.prototype, {
	createNode: function (coord) {
		return new __WEBPACK_IMPORTED_MODULE_2__RelateNode__["a" /* default */](coord, new __WEBPACK_IMPORTED_MODULE_0__EdgeEndBundleStar__["a" /* default */]());
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RelateNodeFactory;
	}
});


/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CascadedPolygonUnion;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_util_PolygonExtracter__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_strtree_STRtree__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_util_GeometryCombiner__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_util_List__ = __webpack_require__(33);










function CascadedPolygonUnion() {
	this._inputPolys = null;
	this._geomFactory = null;
	let polys = arguments[0];
	this._inputPolys = polys;
	if (this._inputPolys === null) this._inputPolys = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(CascadedPolygonUnion.prototype, {
	reduceToGeometries: function (geomTree) {
		var geoms = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = geomTree.iterator(); i.hasNext(); ) {
			var o = i.next();
			var geom = null;
			if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(o, __WEBPACK_IMPORTED_MODULE_9__java_util_List__["a" /* default */])) {
				geom = this.unionTree(o);
			} else if (o instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Geometry__["a" /* default */]) {
				geom = o;
			}
			geoms.add(geom);
		}
		return geoms;
	},
	extractByEnvelope: function (env, geom, disjointGeoms) {
		var intersectingGeoms = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elem = geom.getGeometryN(i);
			if (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem); else disjointGeoms.add(elem);
		}
		return this._geomFactory.buildGeometry(intersectingGeoms);
	},
	unionOptimized: function (g0, g1) {
		var g0Env = g0.getEnvelopeInternal();
		var g1Env = g1.getEnvelopeInternal();
		if (!g0Env.intersects(g1Env)) {
			var combo = __WEBPACK_IMPORTED_MODULE_6__geom_util_GeometryCombiner__["a" /* default */].combine(g0, g1);
			return combo;
		}
		if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);
		var commonEnv = g0Env.intersection(g1Env);
		return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
	},
	union: function () {
		if (this._inputPolys === null) throw new IllegalStateException("union() method cannot be called twice");
		if (this._inputPolys.isEmpty()) return null;
		this._geomFactory = this._inputPolys.iterator().next().getFactory();
		var index = new __WEBPACK_IMPORTED_MODULE_1__index_strtree_STRtree__["a" /* default */](CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
		for (var i = this._inputPolys.iterator(); i.hasNext(); ) {
			var item = i.next();
			index.insert(item.getEnvelopeInternal(), item);
		}
		this._inputPolys = null;
		var itemTree = index.itemsTree();
		var unionAll = this.unionTree(itemTree);
		return unionAll;
	},
	binaryUnion: function () {
		if (arguments.length === 1) {
			let geoms = arguments[0];
			return this.binaryUnion(geoms, 0, geoms.size());
		} else if (arguments.length === 3) {
			let geoms = arguments[0], start = arguments[1], end = arguments[2];
			if (end - start <= 1) {
				var g0 = CascadedPolygonUnion.getGeometry(geoms, start);
				return this.unionSafe(g0, null);
			} else if (end - start === 2) {
				return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));
			} else {
				var mid = Math.trunc((end + start) / 2);
				var g0 = this.binaryUnion(geoms, start, mid);
				var g1 = this.binaryUnion(geoms, mid, end);
				return this.unionSafe(g0, g1);
			}
		}
	},
	repeatedUnion: function (geoms) {
		var union = null;
		for (var i = geoms.iterator(); i.hasNext(); ) {
			var g = i.next();
			if (union === null) union = g.copy(); else union = union.union(g);
		}
		return union;
	},
	unionSafe: function (g0, g1) {
		if (g0 === null && g1 === null) return null;
		if (g0 === null) return g1.copy();
		if (g1 === null) return g0.copy();
		return this.unionOptimized(g0, g1);
	},
	unionActual: function (g0, g1) {
		return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));
	},
	unionTree: function (geomTree) {
		var geoms = this.reduceToGeometries(geomTree);
		var union = this.binaryUnion(geoms);
		return union;
	},
	unionUsingEnvelopeIntersection: function (g0, g1, common) {
		var disjointPolys = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
		var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
		var union = this.unionActual(g0Int, g1Int);
		disjointPolys.add(union);
		var overallUnion = __WEBPACK_IMPORTED_MODULE_6__geom_util_GeometryCombiner__["a" /* default */].combine(disjointPolys);
		return overallUnion;
	},
	bufferUnion: function () {
		if (arguments.length === 1) {
			let geoms = arguments[0];
			var factory = geoms.get(0).getFactory();
			var gColl = factory.buildGeometry(geoms);
			var unionAll = gColl.buffer(0.0);
			return unionAll;
		} else if (arguments.length === 2) {
			let g0 = arguments[0], g1 = arguments[1];
			var factory = g0.getFactory();
			var gColl = factory.createGeometryCollection([g0, g1]);
			var unionAll = gColl.buffer(0.0);
			return unionAll;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CascadedPolygonUnion;
	}
});
CascadedPolygonUnion.restrictToPolygons = function (g) {
	if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(g, __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__["a" /* default */])) {
		return g;
	}
	var polygons = __WEBPACK_IMPORTED_MODULE_0__geom_util_PolygonExtracter__["a" /* default */].getPolygons(g);
	if (polygons.size() === 1) return polygons.get(0);
	return g.getFactory().createMultiPolygon(__WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__["a" /* default */].toPolygonArray(polygons));
};
CascadedPolygonUnion.getGeometry = function (list, index) {
	if (index >= list.size()) return null;
	return list.get(index);
};
CascadedPolygonUnion.union = function (polys) {
	var op = new CascadedPolygonUnion(polys);
	return op.union();
};
CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PointGeometryUnion;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_util_GeometryCombiner__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_CoordinateArrays__ = __webpack_require__(19);






function PointGeometryUnion() {
	this._pointGeom = null;
	this._otherGeom = null;
	this._geomFact = null;
	let pointGeom = arguments[0], otherGeom = arguments[1];
	this._pointGeom = pointGeom;
	this._otherGeom = otherGeom;
	this._geomFact = otherGeom.getFactory();
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(PointGeometryUnion.prototype, {
	union: function () {
		var locater = new __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__["a" /* default */]();
		var exteriorCoords = new __WEBPACK_IMPORTED_MODULE_2__java_util_TreeSet__["a" /* default */]();
		for (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {
			var point = this._pointGeom.getGeometryN(i);
			var coord = point.getCoordinate();
			var loc = locater.locate(coord, this._otherGeom);
			if (loc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR) exteriorCoords.add(coord);
		}
		if (exteriorCoords.size() === 0) return this._otherGeom;
		var ptComp = null;
		var coords = __WEBPACK_IMPORTED_MODULE_5__geom_CoordinateArrays__["a" /* default */].toCoordinateArray(exteriorCoords);
		if (coords.length === 1) {
			ptComp = this._geomFact.createPoint(coords[0]);
		} else {
			ptComp = this._geomFact.createMultiPointFromCoords(coords);
		}
		return __WEBPACK_IMPORTED_MODULE_4__geom_util_GeometryCombiner__["a" /* default */].combine(ptComp, this._otherGeom);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PointGeometryUnion;
	}
});
PointGeometryUnion.union = function (pointGeom, otherGeom) {
	var unioner = new PointGeometryUnion(pointGeom, otherGeom);
	return unioner.union();
};


/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineSegmentIndex;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_quadtree_Quadtree__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_ItemVisitor__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__TaggedLineString__ = __webpack_require__(164);







function LineSegmentIndex() {
	this._index = new __WEBPACK_IMPORTED_MODULE_0__index_quadtree_Quadtree__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LineSegmentIndex.prototype, {
	remove: function (seg) {
		this._index.remove(new __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */](seg.p0, seg.p1), seg);
	},
	add: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_6__TaggedLineString__["a" /* default */]) {
			let line = arguments[0];
			var segs = line.getSegments();
			for (var i = 0; i < segs.length; i++) {
				var seg = segs[i];
				this.add(seg);
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__["a" /* default */]) {
			let seg = arguments[0];
			this._index.insert(new __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */](seg.p0, seg.p1), seg);
		}
	},
	query: function (querySeg) {
		var env = new __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */](querySeg.p0, querySeg.p1);
		var visitor = new LineSegmentVisitor(querySeg);
		this._index.query(env, visitor);
		var itemsFound = visitor.getItems();
		return itemsFound;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineSegmentIndex;
	}
});
function LineSegmentVisitor() {
	this._querySeg = null;
	this._items = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
	let querySeg = arguments[0];
	this._querySeg = querySeg;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LineSegmentVisitor.prototype, {
	visitItem: function (item) {
		var seg = item;
		if (__WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */].intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);
	},
	getItems: function () {
		return this._items;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__index_ItemVisitor__["a" /* default */]];
	},
	getClass: function () {
		return LineSegmentVisitor;
	}
});


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TaggedLineString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__TaggedLineSegment__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);



function TaggedLineString() {
	this._parentLine = null;
	this._segs = null;
	this._resultSegs = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
	this._minimumSize = null;
	if (arguments.length === 1) {
		let parentLine = arguments[0];
		TaggedLineString.call(this, parentLine, 2);
	} else if (arguments.length === 2) {
		let parentLine = arguments[0], minimumSize = arguments[1];
		this._parentLine = parentLine;
		this._minimumSize = minimumSize;
		this.init();
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(TaggedLineString.prototype, {
	addToResult: function (seg) {
		this._resultSegs.add(seg);
	},
	asLineString: function () {
		return this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));
	},
	getResultSize: function () {
		var resultSegsSize = this._resultSegs.size();
		return resultSegsSize === 0 ? 0 : resultSegsSize + 1;
	},
	getParent: function () {
		return this._parentLine;
	},
	getSegment: function (i) {
		return this._segs[i];
	},
	getParentCoordinates: function () {
		return this._parentLine.getCoordinates();
	},
	getMinimumSize: function () {
		return this._minimumSize;
	},
	asLinearRing: function () {
		return this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));
	},
	getSegments: function () {
		return this._segs;
	},
	init: function () {
		var pts = this._parentLine.getCoordinates();
		this._segs = new Array(pts.length - 1).fill(null);
		for (var i = 0; i < pts.length - 1; i++) {
			var seg = new __WEBPACK_IMPORTED_MODULE_1__TaggedLineSegment__["a" /* default */](pts[i], pts[i + 1], this._parentLine, i);
			this._segs[i] = seg;
		}
	},
	getResultCoordinates: function () {
		return TaggedLineString.extractCoordinates(this._resultSegs);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TaggedLineString;
	}
});
TaggedLineString.extractCoordinates = function (segs) {
	var pts = new Array(segs.size() + 1).fill(null);
	var seg = null;
	for (var i = 0; i < segs.size(); i++) {
		seg = segs.get(i);
		pts[i] = seg.p0;
	}
	pts[pts.length - 1] = seg.p1;
	return pts;
};


/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConstraintVertex;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__quadedge_Vertex__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function ConstraintVertex() {
	this._isOnConstraint = null;
	this._constraint = null;
	let p = arguments[0];
	__WEBPACK_IMPORTED_MODULE_1__quadedge_Vertex__["a" /* default */].call(this, p);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(ConstraintVertex, __WEBPACK_IMPORTED_MODULE_1__quadedge_Vertex__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(ConstraintVertex.prototype, {
	getConstraint: function () {
		return this._constraint;
	},
	setOnConstraint: function (isOnConstraint) {
		this._isOnConstraint = isOnConstraint;
	},
	merge: function (other) {
		if (other._isOnConstraint) {
			this._isOnConstraint = true;
			this._constraint = other._constraint;
		}
	},
	isOnConstraint: function () {
		return this._isOnConstraint;
	},
	setConstraint: function (constraint) {
		this._isOnConstraint = true;
		this._constraint = constraint;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConstraintVertex;
	}
});


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = QuadEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__ = __webpack_require__(14);



function QuadEdge() {
	this._rot = null;
	this._vertex = null;
	this._next = null;
	this._data = null;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(QuadEdge.prototype, {
	equalsNonOriented: function (qe) {
		if (this.equalsOriented(qe)) return true;
		if (this.equalsOriented(qe.sym())) return true;
		return false;
	},
	toLineSegment: function () {
		return new __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__["a" /* default */](this._vertex.getCoordinate(), this.dest().getCoordinate());
	},
	dest: function () {
		return this.sym().orig();
	},
	oNext: function () {
		return this._next;
	},
	equalsOriented: function (qe) {
		if (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;
		return false;
	},
	dNext: function () {
		return this.sym().oNext().sym();
	},
	lPrev: function () {
		return this._next.sym();
	},
	rPrev: function () {
		return this.sym().oNext();
	},
	rot: function () {
		return this._rot;
	},
	oPrev: function () {
		return this._rot._next._rot;
	},
	sym: function () {
		return this._rot._rot;
	},
	setOrig: function (o) {
		this._vertex = o;
	},
	lNext: function () {
		return this.invRot().oNext().rot();
	},
	getLength: function () {
		return this.orig().getCoordinate().distance(this.dest().getCoordinate());
	},
	invRot: function () {
		return this._rot.sym();
	},
	setDest: function (d) {
		this.sym().setOrig(d);
	},
	setData: function (data) {
		this._data = data;
	},
	getData: function () {
		return this._data;
	},
	delete: function () {
		this._rot = null;
	},
	orig: function () {
		return this._vertex;
	},
	rNext: function () {
		return this._rot._next.invRot();
	},
	toString: function () {
		var p0 = this._vertex.getCoordinate();
		var p1 = this.dest().getCoordinate();
		return __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(p0, p1);
	},
	isLive: function () {
		return this._rot !== null;
	},
	getPrimary: function () {
		if (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this; else return this.sym();
	},
	dPrev: function () {
		return this.invRot().oNext().invRot();
	},
	setNext: function (next) {
		this._next = next;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return QuadEdge;
	}
});
QuadEdge.makeEdge = function (o, d) {
	var q0 = new QuadEdge();
	var q1 = new QuadEdge();
	var q2 = new QuadEdge();
	var q3 = new QuadEdge();
	q0._rot = q1;
	q1._rot = q2;
	q2._rot = q3;
	q3._rot = q0;
	q0.setNext(q0);
	q1.setNext(q3);
	q2.setNext(q2);
	q3.setNext(q1);
	var base = q0;
	base.setOrig(o);
	base.setDest(d);
	return base;
};
QuadEdge.swap = function (e) {
	var a = e.oPrev();
	var b = e.sym().oPrev();
	QuadEdge.splice(e, a);
	QuadEdge.splice(e.sym(), b);
	QuadEdge.splice(e, a.lNext());
	QuadEdge.splice(e.sym(), b.lNext());
	e.setOrig(a.dest());
	e.setDest(b.dest());
};
QuadEdge.splice = function (a, b) {
	var alpha = a.oNext().rot();
	var beta = b.oNext().rot();
	var t1 = b.oNext();
	var t2 = a.oNext();
	var t3 = beta.oNext();
	var t4 = alpha.oNext();
	a.setNext(t1);
	b.setNext(t2);
	alpha.setNext(t3);
	beta.setNext(t4);
};
QuadEdge.connect = function (a, b) {
	var e = QuadEdge.makeEdge(a.dest(), b.orig());
	QuadEdge.splice(e, a.lNext());
	QuadEdge.splice(e.sym(), b);
	return e;
};


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LastFoundQuadEdgeLocator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__QuadEdgeLocator__ = __webpack_require__(370);


function LastFoundQuadEdgeLocator() {
	this._subdiv = null;
	this._lastEdge = null;
	let subdiv = arguments[0];
	this._subdiv = subdiv;
	this.init();
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(LastFoundQuadEdgeLocator.prototype, {
	init: function () {
		this._lastEdge = this.findEdge();
	},
	locate: function (v) {
		if (!this._lastEdge.isLive()) {
			this.init();
		}
		var e = this._subdiv.locateFromEdge(v, this._lastEdge);
		this._lastEdge = e;
		return e;
	},
	findEdge: function () {
		var edges = this._subdiv.getEdges();
		return edges.iterator().next();
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__QuadEdgeLocator__["a" /* default */]];
	},
	getClass: function () {
		return LastFoundQuadEdgeLocator;
	}
});


/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Segment;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__ = __webpack_require__(14);



function Segment() {
	this._ls = null;
	this._data = null;
	if (arguments.length === 2) {
		let p0 = arguments[0], p1 = arguments[1];
		this._ls = new __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__["a" /* default */](p0, p1);
	} else if (arguments.length === 3) {
		let p0 = arguments[0], p1 = arguments[1], data = arguments[2];
		this._ls = new __WEBPACK_IMPORTED_MODULE_2__geom_LineSegment__["a" /* default */](p0, p1);
		this._data = data;
	} else if (arguments.length === 6) {
		let x1 = arguments[0], y1 = arguments[1], z1 = arguments[2], x2 = arguments[3], y2 = arguments[4], z2 = arguments[5];
		Segment.call(this, new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](x1, y1, z1), new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](x2, y2, z2));
	} else if (arguments.length === 7) {
		let x1 = arguments[0], y1 = arguments[1], z1 = arguments[2], x2 = arguments[3], y2 = arguments[4], z2 = arguments[5], data = arguments[6];
		Segment.call(this, new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](x1, y1, z1), new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](x2, y2, z2), data);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Segment.prototype, {
	getLineSegment: function () {
		return this._ls;
	},
	getEndZ: function () {
		var p = this._ls.getCoordinate(1);
		return p.z;
	},
	getStartZ: function () {
		var p = this._ls.getCoordinate(0);
		return p.z;
	},
	intersection: function (s) {
		return this._ls.intersection(s.getLineSegment());
	},
	getStart: function () {
		return this._ls.getCoordinate(0);
	},
	getEnd: function () {
		return this._ls.getCoordinate(1);
	},
	getEndY: function () {
		var p = this._ls.getCoordinate(1);
		return p.y;
	},
	getStartX: function () {
		var p = this._ls.getCoordinate(0);
		return p.x;
	},
	equalsTopo: function (s) {
		return this._ls.equalsTopo(s.getLineSegment());
	},
	getStartY: function () {
		var p = this._ls.getCoordinate(0);
		return p.y;
	},
	setData: function (data) {
		this._data = data;
	},
	getData: function () {
		return this._data;
	},
	getEndX: function () {
		var p = this._ls.getCoordinate(1);
		return p.x;
	},
	toString: function () {
		return this._ls.toString();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Segment;
	}
});


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LocationIndexedLine;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LinearLocation__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LocationIndexOfPoint__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__LocationIndexOfLine__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ExtractLineByLocation__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_MultiLineString__ = __webpack_require__(28);








function LocationIndexedLine() {
	this._linearGeom = null;
	let linearGeom = arguments[0];
	this._linearGeom = linearGeom;
	this.checkGeometryType();
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(LocationIndexedLine.prototype, {
	clampIndex: function (index) {
		var loc = index.clone();
		loc.clamp(this._linearGeom);
		return loc;
	},
	project: function (pt) {
		return __WEBPACK_IMPORTED_MODULE_4__LocationIndexOfPoint__["a" /* default */].indexOf(this._linearGeom, pt);
	},
	checkGeometryType: function () {
		if (!(this._linearGeom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */] || this._linearGeom instanceof __WEBPACK_IMPORTED_MODULE_7__geom_MultiLineString__["a" /* default */])) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Input geometry must be linear");
	},
	extractPoint: function () {
		if (arguments.length === 1) {
			let index = arguments[0];
			return index.getCoordinate(this._linearGeom);
		} else if (arguments.length === 2) {
			let index = arguments[0], offsetDistance = arguments[1];
			var indexLow = index.toLowest(this._linearGeom);
			return indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);
		}
	},
	isValidIndex: function (index) {
		return index.isValid(this._linearGeom);
	},
	getEndIndex: function () {
		return __WEBPACK_IMPORTED_MODULE_2__LinearLocation__["a" /* default */].getEndLocation(this._linearGeom);
	},
	getStartIndex: function () {
		return new __WEBPACK_IMPORTED_MODULE_2__LinearLocation__["a" /* default */]();
	},
	indexOfAfter: function (pt, minIndex) {
		return __WEBPACK_IMPORTED_MODULE_4__LocationIndexOfPoint__["a" /* default */].indexOfAfter(this._linearGeom, pt, minIndex);
	},
	extractLine: function (startIndex, endIndex) {
		return __WEBPACK_IMPORTED_MODULE_6__ExtractLineByLocation__["a" /* default */].extract(this._linearGeom, startIndex, endIndex);
	},
	indexOf: function (pt) {
		return __WEBPACK_IMPORTED_MODULE_4__LocationIndexOfPoint__["a" /* default */].indexOf(this._linearGeom, pt);
	},
	indicesOf: function (subLine) {
		return __WEBPACK_IMPORTED_MODULE_5__LocationIndexOfLine__["a" /* default */].indicesOf(this._linearGeom, subLine);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LocationIndexedLine;
	}
});


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LocationIndexOfPoint;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LinearIterator__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LinearLocation__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_Assert__ = __webpack_require__(4);






function LocationIndexOfPoint() {
	this._linearGeom = null;
	let linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(LocationIndexOfPoint.prototype, {
	indexOf: function (inputPt) {
		return this.indexOfFromStart(inputPt, null);
	},
	indexOfFromStart: function (inputPt, minIndex) {
		var minDistance = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE;
		var minComponentIndex = 0;
		var minSegmentIndex = 0;
		var minFrac = -1.0;
		var seg = new __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__["a" /* default */]();
		for (var it = new __WEBPACK_IMPORTED_MODULE_0__LinearIterator__["a" /* default */](this._linearGeom); it.hasNext(); it.next()) {
			if (!it.isEndOfLine()) {
				seg.p0 = it.getSegmentStart();
				seg.p1 = it.getSegmentEnd();
				var segDistance = seg.distance(inputPt);
				var segFrac = seg.segmentFraction(inputPt);
				var candidateComponentIndex = it.getComponentIndex();
				var candidateSegmentIndex = it.getVertexIndex();
				if (segDistance < minDistance) {
					if (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {
						minComponentIndex = candidateComponentIndex;
						minSegmentIndex = candidateSegmentIndex;
						minFrac = segFrac;
						minDistance = segDistance;
					}
				}
			}
		}
		if (minDistance === __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE) {
			return new __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */](minIndex);
		}
		var loc = new __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */](minComponentIndex, minSegmentIndex, minFrac);
		return loc;
	},
	indexOfAfter: function (inputPt, minIndex) {
		if (minIndex === null) return this.indexOf(inputPt);
		var endLoc = __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */].getEndLocation(this._linearGeom);
		if (endLoc.compareTo(minIndex) <= 0) return endLoc;
		var closestAfter = this.indexOfFromStart(inputPt, minIndex);
		__WEBPACK_IMPORTED_MODULE_5__util_Assert__["a" /* default */].isTrue(closestAfter.compareTo(minIndex) >= 0, "computed location is before specified minimum location");
		return closestAfter;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LocationIndexOfPoint;
	}
});
LocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {
	var locater = new LocationIndexOfPoint(linearGeom);
	return locater.indexOf(inputPt);
};
LocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {
	var locater = new LocationIndexOfPoint(linearGeom);
	return locater.indexOfAfter(inputPt, minIndex);
};


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LocationIndexOfLine;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LocationIndexOfPoint__ = __webpack_require__(170);


function LocationIndexOfLine() {
	this._linearGeom = null;
	let linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(LocationIndexOfLine.prototype, {
	indicesOf: function (subLine) {
		var startPt = subLine.getGeometryN(0).getCoordinateN(0);
		var lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);
		var endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);
		var locPt = new __WEBPACK_IMPORTED_MODULE_1__LocationIndexOfPoint__["a" /* default */](this._linearGeom);
		var subLineLoc = new Array(2).fill(null);
		subLineLoc[0] = locPt.indexOf(startPt);
		if (subLine.getLength() === 0.0) {
			subLineLoc[1] = subLineLoc[0].clone();
		} else {
			subLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);
		}
		return subLineLoc;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LocationIndexOfLine;
	}
});
LocationIndexOfLine.indicesOf = function (linearGeom, subLine) {
	var locater = new LocationIndexOfLine(linearGeom);
	return locater.indicesOf(subLine);
};


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ExtractLineByLocation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LinearIterator__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__LinearGeometryBuilder__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_MultiLineString__ = __webpack_require__(28);







function ExtractLineByLocation() {
	this._line = null;
	let line = arguments[0];
	this._line = line;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(ExtractLineByLocation.prototype, {
	computeLinear: function (start, end) {
		var builder = new __WEBPACK_IMPORTED_MODULE_5__LinearGeometryBuilder__["a" /* default */](this._line.getFactory());
		builder.setFixInvalidLines(true);
		if (!start.isVertex()) builder.add(start.getCoordinate(this._line));
		for (var it = new __WEBPACK_IMPORTED_MODULE_2__LinearIterator__["a" /* default */](this._line, start); it.hasNext(); it.next()) {
			if (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;
			var pt = it.getSegmentStart();
			builder.add(pt);
			if (it.isEndOfLine()) builder.endLine();
		}
		if (!end.isVertex()) builder.add(end.getCoordinate(this._line));
		return builder.getGeometry();
	},
	computeLine: function (start, end) {
		var coordinates = this._line.getCoordinates();
		var newCoordinates = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
		var startSegmentIndex = start.getSegmentIndex();
		if (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;
		var lastSegmentIndex = end.getSegmentIndex();
		if (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;
		if (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;
		if (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));
		for (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {
			newCoordinates.add(coordinates[i]);
		}
		if (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));
		if (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));
		var newCoordinateArray = newCoordinates.toCoordinateArray();
		if (newCoordinateArray.length <= 1) {
			newCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];
		}
		return this._line.getFactory().createLineString(newCoordinateArray);
	},
	extract: function (start, end) {
		if (end.compareTo(start) < 0) {
			return this.reverse(this.computeLinear(end, start));
		}
		return this.computeLinear(start, end);
	},
	reverse: function (linear) {
		if (linear instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) return linear.reverse();
		if (linear instanceof __WEBPACK_IMPORTED_MODULE_6__geom_MultiLineString__["a" /* default */]) return linear.reverse();
		__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].shouldNeverReachHere("non-linear geometry encountered");
		return null;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ExtractLineByLocation;
	}
});
ExtractLineByLocation.extract = function (line, start, end) {
	var ls = new ExtractLineByLocation(line);
	return ls.extract(start, end);
};


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LinearGeometryBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function LinearGeometryBuilder() {
	this._geomFact = null;
	this._lines = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
	this._coordList = null;
	this._ignoreInvalidLines = false;
	this._fixInvalidLines = false;
	this._lastPt = null;
	let geomFact = arguments[0];
	this._geomFact = geomFact;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LinearGeometryBuilder.prototype, {
	getGeometry: function () {
		this.endLine();
		return this._geomFact.buildGeometry(this._lines);
	},
	getLastCoordinate: function () {
		return this._lastPt;
	},
	endLine: function () {
		if (this._coordList === null) {
			return null;
		}
		if (this._ignoreInvalidLines && this._coordList.size() < 2) {
			this._coordList = null;
			return null;
		}
		var rawPts = this._coordList.toCoordinateArray();
		var pts = rawPts;
		if (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);
		this._coordList = null;
		var line = null;
		try {
			line = this._geomFact.createLineString(pts);
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]) {
				if (!this._ignoreInvalidLines) throw ex;
			} else throw ex;
		} finally {}
		if (line !== null) this._lines.add(line);
	},
	setFixInvalidLines: function (fixInvalidLines) {
		this._fixInvalidLines = fixInvalidLines;
	},
	add: function () {
		if (arguments.length === 1) {
			let pt = arguments[0];
			this.add(pt, true);
		} else if (arguments.length === 2) {
			let pt = arguments[0], allowRepeatedPoints = arguments[1];
			if (this._coordList === null) this._coordList = new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */]();
			this._coordList.add(pt, allowRepeatedPoints);
			this._lastPt = pt;
		}
	},
	setIgnoreInvalidLines: function (ignoreInvalidLines) {
		this._ignoreInvalidLines = ignoreInvalidLines;
	},
	validCoordinateSequence: function (pts) {
		if (pts.length >= 2) return pts;
		var validPts = [pts[0], pts[0]];
		return validPts;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LinearGeometryBuilder;
	}
});


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LengthLocationMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LinearIterator__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LinearLocation__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);



function LengthLocationMap() {
	this._linearGeom = null;
	let linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LengthLocationMap.prototype, {
	getLength: function (loc) {
		var totalLength = 0.0;
		var it = new __WEBPACK_IMPORTED_MODULE_0__LinearIterator__["a" /* default */](this._linearGeom);
		while (it.hasNext()) {
			if (!it.isEndOfLine()) {
				var p0 = it.getSegmentStart();
				var p1 = it.getSegmentEnd();
				var segLen = p1.distance(p0);
				if (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {
					return totalLength + segLen * loc.getSegmentFraction();
				}
				totalLength += segLen;
			}
			it.next();
		}
		return totalLength;
	},
	resolveHigher: function (loc) {
		if (!loc.isEndpoint(this._linearGeom)) return loc;
		var compIndex = loc.getComponentIndex();
		if (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;
		do {
			compIndex++;
		} while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);
		return new __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */](compIndex, 0, 0.0);
	},
	getLocation: function () {
		if (arguments.length === 1) {
			let length = arguments[0];
			return this.getLocation(length, true);
		} else if (arguments.length === 2) {
			let length = arguments[0], resolveLower = arguments[1];
			var forwardLength = length;
			if (length < 0.0) {
				var lineLen = this._linearGeom.getLength();
				forwardLength = lineLen + length;
			}
			var loc = this.getLocationForward(forwardLength);
			if (resolveLower) {
				return loc;
			}
			return this.resolveHigher(loc);
		}
	},
	getLocationForward: function (length) {
		if (length <= 0.0) return new __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */]();
		var totalLength = 0.0;
		var it = new __WEBPACK_IMPORTED_MODULE_0__LinearIterator__["a" /* default */](this._linearGeom);
		while (it.hasNext()) {
			if (it.isEndOfLine()) {
				if (totalLength === length) {
					var compIndex = it.getComponentIndex();
					var segIndex = it.getVertexIndex();
					return new __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */](compIndex, segIndex, 0.0);
				}
			} else {
				var p0 = it.getSegmentStart();
				var p1 = it.getSegmentEnd();
				var segLen = p1.distance(p0);
				if (totalLength + segLen > length) {
					var frac = (length - totalLength) / segLen;
					var compIndex = it.getComponentIndex();
					var segIndex = it.getVertexIndex();
					return new __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */](compIndex, segIndex, frac);
				}
				totalLength += segLen;
			}
			it.next();
		}
		return __WEBPACK_IMPORTED_MODULE_1__LinearLocation__["a" /* default */].getEndLocation(this._linearGeom);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LengthLocationMap;
	}
});
LengthLocationMap.getLength = function (linearGeom, loc) {
	var locater = new LengthLocationMap(linearGeom);
	return locater.getLength(loc);
};
LengthLocationMap.getLocation = function () {
	if (arguments.length === 2) {
		let linearGeom = arguments[0], length = arguments[1];
		var locater = new LengthLocationMap(linearGeom);
		return locater.getLocation(length);
	} else if (arguments.length === 3) {
		let linearGeom = arguments[0], length = arguments[1], resolveLower = arguments[2];
		var locater = new LengthLocationMap(linearGeom);
		return locater.getLocation(length, resolveLower);
	}
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(176);
__webpack_require__(384);
module.exports = __webpack_require__(387);


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var L, _, booleanPointOnLine, turf, turfBooleanOverlap, turfMeta, turfUnion,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

L = __webpack_require__(110);

_ = __webpack_require__(177);

turf = __webpack_require__(70);

turfMeta = __webpack_require__(178);

turfBooleanOverlap = __webpack_require__(179);

turfUnion = __webpack_require__(203);

booleanPointOnLine = __webpack_require__(381);

__webpack_require__(383);

L.Merging = {};

L.Merging = {};

L.Merging.Event = {};

L.Merging.Event.START = "merge:start";

L.Merging.Event.STOP = "merge:stop";

L.Merging.Event.SELECT = "merge:select";

L.Merging.Event.UNSELECT = "merge:unselect";

L.Merging.Event.MERGED = "merge:merged";

L.Merge = (function(superClass) {
  extend(Merge, superClass);

  Merge.TYPE = 'merge';

  function Merge(map, options) {
    this.type = this.constructor.TYPE;
    this._map = map;
    Merge.__super__.constructor.call(this, map);
    this.options = _.merge(this.options, options);
    this._featureGroup = options.featureGroup;
    this._availableLayers = new L.FeatureGroup;
    this._activeLayer = void 0;
    this._uneditedLayerProps = [];
    if (!(this._featureGroup instanceof L.FeatureGroup)) {
      throw new Error('options.featureGroup must be a L.FeatureGroup');
    }
  }

  Merge.prototype.enable = function() {
    var poly, poly2;
    if (this._enabled || !this._featureGroup.getLayers().length) {
      return;
    }
    this.fire('enabled', {
      handler: this.type
    });
    this._map.fire(L.Merging.Event.START, {
      handler: this.type
    });
    Merge.__super__.enable.apply(this, arguments);
    this._availableLayers.on('layeradd', this._enableLayer, this);
    this._availableLayers.on('layerremove', this._disableLayer, this);
    this._featureGroup.on('layeradd', this.refreshAvailableLayers, this);
    this._featureGroup.on('layerremove', this.refreshAvailableLayers, this);
    poly = new L.Polygon([[[45.824114, -0.796735], [45.824244, -0.796029], [45.824409, -0.795145], [45.824509, -0.794611], [45.824811, -0.795321], [45.824579, -0.79664], [45.824114, -0.796735]]]);
    this._featureGroup.addData(poly.toGeoJSON());
    poly2 = new L.Polygon([[[45.824483, -0.794565], [45.824308, -0.794476], [45.82399, -0.794315], [45.82394, -0.79429], [45.823719, -0.794154], [45.82434, -0.793379], [45.824728, -0.793706], [45.824483, -0.794565]]]);
    this._featureGroup.addData(poly2.toGeoJSON());
    this._map.on(L.Merging.Event.SELECT, this._mergeMode, this);
    return this._map.on('zoomend moveend', (function(_this) {
      return function() {
        return _this.refreshAvailableLayers();
      };
    })(this));
  };

  Merge.prototype.disable = function() {
    if (!this._enabled) {
      return;
    }
    this._availableLayers.off('layeradd', this._enableLayer, this);
    this._availableLayers.off('layerremove', this._disableLayer, this);
    Merge.__super__.disable.apply(this, arguments);
    this._map.fire(L.Merging.Event.STOP, {
      handler: this.type
    });
    this._map.off(L.Merging.Event.SELECT, this._startCutDrawing, this);
    this.fire('disabled', {
      handler: this.type
    });
  };

  Merge.prototype.addHooks = function() {
    this.refreshAvailableLayers();
    return this._availableLayers.eachLayer(this._enableLayer, this);
  };

  Merge.prototype.refreshAvailableLayers = function() {
    var addList, l, len, len1, m, n, newLayers, removeList, results;
    if (!this._featureGroup.getLayers().length) {
      return;
    }
    if (typeof this._featureGroup.search === 'function') {
      newLayers = new L.LayerGroup(this._featureGroup.search(this._map.getBounds()));
      removeList = this._availableLayers.getLayers().filter(function(layer) {
        return !newLayers.hasLayer(layer);
      });
      if (removeList.length) {
        for (m = 0, len = removeList.length; m < len; m++) {
          l = removeList[m];
          this._availableLayers.removeLayer(l);
        }
      }
      addList = newLayers.getLayers().filter((function(_this) {
        return function(layer) {
          return !_this._availableLayers.hasLayer(layer);
        };
      })(this));
      if (addList.length) {
        results = [];
        for (n = 0, len1 = addList.length; n < len1; n++) {
          l = addList[n];
          results.push(this._availableLayers.addLayer(l));
        }
        return results;
      }
    } else {
      return this._availableLayers = this._featureGroup;
    }
  };

  Merge.prototype.removeHooks = function() {
    return this._featureGroup.eachLayer(this._disableLayer, this);
  };

  Merge.prototype.save = function() {
    this._featureGroup.eachLayer((function(_this) {
      return function(l) {
        return _this._map.removeLayer(l);
      };
    })(this));
    this._featureGroup.addLayer(this._activeLayer._poly);
    this._featureGroup.addTo(this._map);
    delete this._activeLayer._poly;
    delete this._activeLayer;
  };

  Merge.prototype._enableLayer = function(e) {
    var layer, pathOptions;
    layer = e.layer || e.target || e;
    layer.options.original = L.extend({}, layer.options);
    if (this.options.disabledPathOptions) {
      pathOptions = L.Util.extend({}, this.options.disabledPathOptions);
      if (pathOptions.maintainColor) {
        pathOptions.color = layer.options.color;
        pathOptions.fillColor = layer.options.fillColor;
      }
      layer.options.disabled = pathOptions;
    }
    if (this.options.selectedPathOptions) {
      pathOptions = L.Util.extend({}, this.options.selectedPathOptions);
      if (pathOptions.maintainColor) {
        pathOptions.color = layer.options.color;
        pathOptions.fillColor = layer.options.fillColor;
      }
      layer.options.selected = pathOptions;
    }
    layer.setStyle(layer.options.disabled);
    layer.bindPopup("stamp" + L.stamp(layer));
    return layer.on('click', this._activate, this);
  };

  Merge.prototype._unselectLayer = function(e) {
    var layer;
    layer = e.layer || e.target || e;
    layer.selected = false;
    if (this.options.selectedPathOptions) {
      layer.setStyle(layer.options.disabled);
    }
    return this._activeLayer = null;
  };

  Merge.prototype._disableLayer = function(e) {
    var layer;
    layer = e.layer || e.target || e;
    layer.selected = false;
    if (this.options.selectedPathOptions) {
      layer.setStyle(layer.options.original);
    }
    delete layer.options.disabled;
    delete layer.options.selected;
    return delete layer.options.original;
  };

  Merge.prototype._activate = function(e) {
    var layer;
    layer = e.target || e.layer || e;
    if (!layer.selected) {
      layer.selected = true;
      layer.setStyle(layer.options.selected);
      if (this._activeLayer) {
        this._unselectLayer(this._activeLayer);
      }
      this._activeLayer = layer;
      return this._map.fire(L.Merging.Event.SELECT, {
        layer: this._activeLayer
      });
    } else {
      layer.selected = false;
      layer.setStyle(layer.options.disabled);
      this._activeLayer = null;
      return this._map.fire(L.Merging.Event.UNSELECT, {
        layer: layer
      });
    }
  };

  Merge.prototype._mergeMode = function() {
    var i, k;
    i = 0;
    k = 0;
    return this._availableLayers.eachLayer((function(_this) {
      return function(layer) {
        var activePoly, closest, coord, coord2, j, len, m, outerRing, overlap, point, poly3, pt, ref, turfCoords, turfLayer, turfPoly, union;
        if (L.stamp(layer) !== L.stamp(_this._activeLayer) && k === 0) {
          console.error("try:", L.stamp(layer));
          activePoly = _this._activeLayer.toTurfFeature();
          turfLayer = layer.toTurfFeature();
          console.error(activePoly, turfLayer);
          overlap = turfBooleanOverlap(activePoly, turfLayer);
          console.error(overlap);
          if (overlap) {
            console.error(turfLayer.geometry.coordinates);
            outerRing = _this._activeLayer.outerRingAsTurfLineString();
            j = 0;
            turfCoords = [];
            ref = turfLayer.geometry.coordinates[0];
            for (m = 0, len = ref.length; m < len; m++) {
              coord = ref[m];
              closest = void 0;
              coord2 = void 0;
              if (j === 1 || j === 2) {
                closest = L.GeometryUtil.closest(_this._map, _this._activeLayer, L.latLng(coord[1], coord[0]));
                console.error("closest:", closest);
              }
              if (closest) {
                coord2 = [closest.lng, closest.lat];
                console.error('prev: ', coord, 'next:', coord2);
                console.error('retest', L.GeometryUtil.closest(_this._map, _this._activeLayer, L.latLng(coord2[1], coord2[0])));
              }
              if (coord2) {
                point = turf.point(coord2);
                pt = L.latLng(coord2[1], coord2[0]);
                turfCoords.push(coord2);
              } else {
                point = turf.point(coord);
                pt = L.latLng(coord[1], coord[0]);
                turfCoords.push(coord);
              }
              console.error(point);
              L.marker(pt).addTo(_this._map);
              console.error('on the line:', booleanPointOnLine["default"](point, outerRing));
              j++;
            }
            turfPoly = turf.polygon([turfCoords]);
            console.error(turfPoly);
            union = turfUnion["default"](activePoly, turfPoly);
            poly3 = new L.Polygon([], {
              color: 'red'
            });
            console.error(union);
            poly3.fromTurfFeature(union);
            poly3.addTo(_this._map);
            k = 1;
          }
          return i++;
        }
      };
    })(this));
  };

  Merge.prototype._merge = (function() {});

  Merge.prototype._hasAvailableLayers = function() {
    return this._availableLayers.getLayers().length !== 0;
  };

  return Merge;

})(L.Handler);

L.Merge.include(L.Mixin.Events);


/***/ }),
/* 177 */
/***/ (function(module, exports) {

module.exports = _;

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_helpers__ = __webpack_require__(70);


/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} featureProperties The current feature properties being processed.
 * @param {Array<number>} featureBBox The current feature BBox being processed.
 * @param {number|string} featureId The current feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
            (isFeature ? geojson.bbox : undefined));
        featureId = (isFeatureCollection ? geojson.features[i].id :
            (isFeature ? geojson.id : undefined));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, featureProperties, featureBBox, featureId);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, featureProperties, featureBBox, featureId);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["feature"])(geometry, properties, bbox, id), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["feature"])(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The feature index of the current element being processed in the array, starts at index 0.
 * @param {number} featureSubIndex The feature sub-index of the current line being processed at index 0
 * @param {number} lineIndex The current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, featureSubIndex, lineIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, featureSubIndex, lineIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=featureSubIndex
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');

    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
        case 'LineString':
            callback(feature, featureIndex, featureSubIndex, 0);
            break;
        case 'Polygon':
            for (var lineIndex = 0; lineIndex < coords.length; lineIndex++) {
                callback(Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])(coords[lineIndex], feature.properties), featureIndex, featureSubIndex, lineIndex);
            }
            break;
        }
    });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The feature index of the current element being processed in the array, starts at index 0.
 * @param {number} featureSubIndex The feature sub-index of the current line being processed at index 0
 * @param {number} lineIndex The current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, featureIndex, featureSubIndex, lineIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=featureSubIndex
 *   //=lineIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, featureIndex, featureSubIndex, lineIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, featureSubIndex, lineIndex);
    });
    return previousValue;
}


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var meta = __webpack_require__(180);
var invariant = __webpack_require__(32);
var lineOverlap = __webpack_require__(181);
var lineIntersect = __webpack_require__(114);
var GeojsonEquality = __webpack_require__(202);
var coordAll = meta.coordAll;
var segmentEach = meta.segmentEach;
var getGeomType = invariant.getGeomType;

/**
 * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry
 * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,
 * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.
 *
 * @name booleanOverlap
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input
 * @returns {boolean} true/false
 * @example
 * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);
 * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);
 * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);
 *
 * turf.booleanOverlap(poly1, poly2)
 * //=true
 * turf.booleanOverlap(poly2, poly3)
 * //=false
 */
module.exports = function (feature1, feature2) {
    // validation
    if (!feature1) throw new Error('feature1 is required');
    if (!feature2) throw new Error('feature2 is required');
    var type1 = getGeomType(feature1);
    var type2 = getGeomType(feature2);
    if (type1 !== type2) throw new Error('features must be of the same type');
    if (type1 === 'Point') throw new Error('Point geometry not supported');

    // features must be not equal
    var equality = new GeojsonEquality({precision: 6});
    if (equality.compare(feature1, feature2)) return false;

    var overlap = 0;

    switch (type1) {
    case 'MultiPoint':
        var coords1 = coordAll(feature1);
        var coords2 = coordAll(feature2);
        coords1.forEach(function (coord1) {
            coords2.forEach(function (coord2) {
                if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) overlap++;
            });
        });
        break;

    case 'LineString':
    case 'MultiLineString':
        segmentEach(feature1, function (segment1) {
            segmentEach(feature2, function (segment2) {
                if (lineOverlap(segment1, segment2).features.length) overlap++;
            });
        });
        break;

    case 'Polygon':
    case 'MultiPolygon':
        segmentEach(feature1, function (segment1) {
            segmentEach(feature2, function (segment2) {
                if (lineIntersect(segment1, segment2).features.length) overlap++;
            });
        });
        break;
    }

    return overlap > 0;
};


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var meta = __webpack_require__(182);
var equal = __webpack_require__(111);
var rbush = __webpack_require__(112);
var invariant = __webpack_require__(32);
var lineSegment = __webpack_require__(113);
var pointOnLine = __webpack_require__(190);
var booleanPointOnLine = __webpack_require__(200);
var featureCollection = __webpack_require__(201).featureCollection;
var getCoords = invariant.getCoords;
var featureEach = meta.featureEach;
var segmentEach = meta.segmentEach;

/**
 * Takes any LineString or Polygon and returns the overlapping lines between both features.
 *
 * @name lineOverlap
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @param {number} [tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)
 * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features
 * @example
 * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);
 * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);
 *
 * var overlapping = turf.lineOverlap(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, overlapping]
 */
module.exports = function (line1, line2, tolerance) {
    var features = [];
    tolerance = tolerance || 0;

    // Create Spatial Index
    var tree = rbush();
    tree.load(lineSegment(line1));
    var overlapSegment;

    // Line Intersection

    // Iterate over line segments
    segmentEach(line2, function (segment) {
        var doesOverlaps = false;

        // Iterate over each segments which falls within the same bounds
        featureEach(tree.search(segment), function (match) {
            if (doesOverlaps === false) {
                var coordsSegment = getCoords(segment).sort();
                var coordsMatch = getCoords(match).sort();

                // Segment overlaps feature
                if (equal(coordsSegment, coordsMatch)) {
                    doesOverlaps = true;
                    // Overlaps already exists - only append last coordinate of segment
                    if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);
                    else overlapSegment = segment;
                // Match segments which don't share nodes (Issue #901)
                } else if (
                    (tolerance === 0) ?
                        booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) :
                        pointOnLine(match, coordsSegment[0]).properties.dist <= tolerance &&
                        pointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {
                    doesOverlaps = true;
                    if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);
                    else overlapSegment = segment;
                } else if (
                    (tolerance === 0) ?
                        booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) :
                        pointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance &&
                        pointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {
                    // Do not define (doesOverlap = true) since more matches can occur within the same segment
                    // doesOverlaps = true;
                    if (overlapSegment) overlapSegment = concatSegment(overlapSegment, match);
                    else overlapSegment = match;
                }
            }
        });

        // Segment doesn't overlap - add overlaps to results & reset
        if (doesOverlaps === false && overlapSegment) {
            features.push(overlapSegment);
            overlapSegment = undefined;
        }
    });
    // Add last segment if exists
    if (overlapSegment) features.push(overlapSegment);

    return featureCollection(features);
};


/**
 * Concat Segment
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<LineString>} segment 2-vertex LineString
 * @returns {Feature<LineString>} concat linestring
 */
function concatSegment(line, segment) {
    var coords = getCoords(segment);
    var lineCoords = getCoords(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];
    var geom = line.geometry.coordinates;

    if (equal(coords[0], start)) geom.unshift(coords[1]);
    else if (equal(coords[0], end)) geom.push(coords[1]);
    else if (equal(coords[1], start)) geom.unshift(coords[0]);
    else if (equal(coords[1], end)) geom.push(coords[0]);
    return line;
}


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 183 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 184 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;

var quickselect = __webpack_require__(186);

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 188 */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    centimeters: 6.373e+8,
    centimetres: 6.373e+8,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

var areaFactors = {
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    centimetres: 10000,
    millimeter: 1000000,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}


/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit=meters] of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

module.exports = {
    feature: feature,
    geometry: geometry,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees,
    radians2degrees: radians2degrees,
    degrees2radians: degrees2radians,
    bearingToAngle: bearingToAngle,
    convertDistance: convertDistance,
    convertArea: convertArea,
    round: round,
    isNumber: isNumber
};


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var meta = __webpack_require__(191);
var helpers = __webpack_require__(192);
var bearing = __webpack_require__(193);
var distance = __webpack_require__(194);
var invariant = __webpack_require__(32);
var destination = __webpack_require__(196);
var lineIntersects = __webpack_require__(114);
var point = helpers.point;
var getCoords = invariant.getCoords;
var lineString = helpers.lineString;
var flattenEach = meta.flattenEach;

/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
 *
 * @name pointOnLine
 * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
 * @param {Geometry|Feature<Point>|number[]} pt point to snap from
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
 * @example
 * var line = turf.lineString([
 *     [-77.031669, 38.878605],
 *     [-77.029609, 38.881946],
 *     [-77.020339, 38.884084],
 *     [-77.025661, 38.885821],
 *     [-77.021884, 38.889563],
 *     [-77.019824, 38.892368]
 * ]);
 * var pt = turf.point([-77.037076, 38.884017]);
 *
 * var snapped = turf.pointOnLine(line, pt, 'miles');
 *
 * //addToMap
 * var addToMap = [line, pt, snapped];
 * snapped.properties['marker-color'] = '#00f';
 */
module.exports = function (lines, pt, units) {
    // validation
    var type = (lines.geometry) ? lines.geometry.type : lines.type;
    if (type !== 'LineString' && type !== 'MultiLineString') {
        throw new Error('lines must be LineString or MultiLineString');
    }

    var closestPt = point([Infinity, Infinity], {
        dist: Infinity
    });

    var length = 0.0;
    flattenEach(lines, function (line) {
        var coords = getCoords(line);

        for (var i = 0; i < coords.length - 1; i++) {
            //start
            var start = point(coords[i]);
            start.properties.dist = distance(pt, start, units);
            //stop
            var stop = point(coords[i + 1]);
            stop.properties.dist = distance(pt, stop, units);
            // sectionLength
            var sectionLength = distance(start, stop, units);
            //perpendicular
            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
            var direction = bearing(start, stop);
            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);
            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);
            var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));
            var intersectPt = null;
            if (intersect.features.length > 0) {
                intersectPt = intersect.features[0];
                intersectPt.properties.dist = distance(pt, intersectPt, units);
                intersectPt.properties.location = length + distance(start, intersectPt, units);
            }

            if (start.properties.dist < closestPt.properties.dist) {
                closestPt = start;
                closestPt.properties.index = i;
                closestPt.properties.location = length;
            }
            if (stop.properties.dist < closestPt.properties.dist) {
                closestPt = stop;
                closestPt.properties.index = i + 1;
                closestPt.properties.location = length + sectionLength;
            }
            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
                closestPt = intersectPt;
                closestPt.properties.index = i;
            }
            // update length
            length += sectionLength;
        }

    });

    return closestPt;
};


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 192 */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    centimeters: 6.373e+8,
    centimetres: 6.373e+8,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

var areaFactors = {
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    centimetres: 10000,
    millimeter: 1000000,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}


/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit=meters] of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

module.exports = {
    feature: feature,
    geometry: geometry,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees,
    radians2degrees: radians2degrees,
    degrees2radians: degrees2radians,
    bearingToAngle: bearingToAngle,
    convertDistance: convertDistance,
    convertArea: convertArea,
    round: round,
    isNumber: isNumber
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var getCoord = __webpack_require__(32).getCoord;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point|points} and finds the geographic bearing between them,
 * i.e. the angle measured in degrees from the north line (0 degrees)
 *
 * @name bearing
 * @param {Geometry|Feature<Point>|Array<number>} start starting Point
 * @param {Geometry|Feature<Point>|Array<number>} end ending Point
 * @param {boolean} [final=false] calculates the final bearing if true
 * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
 * @example
 * var point1 = turf.point([-75.343, 39.984]);
 * var point2 = turf.point([-75.534, 39.123]);
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2]
 * point1.properties['marker-color'] = '#f00'
 * point2.properties['marker-color'] = '#0f0'
 * point1.properties.bearing = bearing
 */
function bearing(start, end, final) {
    if (final === true) return calculateFinalBearing(start, end);

    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(start);
    var coordinates2 = getCoord(end);

    var lon1 = degrees2radians * coordinates1[0];
    var lon2 = degrees2radians * coordinates2[0];
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

    var bear = radians2degrees * Math.atan2(a, b);

    return bear;
}

/**
 * Calculates Final Bearing
 * @private
 * @param {Feature<Point>} start starting Point
 * @param {Feature<Point>} end ending Point
 * @returns {number} bearing
 */
function calculateFinalBearing(start, end) {
    // Swap start & end
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}

module.exports = bearing;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var getCoord = __webpack_require__(32).getCoord;
var radiansToDistance = __webpack_require__(195).radiansToDistance;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Calculates the distance between two {@link Point|points} in degrees, radians,
 * miles, or kilometers. This uses the
 * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
 * to account for global curvature.
 *
 * @name distance
 * @param {Geometry|Feature<Point>|Array<number>} from origin point
 * @param {Geometry|Feature<Point>|Array<number>} to destination point
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 *
 * var distance = turf.distance(from, to, "miles");
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
module.exports = function (from, to, units) {
    var degrees2radians = Math.PI / 180;
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);
    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];

    var a = Math.pow(Math.sin(dLat / 2), 2) +
          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
};


/***/ }),
/* 195 */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    centimeters: 6.373e+8,
    centimetres: 6.373e+8,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

var areaFactors = {
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    centimetres: 10000,
    millimeter: 1000000,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}


/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit=meters] of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

module.exports = {
    feature: feature,
    geometry: geometry,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees,
    radians2degrees: radians2degrees,
    degrees2radians: degrees2radians,
    bearingToAngle: bearingToAngle,
    convertDistance: convertDistance,
    convertArea: convertArea,
    round: round,
    isNumber: isNumber
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
var getCoord = __webpack_require__(32).getCoord;
var helpers = __webpack_require__(197);
var point = helpers.point;
var distanceToRadians = helpers.distanceToRadians;

/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Geometry|Feature<Point>|Array<number>} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {string} [units=kilometers] miles, kilometers, degrees, or radians
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var units = 'miles';
 *
 * var destination = turf.destination(point, distance, bearing, units);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */
module.exports = function (origin, distance, bearing, units) {
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(origin);
    var longitude1 = degrees2radians * coordinates1[0];
    var latitude1 = degrees2radians * coordinates1[1];
    var bearing_rad = degrees2radians * bearing;

    var radians = distanceToRadians(distance, units);

    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),
        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));

    return point([radians2degrees * longitude2, radians2degrees * latitude2]);
};


/***/ }),
/* 197 */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    centimeters: 6.373e+8,
    centimetres: 6.373e+8,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

var areaFactors = {
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    centimetres: 10000,
    millimeter: 1000000,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}


/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit=meters] of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

module.exports = {
    feature: feature,
    geometry: geometry,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees,
    radians2degrees: radians2degrees,
    degrees2radians: degrees2radians,
    bearingToAngle: bearingToAngle,
    convertDistance: convertDistance,
    convertArea: convertArea,
    round: round,
    isNumber: isNumber
};


/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 199 */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    centimeters: 6.373e+8,
    centimetres: 6.373e+8,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

var areaFactors = {
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    centimetres: 10000,
    millimeter: 1000000,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}


/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit=meters] of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

module.exports = {
    feature: feature,
    geometry: geometry,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees,
    radians2degrees: radians2degrees,
    degrees2radians: degrees2radians,
    bearingToAngle: bearingToAngle,
    convertDistance: convertDistance,
    convertArea: convertArea,
    round: round,
    isNumber: isNumber
};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var getCoords = __webpack_require__(32).getCoords;

/**
 * Returns true if a point is on a line. Accepts a optional parameter to ignore the start and end vertices of the linestring.
 *
 * @name booleanPointOnLine
 * @param {Geometry|Feature<Point>} point GeoJSON Feature or Geometry
 * @param {Geometry|Feature<LineString>} linestring GeoJSON Feature or Geometry
 * @param {boolean} [ignoreEndVertices=false] whether to ignore the start and end vertices.
 * @returns {boolean} true/false
 * @example
 * var pt = turf.point([0, 0]);
 * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
 * var isPointOnLine = turf.booleanPointOnLine(pt, line);
 * //=true
 */
module.exports = function (point, linestring, ignoreEndVertices) {
    var pointCoords = getCoords(point);
    var lineCoords = getCoords(linestring);
    for (var i = 0; i < lineCoords.length - 1; i++) {
        var ignoreBoundary = false;
        if (ignoreEndVertices) {
            if (i === 0) ignoreBoundary = 'start';
            if (i === lineCoords.length - 2) ignoreBoundary = 'end';
            if (i === 0 && i + 1 === lineCoords.length - 1) ignoreBoundary = 'both';
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], pointCoords, ignoreBoundary)) return true;
    }
    return false;
};

// See http://stackoverflow.com/a/4833823/1979085
/**
 * @private
 * @param {Array<number>} lineSegmentStart coord pair of start of line
 * @param {Array<number>} lineSegmentEnd coord pair of end of line
 * @param {Array<number>} point coord pair of point to check
 * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends. If true which end to ignore.
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, point, excludeBoundary) {
    var dxc = point[0] - lineSegmentStart[0];
    var dyc = point[1] - lineSegmentStart[1];
    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] <= point[0] && point[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= point[0] && point[0] <= lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] <= point[1] && point[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= point[1] && point[1] <= lineSegmentStart[1];
    } else if (excludeBoundary === 'start') {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] < point[0] && point[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= point[0] && point[0] < lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] < point[1] && point[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= point[1] && point[1] < lineSegmentStart[1];
    } else if (excludeBoundary === 'end') {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] <= point[0] && point[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < point[0] && point[0] <= lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] <= point[1] && point[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < point[1] && point[1] <= lineSegmentStart[1];
    } else if (excludeBoundary === 'both') {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] < point[0] && point[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < point[0] && point[0] < lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] < point[1] && point[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < point[1] && point[1] < lineSegmentStart[1];
    }
}


/***/ }),
/* 201 */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties, bbox, id) {
    if (geometry === undefined) throw new Error('geometry is required');
    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var feat = {type: 'Feature'};
    if (id) feat.id = id;
    if (bbox) feat.bbox = bbox;
    feat.properties = properties || {};
    feat.geometry = geometry;
    return feat;
}

/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<number>} coordinates Coordinates
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = 'Point';
 * var coordinates = [110, 50];
 *
 * var geometry = turf.geometry(type, coordinates);
 *
 * //=geometry
 */
function geometry(type, coordinates, bbox) {
    // Validation
    if (!type) throw new Error('type is required');
    if (!coordinates) throw new Error('coordinates is required');
    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

    var geom;
    switch (type) {
    case 'Point': geom = point(coordinates).geometry; break;
    case 'LineString': geom = lineString(coordinates).geometry; break;
    case 'Polygon': geom = polygon(coordinates).geometry; break;
    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
    default: throw new Error(type + ' is invalid');
    }
    if (bbox) geom.bbox = bbox;
    return geom;
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *   [-2.275543, 53.464547],
 *   [-2.275543, 53.489271],
 *   [-2.215118, 53.489271],
 *   [-2.215118, 53.464547],
 *   [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
    // Check if first point of LineString contains two numbers
    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var collection = turf.featureCollection(features);
 *
 * //=collection
 */
function featureCollection(features, bbox, id) {
    if (!features) throw new Error('No features passed');
    if (!Array.isArray(features)) throw new Error('features must be an Array');
    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

    var fc = {type: 'FeatureCollection'};
    if (id) fc.id = id;
    if (bbox) fc.bbox = bbox;
    fc.features = features;
    return fc;
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, bbox, id) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties, bbox, id);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Array<number>} [bbox] BBox [west, south, east, north]
 * @param {string|number} [id] Identifier
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties, bbox, id) {
    if (!geometries) throw new Error('geometries is required');
    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties, bbox, id);
}

// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    centimeters: 6.373e+8,
    centimetres: 6.373e+8,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

var areaFactors = {
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    centimetres: 10000,
    millimeter: 1000000,
    acres: 0.000247105,
    miles: 3.86e-7,
    yards: 1.195990046,
    feet: 10.763910417,
    inches: 1550.003100006
};
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    if (radians === undefined || radians === null) throw new Error('radians is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return radians * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    if (distance === undefined || distance === null) throw new Error('distance is required');

    var factor = factors[units || 'kilometers'];
    if (!factor) throw new Error('units is invalid');
    return distance / factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    return radians2degrees(distanceToRadians(distance, units));
}

/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAngle
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAngle(bearing) {
    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

    var angle = bearing % 360;
    if (angle < 0) angle += 360;
    return angle;
}

/**
 * Converts an angle in radians to degrees
 *
 * @name radians2degrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radians2degrees(radians) {
    if (radians === null || radians === undefined) throw new Error('radians is required');

    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}

/**
 * Converts an angle in degrees to radians
 *
 * @name degrees2radians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degrees2radians(degrees) {
    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

    var radians = degrees % 360;
    return radians * Math.PI / 180;
}


/**
 * Converts a distance to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} distance to be converted
 * @param {string} originalUnit of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertDistance(distance, originalUnit, finalUnit) {
    if (distance === null || distance === undefined) throw new Error('distance is required');
    if (!(distance >= 0)) throw new Error('distance must be a positive number');

    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
    return convertedDistance;
}

/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
 * @param {number} area to be converted
 * @param {string} [originalUnit=meters] of the distance
 * @param {string} [finalUnit=kilometers] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === null || area === undefined) throw new Error('area is required');
    if (!(area >= 0)) throw new Error('area must be a positive number');

    var startFactor = areaFactors[originalUnit || 'meters'];
    if (!startFactor) throw new Error('invalid original units');

    var finalFactor = areaFactors[finalUnit || 'kilometers'];
    if (!finalFactor) throw new Error('invalid final units');

    return (area / startFactor) * finalFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

module.exports = {
    feature: feature,
    geometry: geometry,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees,
    radians2degrees: radians2degrees,
    degrees2radians: degrees2radians,
    bearingToAngle: bearingToAngle,
    convertDistance: convertDistance,
    convertArea: convertArea,
    round: round,
    isNumber: isNumber
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

//index.js
var deepEqual = __webpack_require__(111);

var Equality = function(opt) {
  this.precision = opt && opt.precision ? opt.precision : 17;
  this.direction = opt && opt.direction ? opt.direction : false;
  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
};

Equality.prototype.compare = function(g1,g2) {
  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;

  switch(g1.type) {
  case 'Point':
    return this.compareCoord(g1.coordinates, g2.coordinates);
    break;
  case 'LineString':
    return this.compareLine(g1.coordinates, g2.coordinates,0,false);
    break;
  case 'Polygon':
    return this.comparePolygon(g1,g2);
    break;
  case 'Feature':
    return this.compareFeature(g1, g2);
  default:
    if (g1.type.indexOf('Multi') === 0) {
      var context = this;
      var g1s = explode(g1);
      var g2s = explode(g2);
      return g1s.every(function(g1part) {
        return this.some(function(g2part) {
          return context.compare(g1part,g2part);
        });
      },g2s);
    }
  }
  return false;
};

function explode(g) {
  return g.coordinates.map(function(part) {
    return {
      type: g.type.replace('Multi', ''),
      coordinates: part}
  });
}
//compare length of coordinates/array
function sameLength(g1,g2) {
   return g1.hasOwnProperty('coordinates') ?
    g1.coordinates.length === g2.coordinates.length
    : g1.length === g2.length;
}

// compare the two coordinates [x,y]
Equality.prototype.compareCoord = function(c1,c2) {
  if (c1.length !== c2.length) {
    return false;
  }

  for (var i=0; i < c1.length; i++) {
    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
      return false;
    }
  }
  return true;
};

Equality.prototype.compareLine = function(path1,path2,ind,isPoly) {
  if (!sameLength(path1,path2)) return false;
  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
  if (isPoly && !this.compareCoord(p1[0],p2[0])) {
    // fix start index of both to same point
    p2 = this.fixStartIndex(p2,p1);
    if(!p2) return;
  }
  // for linestring ind =0 and for polygon ind =1
  var sameDirection = this.compareCoord(p1[ind],p2[ind]);
  if (this.direction || sameDirection
  ) {
    return this.comparePath(p1, p2);
  } else {
    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])
    ) {
      return this.comparePath(p1.slice().reverse(), p2);
    }
    return false;
  }
};
Equality.prototype.fixStartIndex = function(sourcePath,targetPath) {
  //make sourcePath first point same as of targetPath
  var correctPath,ind = -1;
  for (var i=0; i< sourcePath.length; i++) {
    if(this.compareCoord(sourcePath[i],targetPath[0])) {
      ind = i;
      break;
    }
  }
  if (ind >= 0) {
    correctPath = [].concat(
      sourcePath.slice(ind,sourcePath.length),
      sourcePath.slice(1,ind+1));
  }
  return correctPath;
};
Equality.prototype.comparePath = function (p1,p2) {
  var cont = this;
  return p1.every(function(c,i) {
    return cont.compareCoord(c,this[i]);
  },p2);
};

Equality.prototype.comparePolygon = function(g1,g2) {
  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {
    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);
    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);
    var cont = this;
    return holes1.every(function(h1) {
      return this.some(function(h2) {
        return cont.compareLine(h1,h2,1,true);
      });
    },holes2);
  } else {
    return false;
  }
};

Equality.prototype.compareFeature = function(g1,g2) {
  if (
    g1.id !== g2.id ||
    !this.objectComparator(g1.properties, g2.properties) ||
    !this.compareBBox(g1,g2)
  ) {
    return false;
  }
  return this.compare(g1.geometry, g2.geometry);
};

Equality.prototype.compareBBox = function(g1,g2) {
  if (
    (!g1.bbox && !g2.bbox) || 
    (
      g1.bbox && g2.bbox &&
      this.compareCoord(g1.bbox, g2.bbox)
    )
  )  {
    return true;
  }
  return false;
};
Equality.prototype.removePseudo = function(path) {
  //TODO to be implement
  return path;
};

function objectComparator(obj1, obj2) {
  return deepEqual(obj1, obj2, {strict: true});
}

module.exports = Equality;


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jsts_es__ = __webpack_require__(204);


/**
 * Takes two or more {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @name union
 * @param {...Feature<Polygon>} A polygon to combine
 * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature
 * @example
 * var poly1 = turf.polygon([[
 *     [-82.574787, 35.594087],
 *     [-82.574787, 35.615581],
 *     [-82.545261, 35.615581],
 *     [-82.545261, 35.594087],
 *     [-82.574787, 35.594087]
 * ]], {"fill": "#0f0"});
 * var poly2 = turf.polygon([[
 *     [-82.560024, 35.585153],
 *     [-82.560024, 35.602602],
 *     [-82.52964, 35.602602],
 *     [-82.52964, 35.585153],
 *     [-82.560024, 35.585153]
 * ]], {"fill": "#00f"});
 *
 * var union = turf.union(poly1, poly2);
 *
 * //addToMap
 * var addToMap = [poly1, poly2, union];
 */
function union() {
    var reader = new __WEBPACK_IMPORTED_MODULE_0_jsts_es__["a" /* GeoJSONReader */]();
    var result = reader.read(JSON.stringify(arguments[0].geometry));

    for (var i = 1; i < arguments.length; i++) {
        result = __WEBPACK_IMPORTED_MODULE_0_jsts_es__["c" /* UnionOp */].union(result, reader.read(JSON.stringify(arguments[i].geometry)));
    }

    var writer = new __WEBPACK_IMPORTED_MODULE_0_jsts_es__["b" /* GeoJSONWriter */]();
    result = writer.write(result);

    return {
        type: 'Feature',
        geometry: result,
        properties: arguments[0].properties
    };
}

/* harmony default export */ __webpack_exports__["default"] = (union);


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_org_locationtech_jts_geom__ = __webpack_require__(205);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_org_locationtech_jts_algorithm__ = __webpack_require__(221);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_org_locationtech_jts_densify__ = __webpack_require__(275);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_org_locationtech_jts_dissolve__ = __webpack_require__(277);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_org_locationtech_jts_geomgraph__ = __webpack_require__(282);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_org_locationtech_jts_index__ = __webpack_require__(283);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_org_locationtech_jts_io__ = __webpack_require__(289);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_6__src_org_locationtech_jts_io__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_6__src_org_locationtech_jts_io__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_org_locationtech_jts_noding__ = __webpack_require__(294);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_org_locationtech_jts_operation__ = __webpack_require__(295);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_8__src_org_locationtech_jts_operation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_org_locationtech_jts_precision__ = __webpack_require__(353);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_org_locationtech_jts_simplify__ = __webpack_require__(356);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_org_locationtech_jts_triangulate__ = __webpack_require__(363);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_org_locationtech_jts_linearref__ = __webpack_require__(378);
/* unused harmony namespace reexport */















/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geom_MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__geom_MultiLineString__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__geom_Dimension__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__geom_IntersectionMatrix__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__geom_PrecisionModel__ = __webpack_require__(51);
/* unused harmony reexport Coordinate */
/* unused harmony reexport CoordinateList */
/* unused harmony reexport Envelope */
/* unused harmony reexport LineSegment */
/* unused harmony reexport GeometryFactory */
/* unused harmony reexport Geometry */
/* unused harmony reexport Point */
/* unused harmony reexport LineString */
/* unused harmony reexport LinearRing */
/* unused harmony reexport Polygon */
/* unused harmony reexport GeometryCollection */
/* unused harmony reexport MultiPoint */
/* unused harmony reexport MultiLineString */
/* unused harmony reexport MultiPolygon */
/* unused harmony reexport Dimension */
/* unused harmony reexport IntersectionMatrix */
/* unused harmony reexport PrecisionModel */





















/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NumberUtil;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function NumberUtil() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NumberUtil.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NumberUtil;
	}
});
NumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {
	return Math.abs(x1 - x2) <= tolerance;
};


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = AssertionFailedException;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_RuntimeException__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function AssertionFailedException() {
	if (arguments.length === 0) {
		__WEBPACK_IMPORTED_MODULE_1__java_lang_RuntimeException__["a" /* default */].call(this);
	} else if (arguments.length === 1) {
		let message = arguments[0];
		__WEBPACK_IMPORTED_MODULE_1__java_lang_RuntimeException__["a" /* default */].call(this, message);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(AssertionFailedException, __WEBPACK_IMPORTED_MODULE_1__java_lang_RuntimeException__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(AssertionFailedException.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return AssertionFailedException;
	}
});


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IndexOutOfBoundsException;
/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function IndexOutOfBoundsException(message) {
  this.message = message || '';
};
IndexOutOfBoundsException.prototype = new Error();

/**
 * @type {string}
 */
IndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);





function LineIntersector() {
	this._result = null;
	this._inputLines = Array(2).fill().map(() => Array(2));
	this._intPt = new Array(2).fill(null);
	this._intLineIndex = null;
	this._isProper = null;
	this._pa = null;
	this._pb = null;
	this._precisionModel = null;
	this._intPt[0] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
	this._intPt[1] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */]();
	this._pa = this._intPt[0];
	this._pb = this._intPt[1];
	this._result = 0;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(LineIntersector.prototype, {
	getIndexAlongSegment: function (segmentIndex, intIndex) {
		this.computeIntLineIndex();
		return this._intLineIndex[segmentIndex][intIndex];
	},
	getTopologySummary: function () {
		var catBuf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		if (this.isEndPoint()) catBuf.append(" endpoint");
		if (this._isProper) catBuf.append(" proper");
		if (this.isCollinear()) catBuf.append(" collinear");
		return catBuf.toString();
	},
	computeIntersection: function (p1, p2, p3, p4) {
		this._inputLines[0][0] = p1;
		this._inputLines[0][1] = p2;
		this._inputLines[1][0] = p3;
		this._inputLines[1][1] = p4;
		this._result = this.computeIntersect(p1, p2, p3, p4);
	},
	getIntersectionNum: function () {
		return this._result;
	},
	computeIntLineIndex: function () {
		if (arguments.length === 0) {
			if (this._intLineIndex === null) {
				this._intLineIndex = Array(2).fill().map(() => Array(2));
				this.computeIntLineIndex(0);
				this.computeIntLineIndex(1);
			}
		} else if (arguments.length === 1) {
			let segmentIndex = arguments[0];
			var dist0 = this.getEdgeDistance(segmentIndex, 0);
			var dist1 = this.getEdgeDistance(segmentIndex, 1);
			if (dist0 > dist1) {
				this._intLineIndex[segmentIndex][0] = 0;
				this._intLineIndex[segmentIndex][1] = 1;
			} else {
				this._intLineIndex[segmentIndex][0] = 1;
				this._intLineIndex[segmentIndex][1] = 0;
			}
		}
	},
	isProper: function () {
		return this.hasIntersection() && this._isProper;
	},
	setPrecisionModel: function (precisionModel) {
		this._precisionModel = precisionModel;
	},
	isInteriorIntersection: function () {
		if (arguments.length === 0) {
			if (this.isInteriorIntersection(0)) return true;
			if (this.isInteriorIntersection(1)) return true;
			return false;
		} else if (arguments.length === 1) {
			let inputLineIndex = arguments[0];
			for (var i = 0; i < this._result; i++) {
				if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {
					return true;
				}
			}
			return false;
		}
	},
	getIntersection: function (intIndex) {
		return this._intPt[intIndex];
	},
	isEndPoint: function () {
		return this.hasIntersection() && !this._isProper;
	},
	hasIntersection: function () {
		return this._result !== LineIntersector.NO_INTERSECTION;
	},
	getEdgeDistance: function (segmentIndex, intIndex) {
		var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
		return dist;
	},
	isCollinear: function () {
		return this._result === LineIntersector.COLLINEAR_INTERSECTION;
	},
	toString: function () {
		return __WEBPACK_IMPORTED_MODULE_1__io_WKTWriter__["a" /* default */].toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + __WEBPACK_IMPORTED_MODULE_1__io_WKTWriter__["a" /* default */].toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
	},
	getEndpoint: function (segmentIndex, ptIndex) {
		return this._inputLines[segmentIndex][ptIndex];
	},
	isIntersection: function (pt) {
		for (var i = 0; i < this._result; i++) {
			if (this._intPt[i].equals2D(pt)) {
				return true;
			}
		}
		return false;
	},
	getIntersectionAlongSegment: function (segmentIndex, intIndex) {
		this.computeIntLineIndex();
		return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineIntersector;
	}
});
LineIntersector.computeEdgeDistance = function (p, p0, p1) {
	var dx = Math.abs(p1.x - p0.x);
	var dy = Math.abs(p1.y - p0.y);
	var dist = -1.0;
	if (p.equals(p0)) {
		dist = 0.0;
	} else if (p.equals(p1)) {
		if (dx > dy) dist = dx; else dist = dy;
	} else {
		var pdx = Math.abs(p.x - p0.x);
		var pdy = Math.abs(p.y - p0.y);
		if (dx > dy) dist = pdx; else dist = pdy;
		if (dist === 0.0 && !p.equals(p0)) {
			dist = Math.max(pdx, pdy);
		}
	}
	__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(!(dist === 0.0 && !p.equals(p0)), "Bad distance calculation");
	return dist;
};
LineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {
	var dx = p.x - p1.x;
	var dy = p.y - p1.y;
	var dist = Math.sqrt(dx * dx + dy * dy);
	__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(!(dist === 0.0 && !p.equals(p1)), "Invalid distance calculation");
	return dist;
};
LineIntersector.DONT_INTERSECT = 0;
LineIntersector.DO_INTERSECT = 1;
LineIntersector.COLLINEAR = 2;
LineIntersector.NO_INTERSECTION = 0;
LineIntersector.POINT_INTERSECTION = 1;
LineIntersector.COLLINEAR_INTERSECTION = 2;


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SortedMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Map__ = __webpack_require__(120);


/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
 *
 * @extends {Map}
 * @constructor
 * @private
 */
function SortedMap() {};
SortedMap.prototype = new __WEBPACK_IMPORTED_MODULE_0__Map__["a" /* default */]();


/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SortedSet;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Set__ = __webpack_require__(121);


/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
 *
 * @extends {Set}
 * @constructor
 * @private
 */
function SortedSet() {};
SortedSet.prototype = new __WEBPACK_IMPORTED_MODULE_0__Set__["a" /* default */]();


/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = StringUtil;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_io_PrintStream__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_io_StringReader__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_text_DecimalFormat__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_io_ByteArrayOutputStream__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_io_IOException__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_io_LineNumberReader__ = __webpack_require__(218);










function StringUtil() {}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(StringUtil.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return StringUtil;
	}
});
StringUtil.chars = function (c, n) {
	var ch = new Array(n).fill(null);
	for (var i = 0; i < n; i++) {
		ch[i] = c;
	}
	return new String(ch);
};
StringUtil.getStackTrace = function () {
	if (arguments.length === 1) {
		let t = arguments[0];
		var os = new __WEBPACK_IMPORTED_MODULE_6__java_io_ByteArrayOutputStream__["a" /* default */]();
		var ps = new __WEBPACK_IMPORTED_MODULE_0__java_io_PrintStream__["a" /* default */](os);
		t.printStackTrace(ps);
		return os.toString();
	} else if (arguments.length === 2) {
		let t = arguments[0], depth = arguments[1];
		var stackTrace = "";
		var stringReader = new __WEBPACK_IMPORTED_MODULE_1__java_io_StringReader__["a" /* default */](StringUtil.getStackTrace(t));
		var lineNumberReader = new __WEBPACK_IMPORTED_MODULE_9__java_io_LineNumberReader__["a" /* default */](stringReader);
		for (var i = 0; i < depth; i++) {
			try {
				stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
			} catch (e) {
				if (e instanceof __WEBPACK_IMPORTED_MODULE_8__java_io_IOException__["a" /* default */]) {
					__WEBPACK_IMPORTED_MODULE_7__Assert__["a" /* default */].shouldNeverReachHere();
				} else throw e;
			} finally {}
		}
		return stackTrace;
	}
};
StringUtil.split = function (s, separator) {
	var separatorlen = separator.length;
	var tokenList = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
	var tmpString = "" + s;
	var pos = tmpString.indexOf(separator);
	while (pos >= 0) {
		var token = tmpString.substring(0, pos);
		tokenList.add(token);
		tmpString = tmpString.substring(pos + separatorlen);
		pos = tmpString.indexOf(separator);
	}
	if (tmpString.length > 0) tokenList.add(tmpString);
	var res = new Array(tokenList.size()).fill(null);
	for (var i = 0; i < res.length; i++) {
		res[i] = tokenList.get(i);
	}
	return res;
};
StringUtil.toString = function () {
	if (arguments.length === 1) {
		let d = arguments[0];
		return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);
	}
};
StringUtil.spaces = function (n) {
	return StringUtil.chars(' ', n);
};
StringUtil.NEWLINE = __WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].getProperty("line.separator");
StringUtil.SIMPLE_ORDINATE_FORMAT = new __WEBPACK_IMPORTED_MODULE_2__java_text_DecimalFormat__["a" /* default */]("0.#");


/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PrintStream;
function PrintStream () {}


/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = StringReader;
function StringReader () {}


/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DecimalFormat;
function DecimalFormat () {}


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ByteArrayOutputStream;
function ByteArrayOutputStream () {}


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IOException;
function IOException () {}


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineNumberReader;
function LineNumberReader () {}


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CoordinateArraySequenceFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CoordinateSequenceFactory__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CoordinateArraySequence__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_io_Serializable__ = __webpack_require__(21);






function CoordinateArraySequenceFactory() {}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(CoordinateArraySequenceFactory.prototype, {
	readResolve: function () {
		return CoordinateArraySequenceFactory.instance();
	},
	create: function () {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				let coordinates = arguments[0];
				return new __WEBPACK_IMPORTED_MODULE_2__CoordinateArraySequence__["a" /* default */](coordinates);
			} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_4__CoordinateSequence__["a" /* default */])) {
				let coordSeq = arguments[0];
				return new __WEBPACK_IMPORTED_MODULE_2__CoordinateArraySequence__["a" /* default */](coordSeq);
			}
		} else if (arguments.length === 2) {
			let size = arguments[0], dimension = arguments[1];
			if (dimension > 3) dimension = 3;
			if (dimension < 2) return new __WEBPACK_IMPORTED_MODULE_2__CoordinateArraySequence__["a" /* default */](size);
			return new __WEBPACK_IMPORTED_MODULE_2__CoordinateArraySequence__["a" /* default */](size, dimension);
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_0__CoordinateSequenceFactory__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return CoordinateArraySequenceFactory;
	}
});
CoordinateArraySequenceFactory.instance = function () {
	return CoordinateArraySequenceFactory.instanceObject;
};
CoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;
CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();


/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// shared pointer
var i
// shortcuts
var defineProperty = Object.defineProperty
function is (a, b) { return (a === b) || (a !== a && b !== b) } // eslint-disable-line

/* harmony default export */ __webpack_exports__["a"] = (createCollection({
  // WeakMap#delete(key:void*):boolean
  'delete': sharedDelete,
  // :was Map#get(key:void*[, d3fault:void*]):void*
  // Map#has(key:void*):boolean
  has: mapHas,
  // Map#get(key:void*):boolean
  get: sharedGet,
  // Map#set(key:void*, value:void*):void
  set: sharedSet,
  // Map#keys(void):Iterator
  keys: sharedKeys,
  // Map#values(void):Iterator
  values: sharedValues,
  // Map#entries(void):Iterator
  entries: mapEntries,
  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
  forEach: sharedForEach,
  // Map#clear():
  clear: sharedClear
}));

/**
 * ES6 collection constructor
 * @return {Function} a collection class
 */
function createCollection (proto, objectOnly) {
  function Collection (a) {
    if (!this || this.constructor !== Collection) return new Collection(a)
    this._keys = []
    this._values = []
    this._itp = [] // iteration pointers
    this.objectOnly = objectOnly

    // parse initial iterable argument passed
    if (a) init.call(this, a)
  }

  // define size for non object-only collections
  if (!objectOnly) {
    defineProperty(proto, 'size', {
      get: sharedSize
    })
  }

  // set prototype
  proto.constructor = Collection
  Collection.prototype = proto

  return Collection
}

/** parse initial iterable argument passed */
function init (a) {
  // init Set argument, like `[1,2,3,{}]`
  if (this.add) a.forEach(this.add, this)
  // init Map argument like `[[1,2], [{}, 4]]`
  else a.forEach(function (a) { this.set(a[0], a[1]) }, this)
}

/** delete */
function sharedDelete (key) {
  if (this.has(key)) {
    this._keys.splice(i, 1)
    this._values.splice(i, 1)
    // update iteration pointers
    this._itp.forEach(function (p) { if (i < p[0]) p[0]-- })
  }
  // Aurora here does it while Canary doesn't
  return i > -1
}

function sharedGet (key) {
  return this.has(key) ? this._values[i] : undefined
}

function has (list, key) {
  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key')
  // NaN or 0 passed
  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line
  else i = list.indexOf(key)
  return i > -1
}

function mapHas (value) {
  return has.call(this, this._keys, value)
}

/** @chainable */
function sharedSet (key, value) {
  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value
  return this
}

function sharedClear () {
  (this._keys || 0).length =
    this._values.length = 0
}

/** keys, values, and iterate related methods */
function sharedKeys () {
  return sharedIterator(this._itp, this._keys)
}

function sharedValues () {
  return sharedIterator(this._itp, this._values)
}

function mapEntries () {
  return sharedIterator(this._itp, this._keys, this._values)
}

function sharedIterator (itp, array, array2) {
  var p = [0]
  var done = false
  itp.push(p)
  return {
    next: function () {
      var v
      var k = p[0]
      if (!done && k < array.length) {
        v = array2 ? [array[k], array2[k]] : array[k]
        p[0]++
      } else {
        done = true
        itp.splice(itp.indexOf(p), 1)
      }
      return { done: done, value: v }
    }
  }
}

function sharedSize () {
  return this._values.length
}

function sharedForEach (callback, context) {
  var it = this.entries()
  for (;;) {
    var r = it.next()
    if (r.done) break
    callback.call(context, r.value[1], r.value[0], this)
  }
}


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_Centroid__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_ConvexHull__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__algorithm_InteriorPointArea__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__algorithm_InteriorPointLine__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__algorithm_InteriorPointPoint__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__algorithm_MCPointInRing__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__algorithm_MinimumBoundingCircle__ = __webpack_require__(273);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__algorithm_MinimumDiameter__ = __webpack_require__(274);
/* unused harmony reexport Centroid */
/* unused harmony reexport CGAlgorithms */
/* unused harmony reexport ConvexHull */
/* unused harmony reexport InteriorPointArea */
/* unused harmony reexport InteriorPointLine */
/* unused harmony reexport InteriorPointPoint */
/* unused harmony reexport RobustLineIntersector */
/* unused harmony reexport MCPointInRing */
/* unused harmony reexport MinimumBoundingCircle */
/* unused harmony reexport MinimumDiameter */














/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_GeometryCollection__ = __webpack_require__(13);








function Centroid() {
	this._areaBasePt = null;
	this._triangleCent3 = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]();
	this._areasum2 = 0;
	this._cg3 = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]();
	this._lineCentSum = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]();
	this._totalLength = 0.0;
	this._ptCount = 0;
	this._ptCentSum = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]();
	let geom = arguments[0];
	this._areaBasePt = null;
	this.add(geom);
}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(Centroid.prototype, {
	addPoint: function (pt) {
		this._ptCount += 1;
		this._ptCentSum.x += pt.x;
		this._ptCentSum.y += pt.y;
	},
	setBasePoint: function (basePt) {
		if (this._areaBasePt === null) this._areaBasePt = basePt;
	},
	addLineSegments: function (pts) {
		var lineLen = 0.0;
		for (var i = 0; i < pts.length - 1; i++) {
			var segmentLen = pts[i].distance(pts[i + 1]);
			if (segmentLen === 0.0) continue;
			lineLen += segmentLen;
			var midx = (pts[i].x + pts[i + 1].x) / 2;
			this._lineCentSum.x += segmentLen * midx;
			var midy = (pts[i].y + pts[i + 1].y) / 2;
			this._lineCentSum.y += segmentLen * midy;
		}
		this._totalLength += lineLen;
		if (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);
	},
	addHole: function (pts) {
		var isPositiveArea = __WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].isCCW(pts);
		for (var i = 0; i < pts.length - 1; i++) {
			this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);
		}
		this.addLineSegments(pts);
	},
	getCentroid: function () {
		var cent = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]();
		if (Math.abs(this._areasum2) > 0.0) {
			cent.x = this._cg3.x / 3 / this._areasum2;
			cent.y = this._cg3.y / 3 / this._areasum2;
		} else if (this._totalLength > 0.0) {
			cent.x = this._lineCentSum.x / this._totalLength;
			cent.y = this._lineCentSum.y / this._totalLength;
		} else if (this._ptCount > 0) {
			cent.x = this._ptCentSum.x / this._ptCount;
			cent.y = this._ptCentSum.y / this._ptCount;
		} else {
			return null;
		}
		return cent;
	},
	addShell: function (pts) {
		if (pts.length > 0) this.setBasePoint(pts[0]);
		var isPositiveArea = !__WEBPACK_IMPORTED_MODULE_1__CGAlgorithms__["a" /* default */].isCCW(pts);
		for (var i = 0; i < pts.length - 1; i++) {
			this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);
		}
		this.addLineSegments(pts);
	},
	addTriangle: function (p0, p1, p2, isPositiveArea) {
		var sign = isPositiveArea ? 1.0 : -1.0;
		Centroid.centroid3(p0, p1, p2, this._triangleCent3);
		var area2 = Centroid.area2(p0, p1, p2);
		this._cg3.x += sign * area2 * this._triangleCent3.x;
		this._cg3.y += sign * area2 * this._triangleCent3.y;
		this._areasum2 += sign * area2;
	},
	add: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Polygon__["a" /* default */]) {
			let poly = arguments[0];
			this.addShell(poly.getExteriorRing().getCoordinates());
			for (var i = 0; i < poly.getNumInteriorRing(); i++) {
				this.addHole(poly.getInteriorRingN(i).getCoordinates());
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			if (geom.isEmpty()) return null;
			if (geom instanceof __WEBPACK_IMPORTED_MODULE_4__geom_Point__["a" /* default */]) {
				this.addPoint(geom.getCoordinate());
			} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
				this.addLineSegments(geom.getCoordinates());
			} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Polygon__["a" /* default */]) {
				var poly = geom;
				this.add(poly);
			} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_7__geom_GeometryCollection__["a" /* default */]) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.add(gc.getGeometryN(i));
				}
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Centroid;
	}
});
Centroid.area2 = function (p1, p2, p3) {
	return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);
};
Centroid.centroid3 = function (p1, p2, p3, c) {
	c.x = p1.x + p2.x + p3.x;
	c.y = p1.y + p2.y + p3.y;
	return null;
};
Centroid.getCentroid = function (geom) {
	var cent = new Centroid(geom);
	return cent.getCentroid();
};


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EmptyStackException;
/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function EmptyStackException(message) {
  this.message = message || '';
};
EmptyStackException.prototype = new Error();


/**
 * @type {string}
 */
EmptyStackException.prototype.name = 'EmptyStackException';


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = UniqueCoordinateArrayFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateFilter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function UniqueCoordinateArrayFilter() {
	this.treeSet = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */]();
	this.list = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(UniqueCoordinateArrayFilter.prototype, {
	filter: function (coord) {
		if (!this.treeSet.contains(coord)) {
			this.list.add(coord);
			this.treeSet.add(coord);
		}
	},
	getCoordinates: function () {
		var coordinates = new Array(this.list.size()).fill(null);
		return this.list.toArray(coordinates);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__geom_CoordinateFilter__["a" /* default */]];
	},
	getClass: function () {
		return UniqueCoordinateArrayFilter;
	}
});
UniqueCoordinateArrayFilter.filterCoordinates = function (coords) {
	var filter = new UniqueCoordinateArrayFilter();
	for (var i = 0; i < coords.length; i++) {
		filter.filter(coords[i]);
	}
	return filter.getCoordinates();
};


/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_overlay_snap_SnapIfNeededOverlayOp__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_overlay_OverlayOp__ = __webpack_require__(42);








function InteriorPointArea() {
	this._factory = null;
	this._interiorPoint = null;
	this._maxWidth = 0.0;
	let g = arguments[0];
	this._factory = g.getFactory();
	this.add(g);
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(InteriorPointArea.prototype, {
	addPolygon: function (geometry) {
		if (geometry.isEmpty()) return null;
		var intPt = null;
		var width = 0;
		var bisector = this.horizontalBisector(geometry);
		if (bisector.getLength() === 0.0) {
			width = 0;
			intPt = bisector.getCoordinate();
		} else {
			var intersections = __WEBPACK_IMPORTED_MODULE_3__operation_overlay_snap_SnapIfNeededOverlayOp__["a" /* default */].overlayOp(bisector, geometry, __WEBPACK_IMPORTED_MODULE_7__operation_overlay_OverlayOp__["a" /* default */].INTERSECTION);
			var widestIntersection = this.widestGeometry(intersections);
			width = widestIntersection.getEnvelopeInternal().getWidth();
			intPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());
		}
		if (this._interiorPoint === null || width > this._maxWidth) {
			this._interiorPoint = intPt;
			this._maxWidth = width;
		}
	},
	getInteriorPoint: function () {
		return this._interiorPoint;
	},
	widestGeometry: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__["a" /* default */]) {
			let gc = arguments[0];
			if (gc.isEmpty()) {
				return gc;
			}
			var widestGeometry = gc.getGeometryN(0);
			for (var i = 1; i < gc.getNumGeometries(); i++) {
				if (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {
					widestGeometry = gc.getGeometryN(i);
				}
			}
			return widestGeometry;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */]) {
			let geometry = arguments[0];
			if (!(geometry instanceof __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__["a" /* default */])) {
				return geometry;
			}
			return this.widestGeometry(geometry);
		}
	},
	horizontalBisector: function (geometry) {
		var envelope = geometry.getEnvelopeInternal();
		var bisectY = SafeBisectorFinder.getBisectorY(geometry);
		return this._factory.createLineString([new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](envelope.getMinX(), bisectY), new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](envelope.getMaxX(), bisectY)]);
	},
	add: function (geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Polygon__["a" /* default */]) {
			this.addPolygon(geom);
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__["a" /* default */]) {
			var gc = geom;
			for (var i = 0; i < gc.getNumGeometries(); i++) {
				this.add(gc.getGeometryN(i));
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return InteriorPointArea;
	}
});
InteriorPointArea.centre = function (envelope) {
	return new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));
};
InteriorPointArea.avg = function (a, b) {
	return (a + b) / 2.0;
};
function SafeBisectorFinder() {
	this._poly = null;
	this._centreY = null;
	this._hiY = __WEBPACK_IMPORTED_MODULE_4__java_lang_Double__["a" /* default */].MAX_VALUE;
	this._loY = -__WEBPACK_IMPORTED_MODULE_4__java_lang_Double__["a" /* default */].MAX_VALUE;
	let poly = arguments[0];
	this._poly = poly;
	this._hiY = poly.getEnvelopeInternal().getMaxY();
	this._loY = poly.getEnvelopeInternal().getMinY();
	this._centreY = InteriorPointArea.avg(this._loY, this._hiY);
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(SafeBisectorFinder.prototype, {
	updateInterval: function (y) {
		if (y <= this._centreY) {
			if (y > this._loY) this._loY = y;
		} else if (y > this._centreY) {
			if (y < this._hiY) {
				this._hiY = y;
			}
		}
	},
	getBisectorY: function () {
		this.process(this._poly.getExteriorRing());
		for (var i = 0; i < this._poly.getNumInteriorRing(); i++) {
			this.process(this._poly.getInteriorRingN(i));
		}
		var bisectY = InteriorPointArea.avg(this._hiY, this._loY);
		return bisectY;
	},
	process: function (line) {
		var seq = line.getCoordinateSequence();
		for (var i = 0; i < seq.size(); i++) {
			var y = seq.getY(i);
			this.updateInterval(y);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SafeBisectorFinder;
	}
});
SafeBisectorFinder.getBisectorY = function (poly) {
	var finder = new SafeBisectorFinder(poly);
	return finder.getBisectorY();
};
InteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;


/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SnapOverlayOp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeometrySnapper__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__precision_CommonBitsRemover__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__OverlayOp__ = __webpack_require__(42);





function SnapOverlayOp() {
	this._geom = new Array(2).fill(null);
	this._snapTolerance = null;
	this._cbr = null;
	let g1 = arguments[0], g2 = arguments[1];
	this._geom[0] = g1;
	this._geom[1] = g2;
	this.computeSnapTolerance();
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(SnapOverlayOp.prototype, {
	selfSnap: function (geom) {
		var snapper0 = new __WEBPACK_IMPORTED_MODULE_0__GeometrySnapper__["a" /* default */](geom);
		var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
		return snapGeom;
	},
	removeCommonBits: function (geom) {
		this._cbr = new __WEBPACK_IMPORTED_MODULE_3__precision_CommonBitsRemover__["a" /* default */]();
		this._cbr.add(geom[0]);
		this._cbr.add(geom[1]);
		var remGeom = new Array(2).fill(null);
		remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
		remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
		return remGeom;
	},
	prepareResult: function (geom) {
		this._cbr.addCommonBits(geom);
		return geom;
	},
	getResultGeometry: function (opCode) {
		var prepGeom = this.snap(this._geom);
		var result = __WEBPACK_IMPORTED_MODULE_4__OverlayOp__["a" /* default */].overlayOp(prepGeom[0], prepGeom[1], opCode);
		return this.prepareResult(result);
	},
	checkValid: function (g) {
		if (!g.isValid()) {
			__WEBPACK_IMPORTED_MODULE_2__java_lang_System__["a" /* default */].out.println("Snapped geometry is invalid");
		}
	},
	computeSnapTolerance: function () {
		this._snapTolerance = __WEBPACK_IMPORTED_MODULE_0__GeometrySnapper__["a" /* default */].computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
	},
	snap: function (geom) {
		var remGeom = this.removeCommonBits(geom);
		var snapGeom = __WEBPACK_IMPORTED_MODULE_0__GeometrySnapper__["a" /* default */].snap(remGeom[0], remGeom[1], this._snapTolerance);
		return snapGeom;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SnapOverlayOp;
	}
});
SnapOverlayOp.overlayOp = function (g0, g1, opCode) {
	var op = new SnapOverlayOp(g0, g1);
	return op.getResultGeometry(opCode);
};
SnapOverlayOp.union = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_4__OverlayOp__["a" /* default */].UNION);
};
SnapOverlayOp.intersection = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_4__OverlayOp__["a" /* default */].INTERSECTION);
};
SnapOverlayOp.symDifference = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_4__OverlayOp__["a" /* default */].SYMDIFFERENCE);
};
SnapOverlayOp.difference = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, __WEBPACK_IMPORTED_MODULE_4__OverlayOp__["a" /* default */].DIFFERENCE);
};


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometrySnapper;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__LineStringSnapper__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_PrecisionModel__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__inherits__ = __webpack_require__(3);









function GeometrySnapper() {
	this._srcGeom = null;
	let srcGeom = arguments[0];
	this._srcGeom = srcGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(GeometrySnapper.prototype, {
	snapTo: function (snapGeom, snapTolerance) {
		var snapPts = this.extractTargetCoordinates(snapGeom);
		var snapTrans = new SnapTransformer(snapTolerance, snapPts);
		return snapTrans.transform(this._srcGeom);
	},
	snapToSelf: function (snapTolerance, cleanResult) {
		var snapPts = this.extractTargetCoordinates(this._srcGeom);
		var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
		var snappedGeom = snapTrans.transform(this._srcGeom);
		var result = snappedGeom;
		if (cleanResult && Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(result, __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__["a" /* default */])) {
			result = snappedGeom.buffer(0);
		}
		return result;
	},
	computeSnapTolerance: function (ringPts) {
		var minSegLen = this.computeMinimumSegmentLength(ringPts);
		var snapTol = minSegLen / 10;
		return snapTol;
	},
	extractTargetCoordinates: function (g) {
		var ptSet = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */]();
		var pts = g.getCoordinates();
		for (var i = 0; i < pts.length; i++) {
			ptSet.add(pts[i]);
		}
		return ptSet.toArray(new Array(0).fill(null));
	},
	computeMinimumSegmentLength: function (pts) {
		var minSegLen = __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].MAX_VALUE;
		for (var i = 0; i < pts.length - 1; i++) {
			var segLen = pts[i].distance(pts[i + 1]);
			if (segLen < minSegLen) minSegLen = segLen;
		}
		return minSegLen;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometrySnapper;
	}
});
GeometrySnapper.snap = function (g0, g1, snapTolerance) {
	var snapGeom = new Array(2).fill(null);
	var snapper0 = new GeometrySnapper(g0);
	snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
	var snapper1 = new GeometrySnapper(g1);
	snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
	return snapGeom;
};
GeometrySnapper.computeOverlaySnapTolerance = function () {
	if (arguments.length === 1) {
		let g = arguments[0];
		var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
		var pm = g.getPrecisionModel();
		if (pm.getType() === __WEBPACK_IMPORTED_MODULE_6__geom_PrecisionModel__["a" /* default */].FIXED) {
			var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
			if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;
		}
		return snapTolerance;
	} else if (arguments.length === 2) {
		let g0 = arguments[0], g1 = arguments[1];
		return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
	}
};
GeometrySnapper.computeSizeBasedSnapTolerance = function (g) {
	var env = g.getEnvelopeInternal();
	var minDimension = Math.min(env.getHeight(), env.getWidth());
	var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
	return snapTol;
};
GeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {
	var snapper0 = new GeometrySnapper(geom);
	return snapper0.snapToSelf(snapTolerance, cleanResult);
};
GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;
function SnapTransformer() {
	__WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */].apply(this);
	this._snapTolerance = null;
	this._snapPts = null;
	this._isSelfSnap = false;
	if (arguments.length === 2) {
		let snapTolerance = arguments[0], snapPts = arguments[1];
		this._snapTolerance = snapTolerance;
		this._snapPts = snapPts;
	} else if (arguments.length === 3) {
		let snapTolerance = arguments[0], snapPts = arguments[1], isSelfSnap = arguments[2];
		this._snapTolerance = snapTolerance;
		this._snapPts = snapPts;
		this._isSelfSnap = isSelfSnap;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_8__inherits__["a" /* default */])(SnapTransformer, __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(SnapTransformer.prototype, {
	snapLine: function (srcPts, snapPts) {
		var snapper = new __WEBPACK_IMPORTED_MODULE_5__LineStringSnapper__["a" /* default */](srcPts, this._snapTolerance);
		snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
		return snapper.snapTo(snapPts);
	},
	transformCoordinates: function (coords, parent) {
		var srcPts = coords.toCoordinateArray();
		var newPts = this.snapLine(srcPts, this._snapPts);
		return this._factory.getCoordinateSequenceFactory().create(newPts);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SnapTransformer;
	}
});


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineStringSnapper;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_LineSegment__ = __webpack_require__(14);






function LineStringSnapper() {
	this._snapTolerance = 0.0;
	this._srcPts = null;
	this._seg = new __WEBPACK_IMPORTED_MODULE_5__geom_LineSegment__["a" /* default */]();
	this._allowSnappingToSourceVertices = false;
	this._isClosed = false;
	if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */] && typeof arguments[1] === "number") {
		let srcLine = arguments[0], snapTolerance = arguments[1];
		LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);
	} else if (arguments[0] instanceof Array && typeof arguments[1] === "number") {
		let srcPts = arguments[0], snapTolerance = arguments[1];
		this._srcPts = srcPts;
		this._isClosed = LineStringSnapper.isClosed(srcPts);
		this._snapTolerance = snapTolerance;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(LineStringSnapper.prototype, {
	snapVertices: function (srcCoords, snapPts) {
		var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
		for (var i = 0; i < end; i++) {
			var srcPt = srcCoords.get(i);
			var snapVert = this.findSnapForVertex(srcPt, snapPts);
			if (snapVert !== null) {
				srcCoords.set(i, new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](snapVert));
				if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](snapVert));
			}
		}
	},
	findSnapForVertex: function (pt, snapPts) {
		for (var i = 0; i < snapPts.length; i++) {
			if (pt.equals2D(snapPts[i])) return null;
			if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];
		}
		return null;
	},
	snapTo: function (snapPts) {
		var coordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */](this._srcPts);
		this.snapVertices(coordList, snapPts);
		this.snapSegments(coordList, snapPts);
		var newPts = coordList.toCoordinateArray();
		return newPts;
	},
	snapSegments: function (srcCoords, snapPts) {
		if (snapPts.length === 0) return null;
		var distinctPtCount = snapPts.length;
		if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;
		for (var i = 0; i < distinctPtCount; i++) {
			var snapPt = snapPts[i];
			var index = this.findSegmentIndexToSnap(snapPt, srcCoords);
			if (index >= 0) {
				srcCoords.add(index + 1, new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](snapPt), false);
			}
		}
	},
	findSegmentIndexToSnap: function (snapPt, srcCoords) {
		var minDist = __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].MAX_VALUE;
		var snapIndex = -1;
		for (var i = 0; i < srcCoords.size() - 1; i++) {
			this._seg.p0 = srcCoords.get(i);
			this._seg.p1 = srcCoords.get(i + 1);
			if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {
				if (this._allowSnappingToSourceVertices) continue; else return -1;
			}
			var dist = this._seg.distance(snapPt);
			if (dist < this._snapTolerance && dist < minDist) {
				minDist = dist;
				snapIndex = i;
			}
		}
		return snapIndex;
	},
	setAllowSnappingToSourceVertices: function (allowSnappingToSourceVertices) {
		this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineStringSnapper;
	}
});
LineStringSnapper.isClosed = function (pts) {
	if (pts.length <= 1) return false;
	return pts[0].equals2D(pts[pts.length - 1]);
};


/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CommonBitsRemover;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CommonBits__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateFilter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_CoordinateSequenceFilter__ = __webpack_require__(59);





function CommonBitsRemover() {
	this._commonCoord = null;
	this._ccFilter = new CommonCoordinateFilter();
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(CommonBitsRemover.prototype, {
	addCommonBits: function (geom) {
		var trans = new Translater(this._commonCoord);
		geom.apply(trans);
		geom.geometryChanged();
	},
	removeCommonBits: function (geom) {
		if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;
		var invCoord = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](this._commonCoord);
		invCoord.x = -invCoord.x;
		invCoord.y = -invCoord.y;
		var trans = new Translater(invCoord);
		geom.apply(trans);
		geom.geometryChanged();
		return geom;
	},
	getCommonCoordinate: function () {
		return this._commonCoord;
	},
	add: function (geom) {
		geom.apply(this._ccFilter);
		this._commonCoord = this._ccFilter.getCommonCoordinate();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CommonBitsRemover;
	}
});
function CommonCoordinateFilter() {
	this._commonBitsX = new __WEBPACK_IMPORTED_MODULE_0__CommonBits__["a" /* default */]();
	this._commonBitsY = new __WEBPACK_IMPORTED_MODULE_0__CommonBits__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(CommonCoordinateFilter.prototype, {
	filter: function (coord) {
		this._commonBitsX.add(coord.x);
		this._commonBitsY.add(coord.y);
	},
	getCommonCoordinate: function () {
		return new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__geom_CoordinateFilter__["a" /* default */]];
	},
	getClass: function () {
		return CommonCoordinateFilter;
	}
});
function Translater() {
	this.trans = null;
	let trans = arguments[0];
	this.trans = trans;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Translater.prototype, {
	filter: function (seq, i) {
		var xp = seq.getOrdinate(i, 0) + this.trans.x;
		var yp = seq.getOrdinate(i, 1) + this.trans.y;
		seq.setOrdinate(i, 0, xp);
		seq.setOrdinate(i, 1, yp);
	},
	isDone: function () {
		return false;
	},
	isGeometryChanged: function () {
		return true;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__geom_CoordinateSequenceFilter__["a" /* default */]];
	},
	getClass: function () {
		return Translater;
	}
});
CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;
CommonBitsRemover.Translater = Translater;


/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CommonBits;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function CommonBits() {
	this._isFirst = true;
	this._commonMantissaBitsCount = 53;
	this._commonBits = 0;
	this._commonSignExp = null;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(CommonBits.prototype, {
	getCommon: function () {
		return __WEBPACK_IMPORTED_MODULE_0__java_lang_Double__["a" /* default */].longBitsToDouble(this._commonBits);
	},
	add: function (num) {
		var numBits = __WEBPACK_IMPORTED_MODULE_0__java_lang_Double__["a" /* default */].doubleToLongBits(num);
		if (this._isFirst) {
			this._commonBits = numBits;
			this._commonSignExp = CommonBits.signExpBits(this._commonBits);
			this._isFirst = false;
			return null;
		}
		var numSignExp = CommonBits.signExpBits(numBits);
		if (numSignExp !== this._commonSignExp) {
			this._commonBits = 0;
			return null;
		}
		this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
		this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
	},
	toString: function () {
		if (arguments.length === 1) {
			let bits = arguments[0];
			var x = __WEBPACK_IMPORTED_MODULE_0__java_lang_Double__["a" /* default */].longBitsToDouble(bits);
			var numStr = Long.toBinaryString(bits);
			var padStr = "0000000000000000000000000000000000000000000000000000000000000000" + numStr;
			var bitStr = padStr.substring(padStr.length - 64);
			var str = bitStr.substring(0, 1) + "  " + bitStr.substring(1, 12) + "(exp) " + bitStr.substring(12) + " [ " + x + " ]";
			return str;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return CommonBits;
	}
});
CommonBits.getBit = function (bits, i) {
	var mask = 1 << i;
	return (bits & mask) !== 0 ? 1 : 0;
};
CommonBits.signExpBits = function (num) {
	return num >> 52;
};
CommonBits.zeroLowerBits = function (bits, nBits) {
	var invMask = (1 << nBits) - 1;
	var mask = ~invMask;
	var zeroed = bits & mask;
	return zeroed;
};
CommonBits.numCommonMostSigMantissaBits = function (num1, num2) {
	var count = 0;
	for (var i = 52; i >= 0; i--) {
		if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;
		count++;
	}
	return 52;
};


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeNodingValidator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noding_BasicSegmentString__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__noding_FastNodingValidator__ = __webpack_require__(233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function EdgeNodingValidator() {
	this._nv = null;
	let edges = arguments[0];
	this._nv = new __WEBPACK_IMPORTED_MODULE_2__noding_FastNodingValidator__["a" /* default */](EdgeNodingValidator.toSegmentStrings(edges));
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeNodingValidator.prototype, {
	checkValid: function () {
		this._nv.checkValid();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeNodingValidator;
	}
});
EdgeNodingValidator.toSegmentStrings = function (edges) {
	var segStrings = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
	for (var i = edges.iterator(); i.hasNext(); ) {
		var e = i.next();
		segStrings.add(new __WEBPACK_IMPORTED_MODULE_0__noding_BasicSegmentString__["a" /* default */](e.getCoordinates(), e));
	}
	return segStrings;
};
EdgeNodingValidator.checkValid = function (edges) {
	var validator = new EdgeNodingValidator(edges);
	validator.checkValid();
};


/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BasicSegmentString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_impl_CoordinateArraySequence__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Octant__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__SegmentString__ = __webpack_require__(94);





function BasicSegmentString() {
	this._pts = null;
	this._data = null;
	let pts = arguments[0], data = arguments[1];
	this._pts = pts;
	this._data = data;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(BasicSegmentString.prototype, {
	getCoordinates: function () {
		return this._pts;
	},
	size: function () {
		return this._pts.length;
	},
	getCoordinate: function (i) {
		return this._pts[i];
	},
	isClosed: function () {
		return this._pts[0].equals(this._pts[this._pts.length - 1]);
	},
	getSegmentOctant: function (index) {
		if (index === this._pts.length - 1) return -1;
		return __WEBPACK_IMPORTED_MODULE_2__Octant__["a" /* default */].octant(this.getCoordinate(index), this.getCoordinate(index + 1));
	},
	setData: function (data) {
		this._data = data;
	},
	getData: function () {
		return this._data;
	},
	toString: function () {
		return __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(new __WEBPACK_IMPORTED_MODULE_1__geom_impl_CoordinateArraySequence__["a" /* default */](this._pts));
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__SegmentString__["a" /* default */]];
	},
	getClass: function () {
		return BasicSegmentString;
	}
});


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = FastNodingValidator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MCIndexNoder__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__InteriorIntersectionFinder__ = __webpack_require__(245);






function FastNodingValidator() {
	this._li = new __WEBPACK_IMPORTED_MODULE_4__algorithm_RobustLineIntersector__["a" /* default */]();
	this._segStrings = null;
	this._findAllIntersections = false;
	this._segInt = null;
	this._isValid = true;
	let segStrings = arguments[0];
	this._segStrings = segStrings;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(FastNodingValidator.prototype, {
	execute: function () {
		if (this._segInt !== null) return null;
		this.checkInteriorIntersections();
	},
	getIntersections: function () {
		return this._segInt.getIntersections();
	},
	isValid: function () {
		this.execute();
		return this._isValid;
	},
	setFindAllIntersections: function (findAllIntersections) {
		this._findAllIntersections = findAllIntersections;
	},
	checkInteriorIntersections: function () {
		this._isValid = true;
		this._segInt = new __WEBPACK_IMPORTED_MODULE_5__InteriorIntersectionFinder__["a" /* default */](this._li);
		this._segInt.setFindAllIntersections(this._findAllIntersections);
		var noder = new __WEBPACK_IMPORTED_MODULE_1__MCIndexNoder__["a" /* default */]();
		noder.setSegmentIntersector(this._segInt);
		noder.computeNodes(this._segStrings);
		if (this._segInt.hasIntersection()) {
			this._isValid = false;
			return null;
		}
	},
	checkValid: function () {
		this.execute();
		if (!this._isValid) throw new __WEBPACK_IMPORTED_MODULE_2__geom_TopologyException__["a" /* default */](this.getErrorMessage(), this._segInt.getInteriorIntersection());
	},
	getErrorMessage: function () {
		if (this._isValid) return "no intersections found";
		var intSegs = this._segInt.getIntersectionSegments();
		return "found non-noded intersection between " + __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(intSegs[0], intSegs[1]) + " and " + __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(intSegs[2], intSegs[3]);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return FastNodingValidator;
	}
});
FastNodingValidator.computeIntersections = function (segStrings) {
	var nv = new FastNodingValidator(segStrings);
	nv.setFindAllIntersections(true);
	nv.isValid();
	return nv.getIntersections();
};


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PriorityQueue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__ = __webpack_require__(1);


function PriorityQueue() {
	this._size = null;
	this._items = null;
	this._size = 0;
	this._items = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
	this._items.add(null);
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(PriorityQueue.prototype, {
	poll: function () {
		if (this.isEmpty()) return null;
		var minItem = this._items.get(1);
		this._items.set(1, this._items.get(this._size));
		this._size -= 1;
		this.reorder(1);
		return minItem;
	},
	size: function () {
		return this._size;
	},
	reorder: function (hole) {
		var child = null;
		var tmp = this._items.get(hole);
		for (; hole * 2 <= this._size; hole = child) {
			child = hole * 2;
			if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;
			if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child)); else break;
		}
		this._items.set(hole, tmp);
	},
	clear: function () {
		this._size = 0;
		this._items.clear();
	},
	isEmpty: function () {
		return this._size === 0;
	},
	add: function (x) {
		this._items.add(null);
		this._size += 1;
		var hole = this._size;
		this._items.set(0, x);
		for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
			this._items.set(hole, this._items.get(Math.trunc(hole / 2)));
		}
		this._items.set(hole, x);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PriorityQueue;
	}
});


/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BoundablePair;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AbstractNode__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__ = __webpack_require__(20);




function BoundablePair() {
	this._boundable1 = null;
	this._boundable2 = null;
	this._distance = null;
	this._itemDistance = null;
	let boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2];
	this._boundable1 = boundable1;
	this._boundable2 = boundable2;
	this._itemDistance = itemDistance;
	this._distance = this.distance();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(BoundablePair.prototype, {
	expandToQueue: function (priQ, minDistance) {
		var isComp1 = BoundablePair.isComposite(this._boundable1);
		var isComp2 = BoundablePair.isComposite(this._boundable2);
		if (isComp1 && isComp2) {
			if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
				this.expand(this._boundable1, this._boundable2, priQ, minDistance);
				return null;
			} else {
				this.expand(this._boundable2, this._boundable1, priQ, minDistance);
				return null;
			}
		} else if (isComp1) {
			this.expand(this._boundable1, this._boundable2, priQ, minDistance);
			return null;
		} else if (isComp2) {
			this.expand(this._boundable2, this._boundable1, priQ, minDistance);
			return null;
		}
		throw new __WEBPACK_IMPORTED_MODULE_0__java_lang_IllegalArgumentException__["a" /* default */]("neither boundable is composite");
	},
	isLeaves: function () {
		return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
	},
	compareTo: function (o) {
		var nd = o;
		if (this._distance < nd._distance) return -1;
		if (this._distance > nd._distance) return 1;
		return 0;
	},
	expand: function (bndComposite, bndOther, priQ, minDistance) {
		var children = bndComposite.getChildBoundables();
		for (var i = children.iterator(); i.hasNext(); ) {
			var child = i.next();
			var bp = new BoundablePair(child, bndOther, this._itemDistance);
			if (bp.getDistance() < minDistance) {
				priQ.add(bp);
			}
		}
	},
	getBoundable: function (i) {
		if (i === 0) return this._boundable1;
		return this._boundable2;
	},
	getDistance: function () {
		return this._distance;
	},
	distance: function () {
		if (this.isLeaves()) {
			return this._itemDistance.distance(this._boundable1, this._boundable2);
		}
		return this._boundable1.getBounds().distance(this._boundable2.getBounds());
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return BoundablePair;
	}
});
BoundablePair.area = function (b) {
	return b.getBounds().getArea();
};
BoundablePair.isComposite = function (item) {
	return item instanceof __WEBPACK_IMPORTED_MODULE_1__AbstractNode__["a" /* default */];
};


/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = AbstractSTRtree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ItemVisitor__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__AbstractNode__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_util_List__ = __webpack_require__(33);










function AbstractSTRtree() {
	this._root = null;
	this._built = false;
	this._itemBoundables = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._nodeCapacity = null;
	if (arguments.length === 0) {
		AbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);
	} else if (arguments.length === 1) {
		let nodeCapacity = arguments[0];
		__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(nodeCapacity > 1, "Node capacity must be greater than 1");
		this._nodeCapacity = nodeCapacity;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(AbstractSTRtree.prototype, {
	getNodeCapacity: function () {
		return this._nodeCapacity;
	},
	lastNode: function (nodes) {
		return nodes.get(nodes.size() - 1);
	},
	size: function () {
		if (arguments.length === 0) {
			if (this.isEmpty()) {
				return 0;
			}
			this.build();
			return this.size(this._root);
		} else if (arguments.length === 1) {
			let node = arguments[0];
			var size = 0;
			for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
				var childBoundable = i.next();
				if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
					size += this.size(childBoundable);
				} else if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */]) {
					size += 1;
				}
			}
			return size;
		}
	},
	removeItem: function (node, item) {
		var childToRemove = null;
		for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
			var childBoundable = i.next();
			if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */]) {
				if (childBoundable.getItem() === item) childToRemove = childBoundable;
			}
		}
		if (childToRemove !== null) {
			node.getChildBoundables().remove(childToRemove);
			return true;
		}
		return false;
	},
	itemsTree: function () {
		if (arguments.length === 0) {
			this.build();
			var valuesTree = this.itemsTree(this._root);
			if (valuesTree === null) return new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
			return valuesTree;
		} else if (arguments.length === 1) {
			let node = arguments[0];
			var valuesTreeForNode = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
			for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
				var childBoundable = i.next();
				if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
					var valuesTreeForChild = this.itemsTree(childBoundable);
					if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
				} else if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */]) {
					valuesTreeForNode.add(childBoundable.getItem());
				} else {
					__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].shouldNeverReachHere();
				}
			}
			if (valuesTreeForNode.size() <= 0) return null;
			return valuesTreeForNode;
		}
	},
	insert: function (bounds, item) {
		__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built.");
		this._itemBoundables.add(new __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */](bounds, item));
	},
	boundablesAtLevel: function () {
		if (arguments.length === 1) {
			let level = arguments[0];
			var boundables = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
			this.boundablesAtLevel(level, this._root, boundables);
			return boundables;
		} else if (arguments.length === 3) {
			let level = arguments[0], top = arguments[1], boundables = arguments[2];
			__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(level > -2);
			if (top.getLevel() === level) {
				boundables.add(top);
				return null;
			}
			for (var i = top.getChildBoundables().iterator(); i.hasNext(); ) {
				var boundable = i.next();
				if (boundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
					this.boundablesAtLevel(level, boundable, boundables);
				} else {
					__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(boundable instanceof __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */]);
					if (level === -1) {
						boundables.add(boundable);
					}
				}
			}
			return null;
		}
	},
	query: function () {
		if (arguments.length === 1) {
			let searchBounds = arguments[0];
			this.build();
			var matches = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
			if (this.isEmpty()) {
				return matches;
			}
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				this.query(searchBounds, this._root, matches);
			}
			return matches;
		} else if (arguments.length === 2) {
			let searchBounds = arguments[0], visitor = arguments[1];
			this.build();
			if (this.isEmpty()) {
				return null;
			}
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				this.query(searchBounds, this._root, visitor);
			}
		} else if (arguments.length === 3) {
			if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_2__ItemVisitor__["a" /* default */]) && (arguments[0] instanceof Object && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */])) {
				let searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];
				var childBoundables = node.getChildBoundables();
				for (var i = 0; i < childBoundables.size(); i++) {
					var childBoundable = childBoundables.get(i);
					if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
						continue;
					}
					if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
						this.query(searchBounds, childBoundable, visitor);
					} else if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */]) {
						visitor.visitItem(childBoundable.getItem());
					} else {
						__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].shouldNeverReachHere();
					}
				}
			} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_9__java_util_List__["a" /* default */]) && (arguments[0] instanceof Object && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */])) {
				let searchBounds = arguments[0], node = arguments[1], matches = arguments[2];
				var childBoundables = node.getChildBoundables();
				for (var i = 0; i < childBoundables.size(); i++) {
					var childBoundable = childBoundables.get(i);
					if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
						continue;
					}
					if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
						this.query(searchBounds, childBoundable, matches);
					} else if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_0__ItemBoundable__["a" /* default */]) {
						matches.add(childBoundable.getItem());
					} else {
						__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].shouldNeverReachHere();
					}
				}
			}
		}
	},
	build: function () {
		if (this._built) return null;
		this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
		this._itemBoundables = null;
		this._built = true;
	},
	getRoot: function () {
		this.build();
		return this._root;
	},
	remove: function () {
		if (arguments.length === 2) {
			let searchBounds = arguments[0], item = arguments[1];
			this.build();
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				return this.remove(searchBounds, this._root, item);
			}
			return false;
		} else if (arguments.length === 3) {
			let searchBounds = arguments[0], node = arguments[1], item = arguments[2];
			var found = this.removeItem(node, item);
			if (found) return true;
			var childToPrune = null;
			for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
				var childBoundable = i.next();
				if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
					continue;
				}
				if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
					found = this.remove(searchBounds, childBoundable, item);
					if (found) {
						childToPrune = childBoundable;
						break;
					}
				}
			}
			if (childToPrune !== null) {
				if (childToPrune.getChildBoundables().isEmpty()) {
					node.getChildBoundables().remove(childToPrune);
				}
			}
			return found;
		}
	},
	createHigherLevels: function (boundablesOfALevel, level) {
		__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(!boundablesOfALevel.isEmpty());
		var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
		if (parentBoundables.size() === 1) {
			return parentBoundables.get(0);
		}
		return this.createHigherLevels(parentBoundables, level + 1);
	},
	depth: function () {
		if (arguments.length === 0) {
			if (this.isEmpty()) {
				return 0;
			}
			this.build();
			return this.depth(this._root);
		} else if (arguments.length === 1) {
			let node = arguments[0];
			var maxChildDepth = 0;
			for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
				var childBoundable = i.next();
				if (childBoundable instanceof __WEBPACK_IMPORTED_MODULE_3__AbstractNode__["a" /* default */]) {
					var childDepth = this.depth(childBoundable);
					if (childDepth > maxChildDepth) maxChildDepth = childDepth;
				}
			}
			return maxChildDepth + 1;
		}
	},
	createParentBoundables: function (childBoundables, newLevel) {
		__WEBPACK_IMPORTED_MODULE_8__util_Assert__["a" /* default */].isTrue(!childBoundables.isEmpty());
		var parentBoundables = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
		parentBoundables.add(this.createNode(newLevel));
		var sortedChildBoundables = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */](childBoundables);
		__WEBPACK_IMPORTED_MODULE_5__java_util_Collections__["a" /* default */].sort(sortedChildBoundables, this.getComparator());
		for (var i = sortedChildBoundables.iterator(); i.hasNext(); ) {
			var childBoundable = i.next();
			if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {
				parentBoundables.add(this.createNode(newLevel));
			}
			this.lastNode(parentBoundables).addChildBoundable(childBoundable);
		}
		return parentBoundables;
	},
	isEmpty: function () {
		if (!this._built) return this._itemBoundables.isEmpty();
		return this._root.isEmpty();
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_7__java_io_Serializable__["a" /* default */]];
	},
	getClass: function () {
		return AbstractSTRtree;
	}
});
AbstractSTRtree.compareDoubles = function (a, b) {
	return a > b ? 1 : a < b ? -1 : 0;
};
function IntersectsOp() {}
AbstractSTRtree.IntersectsOp = IntersectsOp;
AbstractSTRtree.serialVersionUID = -3886435814360241337;
AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;


/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ItemDistance;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function ItemDistance() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(ItemDistance.prototype, {
	distance: function (item1, item2) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ItemDistance;
	}
});


/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SegmentNodeList;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SegmentNode__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Iterator__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NodedSegmentString__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_Integer__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_lang_RuntimeException__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_TreeMap__ = __webpack_require__(35);











function SegmentNodeList() {
	this._nodeMap = new __WEBPACK_IMPORTED_MODULE_10__java_util_TreeMap__["a" /* default */]();
	this._edge = null;
	let edge = arguments[0];
	this._edge = edge;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(SegmentNodeList.prototype, {
	getSplitCoordinates: function () {
		var coordList = new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */]();
		this.addEndpoints();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			this.addEdgeCoordinates(eiPrev, ei, coordList);
			eiPrev = ei;
		}
		return coordList.toCoordinateArray();
	},
	addCollapsedNodes: function () {
		var collapsedVertexIndexes = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */]();
		this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
		this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
		for (var it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {
			var vertexIndex = it.next().intValue();
			this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
		}
	},
	print: function (out) {
		out.println("Intersections:");
		for (var it = this.iterator(); it.hasNext(); ) {
			var ei = it.next();
			ei.print(out);
		}
	},
	findCollapsesFromExistingVertices: function (collapsedVertexIndexes) {
		for (var i = 0; i < this._edge.size() - 2; i++) {
			var p0 = this._edge.getCoordinate(i);
			var p1 = this._edge.getCoordinate(i + 1);
			var p2 = this._edge.getCoordinate(i + 2);
			if (p0.equals2D(p2)) {
				collapsedVertexIndexes.add(new __WEBPACK_IMPORTED_MODULE_6__java_lang_Integer__["a" /* default */](i + 1));
			}
		}
	},
	addEdgeCoordinates: function (ei0, ei1, coordList) {
		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
		var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var ipt = 0;
		coordList.add(new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](ei0.coord), false);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			coordList.add(this._edge.getCoordinate(i));
		}
		if (useIntPt1) {
			coordList.add(new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](ei1.coord));
		}
	},
	iterator: function () {
		return this._nodeMap.values().iterator();
	},
	addSplitEdges: function (edgeList) {
		this.addEndpoints();
		this.addCollapsedNodes();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var newEdge = this.createSplitEdge(eiPrev, ei);
			edgeList.add(newEdge);
			eiPrev = ei;
		}
	},
	findCollapseIndex: function (ei0, ei1, collapsedVertexIndex) {
		if (!ei0.coord.equals2D(ei1.coord)) return false;
		var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
		if (!ei1.isInterior()) {
			numVerticesBetween--;
		}
		if (numVerticesBetween === 1) {
			collapsedVertexIndex[0] = ei0.segmentIndex + 1;
			return true;
		}
		return false;
	},
	findCollapsesFromInsertedNodes: function (collapsedVertexIndexes) {
		var collapsedVertexIndex = new Array(1).fill(null);
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
			if (isCollapsed) collapsedVertexIndexes.add(new __WEBPACK_IMPORTED_MODULE_6__java_lang_Integer__["a" /* default */](collapsedVertexIndex[0]));
			eiPrev = ei;
		}
	},
	getEdge: function () {
		return this._edge;
	},
	addEndpoints: function () {
		var maxSegIndex = this._edge.size() - 1;
		this.add(this._edge.getCoordinate(0), 0);
		this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
	},
	createSplitEdge: function (ei0, ei1) {
		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
		var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var pts = new Array(npts).fill(null);
		var ipt = 0;
		pts[ipt++] = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](ei0.coord);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			pts[ipt++] = this._edge.getCoordinate(i);
		}
		if (useIntPt1) pts[ipt] = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */](ei1.coord);
		return new __WEBPACK_IMPORTED_MODULE_4__NodedSegmentString__["a" /* default */](pts, this._edge.getData());
	},
	add: function (intPt, segmentIndex) {
		var eiNew = new __WEBPACK_IMPORTED_MODULE_1__SegmentNode__["a" /* default */](this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
		var ei = this._nodeMap.get(eiNew);
		if (ei !== null) {
			__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(ei.coord.equals2D(intPt), "Found equal nodes with different coordinates");
			return ei;
		}
		this._nodeMap.put(eiNew, eiNew);
		return eiNew;
	},
	checkSplitEdgesCorrectness: function (splitEdges) {
		var edgePts = this._edge.getCoordinates();
		var split0 = splitEdges.get(0);
		var pt0 = split0.getCoordinate(0);
		if (!pt0.equals2D(edgePts[0])) throw new __WEBPACK_IMPORTED_MODULE_8__java_lang_RuntimeException__["a" /* default */]("bad split edge start point at " + pt0);
		var splitn = splitEdges.get(splitEdges.size() - 1);
		var splitnPts = splitn.getCoordinates();
		var ptn = splitnPts[splitnPts.length - 1];
		if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new __WEBPACK_IMPORTED_MODULE_8__java_lang_RuntimeException__["a" /* default */]("bad split edge end point at " + ptn);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SegmentNodeList;
	}
});
function NodeVertexIterator() {
	this._nodeList = null;
	this._edge = null;
	this._nodeIt = null;
	this._currNode = null;
	this._nextNode = null;
	this._currSegIndex = 0;
	let nodeList = arguments[0];
	this._nodeList = nodeList;
	this._edge = nodeList.getEdge();
	this._nodeIt = nodeList.iterator();
	this.readNextNode();
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(NodeVertexIterator.prototype, {
	next: function () {
		if (this._currNode === null) {
			this._currNode = this._nextNode;
			this._currSegIndex = this._currNode.segmentIndex;
			this.readNextNode();
			return this._currNode;
		}
		if (this._nextNode === null) return null;
		if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
			this._currNode = this._nextNode;
			this._currSegIndex = this._currNode.segmentIndex;
			this.readNextNode();
			return this._currNode;
		}
		if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}
		return null;
	},
	remove: function () {
		throw new UnsupportedOperationException(this.getClass().getName());
	},
	hasNext: function () {
		if (this._nextNode === null) return false;
		return true;
	},
	readNextNode: function () {
		if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__java_util_Iterator__["a" /* default */]];
	},
	getClass: function () {
		return NodeVertexIterator;
	}
});


/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SegmentNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SegmentPointComparator__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__ = __webpack_require__(20);




function SegmentNode() {
	this._segString = null;
	this.coord = null;
	this.segmentIndex = null;
	this._segmentOctant = null;
	this._isInterior = null;
	let segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3];
	this._segString = segString;
	this.coord = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](coord);
	this.segmentIndex = segmentIndex;
	this._segmentOctant = segmentOctant;
	this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(SegmentNode.prototype, {
	getCoordinate: function () {
		return this.coord;
	},
	print: function (out) {
		out.print(this.coord);
		out.print(" seg # = " + this.segmentIndex);
	},
	compareTo: function (obj) {
		var other = obj;
		if (this.segmentIndex < other.segmentIndex) return -1;
		if (this.segmentIndex > other.segmentIndex) return 1;
		if (this.coord.equals2D(other.coord)) return 0;
		return __WEBPACK_IMPORTED_MODULE_2__SegmentPointComparator__["a" /* default */].compare(this._segmentOctant, this.coord, other.coord);
	},
	isEndPoint: function (maxSegmentIndex) {
		if (this.segmentIndex === 0 && !this._isInterior) return true;
		if (this.segmentIndex === maxSegmentIndex) return true;
		return false;
	},
	isInterior: function () {
		return this._isInterior;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return SegmentNode;
	}
});


/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SegmentPointComparator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_Assert__ = __webpack_require__(4);


function SegmentPointComparator() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(SegmentPointComparator.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SegmentPointComparator;
	}
});
SegmentPointComparator.relativeSign = function (x0, x1) {
	if (x0 < x1) return -1;
	if (x0 > x1) return 1;
	return 0;
};
SegmentPointComparator.compare = function (octant, p0, p1) {
	if (p0.equals2D(p1)) return 0;
	var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
	var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
	switch (octant) {
		case 0:
			return SegmentPointComparator.compareValue(xSign, ySign);
		case 1:
			return SegmentPointComparator.compareValue(ySign, xSign);
		case 2:
			return SegmentPointComparator.compareValue(ySign, -xSign);
		case 3:
			return SegmentPointComparator.compareValue(-xSign, ySign);
		case 4:
			return SegmentPointComparator.compareValue(-xSign, -ySign);
		case 5:
			return SegmentPointComparator.compareValue(-ySign, -xSign);
		case 6:
			return SegmentPointComparator.compareValue(-ySign, xSign);
		case 7:
			return SegmentPointComparator.compareValue(xSign, -ySign);
	}
	__WEBPACK_IMPORTED_MODULE_1__util_Assert__["a" /* default */].shouldNeverReachHere("invalid octant value");
	return 0;
};
SegmentPointComparator.compareValue = function (compareSign0, compareSign1) {
	if (compareSign0 < 0) return -1;
	if (compareSign0 > 0) return 1;
	if (compareSign1 < 0) return -1;
	if (compareSign1 > 0) return 1;
	return 0;
};


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodableSegmentString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SegmentString__ = __webpack_require__(94);


function NodableSegmentString() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NodableSegmentString.prototype, {
	addIntersection: function (intPt, segmentIndex) {},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__SegmentString__["a" /* default */]];
	},
	getClass: function () {
		return NodableSegmentString;
	}
});


/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChainOverlapAction;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__ = __webpack_require__(7);



function MonotoneChainOverlapAction() {
	this.tempEnv1 = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */]();
	this.tempEnv2 = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */]();
	this._overlapSeg1 = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]();
	this._overlapSeg2 = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonotoneChainOverlapAction.prototype, {
	overlap: function () {
		if (arguments.length === 2) {
			let seg1 = arguments[0], seg2 = arguments[1];
		} else if (arguments.length === 4) {
			let mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];
			mc1.getLineSegment(start1, this._overlapSeg1);
			mc2.getLineSegment(start2, this._overlapSeg2);
			this.overlap(this._overlapSeg1, this._overlapSeg2);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChainOverlapAction;
	}
});


/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChain;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Envelope__ = __webpack_require__(7);


function MonotoneChain() {
	this._pts = null;
	this._start = null;
	this._end = null;
	this._env = null;
	this._context = null;
	this._id = null;
	let pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3];
	this._pts = pts;
	this._start = start;
	this._end = end;
	this._context = context;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonotoneChain.prototype, {
	getLineSegment: function (index, ls) {
		ls.p0 = this._pts[index];
		ls.p1 = this._pts[index + 1];
	},
	computeSelect: function (searchEnv, start0, end0, mcs) {
		var p0 = this._pts[start0];
		var p1 = this._pts[end0];
		mcs.tempEnv1.init(p0, p1);
		if (end0 - start0 === 1) {
			mcs.select(this, start0);
			return null;
		}
		if (!searchEnv.intersects(mcs.tempEnv1)) return null;
		var mid = Math.trunc((start0 + end0) / 2);
		if (start0 < mid) {
			this.computeSelect(searchEnv, start0, mid, mcs);
		}
		if (mid < end0) {
			this.computeSelect(searchEnv, mid, end0, mcs);
		}
	},
	getCoordinates: function () {
		var coord = new Array(this._end - this._start + 1).fill(null);
		var index = 0;
		for (var i = this._start; i <= this._end; i++) {
			coord[index++] = this._pts[i];
		}
		return coord;
	},
	computeOverlaps: function (mc, mco) {
		this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
	},
	setId: function (id) {
		this._id = id;
	},
	select: function (searchEnv, mcs) {
		this.computeSelect(searchEnv, this._start, this._end, mcs);
	},
	getEnvelope: function () {
		if (this._env === null) {
			var p0 = this._pts[this._start];
			var p1 = this._pts[this._end];
			this._env = new __WEBPACK_IMPORTED_MODULE_1__geom_Envelope__["a" /* default */](p0, p1);
		}
		return this._env;
	},
	getEndIndex: function () {
		return this._end;
	},
	getStartIndex: function () {
		return this._start;
	},
	getContext: function () {
		return this._context;
	},
	getId: function () {
		return this._id;
	},
	computeOverlapsInternal: function (start0, end0, mc, start1, end1, mco) {
		var p00 = this._pts[start0];
		var p01 = this._pts[end0];
		var p10 = mc._pts[start1];
		var p11 = mc._pts[end1];
		if (end0 - start0 === 1 && end1 - start1 === 1) {
			mco.overlap(this, start0, mc, start1);
			return null;
		}
		mco.tempEnv1.init(p00, p01);
		mco.tempEnv2.init(p10, p11);
		if (!mco.tempEnv1.intersects(mco.tempEnv2)) return null;
		var mid0 = Math.trunc((start0 + end0) / 2);
		var mid1 = Math.trunc((start1 + end1) / 2);
		if (start0 < mid0) {
			if (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);
			if (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);
		}
		if (mid0 < end0) {
			if (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);
			if (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChain;
	}
});


/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SinglePassNoder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Noder__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function SinglePassNoder() {
	this._segInt = null;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		let segInt = arguments[0];
		this.setSegmentIntersector(segInt);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(SinglePassNoder.prototype, {
	setSegmentIntersector: function (segInt) {
		this._segInt = segInt;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_0__Noder__["a" /* default */]];
	},
	getClass: function () {
		return SinglePassNoder;
	}
});


/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = InteriorIntersectionFinder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SegmentIntersector__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);



function InteriorIntersectionFinder() {
	this._findAllIntersections = false;
	this._isCheckEndSegmentsOnly = false;
	this._li = null;
	this._interiorIntersection = null;
	this._intSegments = null;
	this._intersections = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
	this._intersectionCount = 0;
	this._keepIntersections = true;
	let li = arguments[0];
	this._li = li;
	this._interiorIntersection = null;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(InteriorIntersectionFinder.prototype, {
	getInteriorIntersection: function () {
		return this._interiorIntersection;
	},
	setCheckEndSegmentsOnly: function (isCheckEndSegmentsOnly) {
		this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
	},
	getIntersectionSegments: function () {
		return this._intSegments;
	},
	count: function () {
		return this._intersectionCount;
	},
	getIntersections: function () {
		return this._intersections;
	},
	setFindAllIntersections: function (findAllIntersections) {
		this._findAllIntersections = findAllIntersections;
	},
	setKeepIntersections: function (keepIntersections) {
		this._keepIntersections = keepIntersections;
	},
	processIntersections: function (e0, segIndex0, e1, segIndex1) {
		if (!this._findAllIntersections && this.hasIntersection()) return null;
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		if (this._isCheckEndSegmentsOnly) {
			var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
			if (!isEndSegPresent) return null;
		}
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._li.isInteriorIntersection()) {
				this._intSegments = new Array(4).fill(null);
				this._intSegments[0] = p00;
				this._intSegments[1] = p01;
				this._intSegments[2] = p10;
				this._intSegments[3] = p11;
				this._interiorIntersection = this._li.getIntersection(0);
				if (this._keepIntersections) this._intersections.add(this._interiorIntersection);
				this._intersectionCount++;
			}
		}
	},
	isEndSegment: function (segStr, index) {
		if (index === 0) return true;
		if (index >= segStr.size() - 2) return true;
		return false;
	},
	hasIntersection: function () {
		return this._interiorIntersection !== null;
	},
	isDone: function () {
		if (this._findAllIntersections) return false;
		return this._interiorIntersection !== null;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__SegmentIntersector__["a" /* default */]];
	},
	getClass: function () {
		return InteriorIntersectionFinder;
	}
});
InteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {
	var finder = new InteriorIntersectionFinder(li);
	finder.setFindAllIntersections(true);
	return finder;
};
InteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {
	return new InteriorIntersectionFinder(li);
};
InteriorIntersectionFinder.createIntersectionCounter = function (li) {
	var finder = new InteriorIntersectionFinder(li);
	finder.setFindAllIntersections(true);
	finder.setKeepIntersections(false);
	return finder;
};


/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryCollectionMapper;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);



function GeometryCollectionMapper() {
	this._mapOp = null;
	let mapOp = arguments[0];
	this._mapOp = mapOp;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(GeometryCollectionMapper.prototype, {
	map: function (gc) {
		var mapped = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = this._mapOp.map(gc.getGeometryN(i));
			if (!g.isEmpty()) mapped.add(g);
		}
		return gc.getFactory().createGeometryCollection(__WEBPACK_IMPORTED_MODULE_0__GeometryFactory__["a" /* default */].toGeometryArray(mapped));
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryCollectionMapper;
	}
});
GeometryCollectionMapper.map = function (gc, op) {
	var mapper = new GeometryCollectionMapper(op);
	return mapper.map(gc);
};


/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MinimalEdgeRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeRing__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function MinimalEdgeRing() {
	let start = arguments[0], geometryFactory = arguments[1];
	__WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeRing__["a" /* default */].call(this, start, geometryFactory);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(MinimalEdgeRing, __WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeRing__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MinimalEdgeRing.prototype, {
	setEdgeRing: function (de, er) {
		de.setMinEdgeRing(er);
	},
	getNext: function (de) {
		return de.getNextMin();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MinimalEdgeRing;
	}
});


/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TopologyLocation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);




function TopologyLocation() {
	this.location = null;
	if (arguments.length === 1) {
		if (arguments[0] instanceof Array) {
			let location = arguments[0];
			this.init(location.length);
		} else if (Number.isInteger(arguments[0])) {
			let on = arguments[0];
			this.init(1);
			this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON] = on;
		} else if (arguments[0] instanceof TopologyLocation) {
			let gl = arguments[0];
			this.init(gl.location.length);
			if (gl !== null) {
				for (var i = 0; i < this.location.length; i++) {
					this.location[i] = gl.location[i];
				}
			}
		}
	} else if (arguments.length === 3) {
		let on = arguments[0], left = arguments[1], right = arguments[2];
		this.init(3);
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON] = on;
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT] = left;
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT] = right;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(TopologyLocation.prototype, {
	setAllLocations: function (locValue) {
		for (var i = 0; i < this.location.length; i++) {
			this.location[i] = locValue;
		}
	},
	isNull: function () {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] !== __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) return false;
		}
		return true;
	},
	setAllLocationsIfNull: function (locValue) {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) this.location[i] = locValue;
		}
	},
	isLine: function () {
		return this.location.length === 1;
	},
	merge: function (gl) {
		if (gl.location.length > this.location.length) {
			var newLoc = new Array(3).fill(null);
			newLoc[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON] = this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON];
			newLoc[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT] = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE;
			newLoc[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT] = __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE;
			this.location = newLoc;
		}
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE && i < gl.location.length) this.location[i] = gl.location[i];
		}
	},
	getLocations: function () {
		return this.location;
	},
	flip: function () {
		if (this.location.length <= 1) return null;
		var temp = this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT];
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT] = this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT];
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT] = temp;
	},
	toString: function () {
		var buf = new __WEBPACK_IMPORTED_MODULE_0__java_lang_StringBuffer__["a" /* default */]();
		if (this.location.length > 1) buf.append(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].toLocationSymbol(this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT]));
		buf.append(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].toLocationSymbol(this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON]));
		if (this.location.length > 1) buf.append(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].toLocationSymbol(this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT]));
		return buf.toString();
	},
	setLocations: function (on, left, right) {
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON] = on;
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].LEFT] = left;
		this.location[__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].RIGHT] = right;
	},
	get: function (posIndex) {
		if (posIndex < this.location.length) return this.location[posIndex];
		return __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE;
	},
	isArea: function () {
		return this.location.length > 1;
	},
	isAnyNull: function () {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE) return true;
		}
		return false;
	},
	setLocation: function () {
		if (arguments.length === 1) {
			let locValue = arguments[0];
			this.setLocation(__WEBPACK_IMPORTED_MODULE_2__Position__["a" /* default */].ON, locValue);
		} else if (arguments.length === 2) {
			let locIndex = arguments[0], locValue = arguments[1];
			this.location[locIndex] = locValue;
		}
	},
	init: function (size) {
		this.location = new Array(size).fill(null);
		this.setAllLocations(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].NONE);
	},
	isEqualOnSide: function (le, locIndex) {
		return this.location[locIndex] === le.location[locIndex];
	},
	allPositionsEqual: function (loc) {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] !== loc) return false;
		}
		return true;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TopologyLocation;
	}
});


/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__OverlayOp__ = __webpack_require__(42);




function LineBuilder() {
	this._op = null;
	this._geometryFactory = null;
	this._ptLocator = null;
	this._lineEdgesList = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
	this._resultLineList = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
	let op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];
	this._op = op;
	this._geometryFactory = geometryFactory;
	this._ptLocator = ptLocator;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(LineBuilder.prototype, {
	collectLines: function (opCode) {
		for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
			var de = it.next();
			this.collectLineEdge(de, opCode, this._lineEdgesList);
			this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);
		}
	},
	labelIsolatedLine: function (e, targetIndex) {
		var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
		e.getLabel().setLocation(targetIndex, loc);
	},
	build: function (opCode) {
		this.findCoveredLineEdges();
		this.collectLines(opCode);
		this.buildLines(opCode);
		return this._resultLineList;
	},
	collectLineEdge: function (de, opCode, edges) {
		var label = de.getLabel();
		var e = de.getEdge();
		if (de.isLineEdge()) {
			if (!de.isVisited() && __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].isResultOfOp(label, opCode) && !e.isCovered()) {
				edges.add(e);
				de.setVisitedEdge(true);
			}
		}
	},
	findCoveredLineEdges: function () {
		for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
			var node = nodeit.next();
			node.getEdges().findCoveredLineEdges();
		}
		for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
			var de = it.next();
			var e = de.getEdge();
			if (de.isLineEdge() && !e.isCoveredSet()) {
				var isCovered = this._op.isCoveredByA(de.getCoordinate());
				e.setCovered(isCovered);
			}
		}
	},
	labelIsolatedLines: function (edgesList) {
		for (var it = edgesList.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			if (e.isIsolated()) {
				if (label.isNull(0)) this.labelIsolatedLine(e, 0); else this.labelIsolatedLine(e, 1);
			}
		}
	},
	buildLines: function (opCode) {
		for (var it = this._lineEdgesList.iterator(); it.hasNext(); ) {
			var e = it.next();
			var label = e.getLabel();
			var line = this._geometryFactory.createLineString(e.getCoordinates());
			this._resultLineList.add(line);
			e.setInResult(true);
		}
	},
	collectBoundaryTouchEdge: function (de, opCode, edges) {
		var label = de.getLabel();
		if (de.isLineEdge()) return null;
		if (de.isVisited()) return null;
		if (de.isInteriorAreaEdge()) return null;
		if (de.getEdge().isInResult()) return null;
		__WEBPACK_IMPORTED_MODULE_2__util_Assert__["a" /* default */].isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
		if (__WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].isResultOfOp(label, opCode) && opCode === __WEBPACK_IMPORTED_MODULE_3__OverlayOp__["a" /* default */].INTERSECTION) {
			edges.add(de.getEdge());
			de.setVisitedEdge(true);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineBuilder;
	}
});


/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PointBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__OverlayOp__ = __webpack_require__(42);



function PointBuilder() {
	this._op = null;
	this._geometryFactory = null;
	this._resultPointList = new __WEBPACK_IMPORTED_MODULE_1__java_util_ArrayList__["a" /* default */]();
	let op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];
	this._op = op;
	this._geometryFactory = geometryFactory;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(PointBuilder.prototype, {
	filterCoveredNodeToPoint: function (n) {
		var coord = n.getCoordinate();
		if (!this._op.isCoveredByLA(coord)) {
			var pt = this._geometryFactory.createPoint(coord);
			this._resultPointList.add(pt);
		}
	},
	extractNonCoveredResultNodes: function (opCode) {
		for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
			var n = nodeit.next();
			if (n.isInResult()) continue;
			if (n.isIncidentEdgeInResult()) continue;
			if (n.getEdges().getDegree() === 0 || opCode === __WEBPACK_IMPORTED_MODULE_2__OverlayOp__["a" /* default */].INTERSECTION) {
				var label = n.getLabel();
				if (__WEBPACK_IMPORTED_MODULE_2__OverlayOp__["a" /* default */].isResultOfOp(label, opCode)) {
					this.filterCoveredNodeToPoint(n);
				}
			}
		}
	},
	build: function (opCode) {
		this.extractNonCoveredResultNodes(opCode);
		return this._resultPointList;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PointBuilder;
	}
});


/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DirectedEdgeStar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EdgeEndStar__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Quadrant__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__inherits__ = __webpack_require__(3);











function DirectedEdgeStar() {
	__WEBPACK_IMPORTED_MODULE_4__EdgeEndStar__["a" /* default */].apply(this);
	this._resultAreaEdgeList = null;
	this._label = null;
	this._SCANNING_FOR_INCOMING = 1;
	this._LINKING_TO_OUTGOING = 2;
}
Object(__WEBPACK_IMPORTED_MODULE_10__inherits__["a" /* default */])(DirectedEdgeStar, __WEBPACK_IMPORTED_MODULE_4__EdgeEndStar__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(DirectedEdgeStar.prototype, {
	linkResultDirectedEdges: function () {
		this.getResultAreaEdges();
		var firstOut = null;
		var incoming = null;
		var state = this._SCANNING_FOR_INCOMING;
		for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
			var nextOut = this._resultAreaEdgeList.get(i);
			var nextIn = nextOut.getSym();
			if (!nextOut.getLabel().isArea()) continue;
			if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
			switch (state) {
				case this._SCANNING_FOR_INCOMING:
					if (!nextIn.isInResult()) continue;
					incoming = nextIn;
					state = this._LINKING_TO_OUTGOING;
					break;
				case this._LINKING_TO_OUTGOING:
					if (!nextOut.isInResult()) continue;
					incoming.setNext(nextOut);
					state = this._SCANNING_FOR_INCOMING;
					break;
			}
		}
		if (state === this._LINKING_TO_OUTGOING) {
			if (firstOut === null) throw new __WEBPACK_IMPORTED_MODULE_2__geom_TopologyException__["a" /* default */]("no outgoing dirEdge found", this.getCoordinate());
			__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(firstOut.isInResult(), "unable to link last incoming dirEdge");
			incoming.setNext(firstOut);
		}
	},
	insert: function (ee) {
		var de = ee;
		this.insertEdgeEnd(de, de);
	},
	getRightmostEdge: function () {
		var edges = this.getEdges();
		var size = edges.size();
		if (size < 1) return null;
		var de0 = edges.get(0);
		if (size === 1) return de0;
		var deLast = edges.get(size - 1);
		var quad0 = de0.getQuadrant();
		var quad1 = deLast.getQuadrant();
		if (__WEBPACK_IMPORTED_MODULE_8__Quadrant__["a" /* default */].isNorthern(quad0) && __WEBPACK_IMPORTED_MODULE_8__Quadrant__["a" /* default */].isNorthern(quad1)) return de0; else if (!__WEBPACK_IMPORTED_MODULE_8__Quadrant__["a" /* default */].isNorthern(quad0) && !__WEBPACK_IMPORTED_MODULE_8__Quadrant__["a" /* default */].isNorthern(quad1)) return deLast; else {
			var nonHorizontalEdge = null;
			if (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast;
		}
		__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].shouldNeverReachHere("found two horizontal edges incident on node");
		return null;
	},
	print: function (out) {
		__WEBPACK_IMPORTED_MODULE_5__java_lang_System__["a" /* default */].out.println("DirectedEdgeStar: " + this.getCoordinate());
		for (var it = this.iterator(); it.hasNext(); ) {
			var de = it.next();
			out.print("out ");
			de.print(out);
			out.println();
			out.print("in ");
			de.getSym().print(out);
			out.println();
		}
	},
	getResultAreaEdges: function () {
		if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
		this._resultAreaEdgeList = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */]();
		for (var it = this.iterator(); it.hasNext(); ) {
			var de = it.next();
			if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
		}
		return this._resultAreaEdgeList;
	},
	updateLabelling: function (nodeLabel) {
		for (var it = this.iterator(); it.hasNext(); ) {
			var de = it.next();
			var label = de.getLabel();
			label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
			label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
		}
	},
	linkAllDirectedEdges: function () {
		this.getEdges();
		var prevOut = null;
		var firstIn = null;
		for (var i = this._edgeList.size() - 1; i >= 0; i--) {
			var nextOut = this._edgeList.get(i);
			var nextIn = nextOut.getSym();
			if (firstIn === null) firstIn = nextIn;
			if (prevOut !== null) nextIn.setNext(prevOut);
			prevOut = nextOut;
		}
		firstIn.setNext(prevOut);
	},
	computeDepths: function () {
		if (arguments.length === 1) {
			let de = arguments[0];
			var edgeIndex = this.findIndex(de);
			var label = de.getLabel();
			var startDepth = de.getDepth(__WEBPACK_IMPORTED_MODULE_1__Position__["a" /* default */].LEFT);
			var targetLastDepth = de.getDepth(__WEBPACK_IMPORTED_MODULE_1__Position__["a" /* default */].RIGHT);
			var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
			var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
			if (lastDepth !== targetLastDepth) throw new __WEBPACK_IMPORTED_MODULE_2__geom_TopologyException__["a" /* default */]("depth mismatch at " + de.getCoordinate());
		} else if (arguments.length === 3) {
			let startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2];
			var currDepth = startDepth;
			for (var i = startIndex; i < endIndex; i++) {
				var nextDe = this._edgeList.get(i);
				var label = nextDe.getLabel();
				nextDe.setEdgeDepths(__WEBPACK_IMPORTED_MODULE_1__Position__["a" /* default */].RIGHT, currDepth);
				currDepth = nextDe.getDepth(__WEBPACK_IMPORTED_MODULE_1__Position__["a" /* default */].LEFT);
			}
			return currDepth;
		}
	},
	mergeSymLabels: function () {
		for (var it = this.iterator(); it.hasNext(); ) {
			var de = it.next();
			var label = de.getLabel();
			label.merge(de.getSym().getLabel());
		}
	},
	linkMinimalDirectedEdges: function (er) {
		var firstOut = null;
		var incoming = null;
		var state = this._SCANNING_FOR_INCOMING;
		for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
			var nextOut = this._resultAreaEdgeList.get(i);
			var nextIn = nextOut.getSym();
			if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
			switch (state) {
				case this._SCANNING_FOR_INCOMING:
					if (nextIn.getEdgeRing() !== er) continue;
					incoming = nextIn;
					state = this._LINKING_TO_OUTGOING;
					break;
				case this._LINKING_TO_OUTGOING:
					if (nextOut.getEdgeRing() !== er) continue;
					incoming.setNextMin(nextOut);
					state = this._SCANNING_FOR_INCOMING;
					break;
			}
		}
		if (state === this._LINKING_TO_OUTGOING) {
			__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(firstOut !== null, "found null for first outgoing dirEdge");
			__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(firstOut.getEdgeRing() === er, "unable to link last incoming dirEdge");
			incoming.setNextMin(firstOut);
		}
	},
	getOutgoingDegree: function () {
		if (arguments.length === 0) {
			var degree = 0;
			for (var it = this.iterator(); it.hasNext(); ) {
				var de = it.next();
				if (de.isInResult()) degree++;
			}
			return degree;
		} else if (arguments.length === 1) {
			let er = arguments[0];
			var degree = 0;
			for (var it = this.iterator(); it.hasNext(); ) {
				var de = it.next();
				if (de.getEdgeRing() === er) degree++;
			}
			return degree;
		}
	},
	getLabel: function () {
		return this._label;
	},
	findCoveredLineEdges: function () {
		var startLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE;
		for (var it = this.iterator(); it.hasNext(); ) {
			var nextOut = it.next();
			var nextIn = nextOut.getSym();
			if (!nextOut.isLineEdge()) {
				if (nextOut.isInResult()) {
					startLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
					break;
				}
				if (nextIn.isInResult()) {
					startLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
					break;
				}
			}
		}
		if (startLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE) return null;
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext(); ) {
			var nextOut = it.next();
			var nextIn = nextOut.getSym();
			if (nextOut.isLineEdge()) {
				nextOut.getEdge().setCovered(currLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
			} else {
				if (nextOut.isInResult()) currLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
				if (nextIn.isInResult()) currLoc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
			}
		}
	},
	computeLabelling: function (geom) {
		__WEBPACK_IMPORTED_MODULE_4__EdgeEndStar__["a" /* default */].prototype.computeLabelling.call(this, geom);
		this._label = new __WEBPACK_IMPORTED_MODULE_6__Label__["a" /* default */](__WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE);
		for (var it = this.iterator(); it.hasNext(); ) {
			var ee = it.next();
			var e = ee.getEdge();
			var eLabel = e.getLabel();
			for (var i = 0; i < 2; i++) {
				var eLoc = eLabel.getLocation(i);
				if (eLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR || eLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) this._label.setLocation(i, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DirectedEdgeStar;
	}
});


/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SimpleMCSweepLineIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MonotoneChain__ = __webpack_require__(253);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SweepLineEvent__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__EdgeSetIntersector__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__SegmentIntersector__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_util_List__ = __webpack_require__(33);










function SimpleMCSweepLineIntersector() {
	__WEBPACK_IMPORTED_MODULE_3__EdgeSetIntersector__["a" /* default */].apply(this);
	this.events = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */]();
	this.nOverlaps = null;
}
Object(__WEBPACK_IMPORTED_MODULE_8__inherits__["a" /* default */])(SimpleMCSweepLineIntersector, __WEBPACK_IMPORTED_MODULE_3__EdgeSetIntersector__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(SimpleMCSweepLineIntersector.prototype, {
	prepareEvents: function () {
		__WEBPACK_IMPORTED_MODULE_5__java_util_Collections__["a" /* default */].sort(this.events);
		for (var i = 0; i < this.events.size(); i++) {
			var ev = this.events.get(i);
			if (ev.isDelete()) {
				ev.getInsertEvent().setDeleteEventIndex(i);
			}
		}
	},
	computeIntersections: function () {
		if (arguments.length === 1) {
			let si = arguments[0];
			this.nOverlaps = 0;
			this.prepareEvents();
			for (var i = 0; i < this.events.size(); i++) {
				var ev = this.events.get(i);
				if (ev.isInsert()) {
					this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
				}
				if (si.isDone()) {
					break;
				}
			}
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof __WEBPACK_IMPORTED_MODULE_6__SegmentIntersector__["a" /* default */] && (Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_9__java_util_List__["a" /* default */]) && Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_9__java_util_List__["a" /* default */]))) {
				let edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];
				this.addEdges(edges0, edges0);
				this.addEdges(edges1, edges1);
				this.computeIntersections(si);
			} else if (typeof arguments[2] === "boolean" && (Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_9__java_util_List__["a" /* default */]) && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_6__SegmentIntersector__["a" /* default */])) {
				let edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];
				if (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);
				this.computeIntersections(si);
			}
		}
	},
	addEdge: function (edge, edgeSet) {
		var mce = edge.getMonotoneChainEdge();
		var startIndex = mce.getStartIndexes();
		for (var i = 0; i < startIndex.length - 1; i++) {
			var mc = new __WEBPACK_IMPORTED_MODULE_1__MonotoneChain__["a" /* default */](mce, i);
			var insertEvent = new __WEBPACK_IMPORTED_MODULE_2__SweepLineEvent__["a" /* default */](edgeSet, mce.getMinX(i), mc);
			this.events.add(insertEvent);
			this.events.add(new __WEBPACK_IMPORTED_MODULE_2__SweepLineEvent__["a" /* default */](mce.getMaxX(i), insertEvent));
		}
	},
	processOverlaps: function (start, end, ev0, si) {
		var mc0 = ev0.getObject();
		for (var i = start; i < end; i++) {
			var ev1 = this.events.get(i);
			if (ev1.isInsert()) {
				var mc1 = ev1.getObject();
				if (!ev0.isSameLabel(ev1)) {
					mc0.computeIntersections(mc1, si);
					this.nOverlaps++;
				}
			}
		}
	},
	addEdges: function () {
		if (arguments.length === 1) {
			let edges = arguments[0];
			for (var i = edges.iterator(); i.hasNext(); ) {
				var edge = i.next();
				this.addEdge(edge, edge);
			}
		} else if (arguments.length === 2) {
			let edges = arguments[0], edgeSet = arguments[1];
			for (var i = edges.iterator(); i.hasNext(); ) {
				var edge = i.next();
				this.addEdge(edge, edgeSet);
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SimpleMCSweepLineIntersector;
	}
});


/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChain;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function MonotoneChain() {
	this.mce = null;
	this.chainIndex = null;
	let mce = arguments[0], chainIndex = arguments[1];
	this.mce = mce;
	this.chainIndex = chainIndex;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonotoneChain.prototype, {
	computeIntersections: function (mc, si) {
		this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChain;
	}
});


/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SweepLineEvent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Comparable__ = __webpack_require__(20);


function SweepLineEvent() {
	this._label = null;
	this._xValue = null;
	this._eventType = null;
	this._insertEvent = null;
	this._deleteEventIndex = null;
	this._obj = null;
	if (arguments.length === 2) {
		let x = arguments[0], insertEvent = arguments[1];
		this._eventType = SweepLineEvent.DELETE;
		this._xValue = x;
		this._insertEvent = insertEvent;
	} else if (arguments.length === 3) {
		let label = arguments[0], x = arguments[1], obj = arguments[2];
		this._eventType = SweepLineEvent.INSERT;
		this._label = label;
		this._xValue = x;
		this._obj = obj;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(SweepLineEvent.prototype, {
	isDelete: function () {
		return this._eventType === SweepLineEvent.DELETE;
	},
	setDeleteEventIndex: function (deleteEventIndex) {
		this._deleteEventIndex = deleteEventIndex;
	},
	getObject: function () {
		return this._obj;
	},
	compareTo: function (o) {
		var pe = o;
		if (this._xValue < pe._xValue) return -1;
		if (this._xValue > pe._xValue) return 1;
		if (this._eventType < pe._eventType) return -1;
		if (this._eventType > pe._eventType) return 1;
		return 0;
	},
	getInsertEvent: function () {
		return this._insertEvent;
	},
	isInsert: function () {
		return this._eventType === SweepLineEvent.INSERT;
	},
	isSameLabel: function (ev) {
		if (this._label === null) return false;
		return this._label === ev._label;
	},
	getDeleteEventIndex: function () {
		return this._deleteEventIndex;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return SweepLineEvent;
	}
});
SweepLineEvent.INSERT = 1;
SweepLineEvent.DELETE = 2;


/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeSetIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function EdgeSetIntersector() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(EdgeSetIntersector.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeSetIntersector;
	}
});


/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IndexedPointInAreaLocator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_ItemVisitor__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PointOnGeometryLocator__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__index_intervalrtree_SortedPackedIntervalRTree__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_util_LinearComponentExtracter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__index_ArrayListVisitor__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__RayCrossingCounter__ = __webpack_require__(123);











function IndexedPointInAreaLocator() {
	this._index = null;
	let g = arguments[0];
	if (!Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(g, __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__["a" /* default */])) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Argument must be Polygonal");
	this._index = new IntervalIndexedGeometry(g);
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(IndexedPointInAreaLocator.prototype, {
	locate: function (p) {
		var rcc = new __WEBPACK_IMPORTED_MODULE_10__RayCrossingCounter__["a" /* default */](p);
		var visitor = new SegmentVisitor(rcc);
		this._index.query(p.y, p.y, visitor);
		return rcc.getLocation();
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__PointOnGeometryLocator__["a" /* default */]];
	},
	getClass: function () {
		return IndexedPointInAreaLocator;
	}
});
function SegmentVisitor() {
	this._counter = null;
	let counter = arguments[0];
	this._counter = counter;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(SegmentVisitor.prototype, {
	visitItem: function (item) {
		var seg = item;
		this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__index_ItemVisitor__["a" /* default */]];
	},
	getClass: function () {
		return SegmentVisitor;
	}
});
function IntervalIndexedGeometry() {
	this._index = new __WEBPACK_IMPORTED_MODULE_5__index_intervalrtree_SortedPackedIntervalRTree__["a" /* default */]();
	let geom = arguments[0];
	this.init(geom);
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(IntervalIndexedGeometry.prototype, {
	init: function (geom) {
		var lines = __WEBPACK_IMPORTED_MODULE_8__geom_util_LinearComponentExtracter__["a" /* default */].getLines(geom);
		for (var i = lines.iterator(); i.hasNext(); ) {
			var line = i.next();
			var pts = line.getCoordinates();
			this.addLine(pts);
		}
	},
	addLine: function (pts) {
		for (var i = 1; i < pts.length; i++) {
			var seg = new __WEBPACK_IMPORTED_MODULE_6__geom_LineSegment__["a" /* default */](pts[i - 1], pts[i]);
			var min = Math.min(seg.p0.y, seg.p1.y);
			var max = Math.max(seg.p0.y, seg.p1.y);
			this._index.insert(min, max, seg);
		}
	},
	query: function () {
		if (arguments.length === 2) {
			let min = arguments[0], max = arguments[1];
			var visitor = new __WEBPACK_IMPORTED_MODULE_9__index_ArrayListVisitor__["a" /* default */]();
			this._index.query(min, max, visitor);
			return visitor.getItems();
		} else if (arguments.length === 3) {
			let min = arguments[0], max = arguments[1], visitor = arguments[2];
			this._index.query(min, max, visitor);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IntervalIndexedGeometry;
	}
});
IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;
IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SortedPackedIntervalRTree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__IntervalRTreeLeafNode__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__IntervalRTreeBranchNode__ = __webpack_require__(259);








function SortedPackedIntervalRTree() {
	this._leaves = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._root = null;
	this._level = 0;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(SortedPackedIntervalRTree.prototype, {
	buildTree: function () {
		__WEBPACK_IMPORTED_MODULE_4__java_util_Collections__["a" /* default */].sort(this._leaves, new IntervalRTreeNode.NodeComparator());
		var src = this._leaves;
		var temp = null;
		var dest = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
		while (true) {
			this.buildLevel(src, dest);
			if (dest.size() === 1) return dest.get(0);
			temp = src;
			src = dest;
			dest = temp;
		}
	},
	insert: function (min, max, item) {
		if (this._root !== null) throw new IllegalStateException("Index cannot be added to once it has been queried");
		this._leaves.add(new __WEBPACK_IMPORTED_MODULE_2__IntervalRTreeLeafNode__["a" /* default */](min, max, item));
	},
	query: function (min, max, visitor) {
		this.init();
		this._root.query(min, max, visitor);
	},
	buildRoot: function () {
		if (this._root !== null) return null;
		this._root = this.buildTree();
	},
	printNode: function (node) {
		__WEBPACK_IMPORTED_MODULE_5__java_lang_System__["a" /* default */].out.println(__WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](node._min, this._level), new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](node._max, this._level)));
	},
	init: function () {
		if (this._root !== null) return null;
		this.buildRoot();
	},
	buildLevel: function (src, dest) {
		this._level++;
		dest.clear();
		for (var i = 0; i < src.size(); i += 2) {
			var n1 = src.get(i);
			var n2 = i + 1 < src.size() ? src.get(i) : null;
			if (n2 === null) {
				dest.add(n1);
			} else {
				var node = new __WEBPACK_IMPORTED_MODULE_7__IntervalRTreeBranchNode__["a" /* default */](src.get(i), src.get(i + 1));
				dest.add(node);
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SortedPackedIntervalRTree;
	}
});


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IntervalRTreeLeafNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__IntervalRTreeNode__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function IntervalRTreeLeafNode() {
	__WEBPACK_IMPORTED_MODULE_0__IntervalRTreeNode__["a" /* default */].apply(this);
	this._item = null;
	let min = arguments[0], max = arguments[1], item = arguments[2];
	this._min = min;
	this._max = max;
	this._item = item;
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(IntervalRTreeLeafNode, __WEBPACK_IMPORTED_MODULE_0__IntervalRTreeNode__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(IntervalRTreeLeafNode.prototype, {
	query: function (queryMin, queryMax, visitor) {
		if (!this.intersects(queryMin, queryMax)) return null;
		visitor.visitItem(this._item);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IntervalRTreeLeafNode;
	}
});


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IntervalRTreeBranchNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__IntervalRTreeNode__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function IntervalRTreeBranchNode() {
	__WEBPACK_IMPORTED_MODULE_0__IntervalRTreeNode__["a" /* default */].apply(this);
	this._node1 = null;
	this._node2 = null;
	let n1 = arguments[0], n2 = arguments[1];
	this._node1 = n1;
	this._node2 = n2;
	this.buildExtent(this._node1, this._node2);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(IntervalRTreeBranchNode, __WEBPACK_IMPORTED_MODULE_0__IntervalRTreeNode__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(IntervalRTreeBranchNode.prototype, {
	buildExtent: function (n1, n2) {
		this._min = Math.min(n1._min, n2._min);
		this._max = Math.max(n1._max, n2._max);
	},
	query: function (queryMin, queryMax, visitor) {
		if (!this.intersects(queryMin, queryMax)) {
			return null;
		}
		if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);
		if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IntervalRTreeBranchNode;
	}
});


/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeIntersectionList;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__EdgeIntersection__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Edge__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_TreeMap__ = __webpack_require__(35);






function EdgeIntersectionList() {
	this._nodeMap = new __WEBPACK_IMPORTED_MODULE_5__java_util_TreeMap__["a" /* default */]();
	this.edge = null;
	let edge = arguments[0];
	this.edge = edge;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(EdgeIntersectionList.prototype, {
	print: function (out) {
		out.println("Intersections:");
		for (var it = this.iterator(); it.hasNext(); ) {
			var ei = it.next();
			ei.print(out);
		}
	},
	iterator: function () {
		return this._nodeMap.values().iterator();
	},
	addSplitEdges: function (edgeList) {
		this.addEndpoints();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var newEdge = this.createSplitEdge(eiPrev, ei);
			edgeList.add(newEdge);
			eiPrev = ei;
		}
	},
	addEndpoints: function () {
		var maxSegIndex = this.edge.pts.length - 1;
		this.add(this.edge.pts[0], 0, 0.0);
		this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
	},
	createSplitEdge: function (ei0, ei1) {
		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
		var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var pts = new Array(npts).fill(null);
		var ipt = 0;
		pts[ipt++] = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](ei0.coord);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			pts[ipt++] = this.edge.pts[i];
		}
		if (useIntPt1) pts[ipt] = ei1.coord;
		return new __WEBPACK_IMPORTED_MODULE_4__Edge__["a" /* default */](pts, new __WEBPACK_IMPORTED_MODULE_3__Label__["a" /* default */](this.edge._label));
	},
	add: function (intPt, segmentIndex, dist) {
		var eiNew = new __WEBPACK_IMPORTED_MODULE_0__EdgeIntersection__["a" /* default */](intPt, segmentIndex, dist);
		var ei = this._nodeMap.get(eiNew);
		if (ei !== null) {
			return ei;
		}
		this._nodeMap.put(eiNew, eiNew);
		return eiNew;
	},
	isIntersection: function (pt) {
		for (var it = this.iterator(); it.hasNext(); ) {
			var ei = it.next();
			if (ei.coord.equals(pt)) return true;
		}
		return false;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeIntersectionList;
	}
});


/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeIntersection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__ = __webpack_require__(20);



function EdgeIntersection() {
	this.coord = null;
	this.segmentIndex = null;
	this.dist = null;
	let coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];
	this.coord = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](coord);
	this.segmentIndex = segmentIndex;
	this.dist = dist;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeIntersection.prototype, {
	getSegmentIndex: function () {
		return this.segmentIndex;
	},
	getCoordinate: function () {
		return this.coord;
	},
	print: function (out) {
		out.print(this.coord);
		out.print(" seg # = " + this.segmentIndex);
		out.println(" dist = " + this.dist);
	},
	compareTo: function (obj) {
		var other = obj;
		return this.compare(other.segmentIndex, other.dist);
	},
	isEndPoint: function (maxSegmentIndex) {
		if (this.segmentIndex === 0 && this.dist === 0.0) return true;
		if (this.segmentIndex === maxSegmentIndex) return true;
		return false;
	},
	toString: function () {
		return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
	},
	getDistance: function () {
		return this.dist;
	},
	compare: function (segmentIndex, dist) {
		if (this.segmentIndex < segmentIndex) return -1;
		if (this.segmentIndex > segmentIndex) return 1;
		if (this.dist < dist) return -1;
		if (this.dist > dist) return 1;
		return 0;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return EdgeIntersection;
	}
});


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChainEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MonotoneChainIndexer__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__ = __webpack_require__(7);



function MonotoneChainEdge() {
	this.e = null;
	this.pts = null;
	this.startIndex = null;
	this.env1 = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */]();
	this.env2 = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */]();
	let e = arguments[0];
	this.e = e;
	this.pts = e.getCoordinates();
	var mcb = new __WEBPACK_IMPORTED_MODULE_1__MonotoneChainIndexer__["a" /* default */]();
	this.startIndex = mcb.getChainStartIndices(this.pts);
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonotoneChainEdge.prototype, {
	getCoordinates: function () {
		return this.pts;
	},
	getMaxX: function (chainIndex) {
		var x1 = this.pts[this.startIndex[chainIndex]].x;
		var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
		return x1 > x2 ? x1 : x2;
	},
	getMinX: function (chainIndex) {
		var x1 = this.pts[this.startIndex[chainIndex]].x;
		var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
		return x1 < x2 ? x1 : x2;
	},
	computeIntersectsForChain: function () {
		if (arguments.length === 4) {
			let chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];
			this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
		} else if (arguments.length === 6) {
			let start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];
			var p00 = this.pts[start0];
			var p01 = this.pts[end0];
			var p10 = mce.pts[start1];
			var p11 = mce.pts[end1];
			if (end0 - start0 === 1 && end1 - start1 === 1) {
				ei.addIntersections(this.e, start0, mce.e, start1);
				return null;
			}
			this.env1.init(p00, p01);
			this.env2.init(p10, p11);
			if (!this.env1.intersects(this.env2)) return null;
			var mid0 = Math.trunc((start0 + end0) / 2);
			var mid1 = Math.trunc((start1 + end1) / 2);
			if (start0 < mid0) {
				if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);
				if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);
			}
			if (mid0 < end0) {
				if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);
				if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);
			}
		}
	},
	getStartIndexes: function () {
		return this.startIndex;
	},
	computeIntersects: function (mce, si) {
		for (var i = 0; i < this.startIndex.length - 1; i++) {
			for (var j = 0; j < mce.startIndex.length - 1; j++) {
				this.computeIntersectsForChain(i, mce, j, si);
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChainEdge;
	}
});


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MonotoneChainIndexer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Integer__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Quadrant__ = __webpack_require__(47);




function MonotoneChainIndexer() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(MonotoneChainIndexer.prototype, {
	getChainStartIndices: function (pts) {
		var start = 0;
		var startIndexList = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
		startIndexList.add(new __WEBPACK_IMPORTED_MODULE_1__java_lang_Integer__["a" /* default */](start));
		do {
			var last = this.findChainEnd(pts, start);
			startIndexList.add(new __WEBPACK_IMPORTED_MODULE_1__java_lang_Integer__["a" /* default */](last));
			start = last;
		} while (start < pts.length - 1);
		var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
		return startIndex;
	},
	findChainEnd: function (pts, start) {
		var chainQuad = __WEBPACK_IMPORTED_MODULE_3__Quadrant__["a" /* default */].quadrant(pts[start], pts[start + 1]);
		var last = start + 1;
		while (last < pts.length) {
			var quad = __WEBPACK_IMPORTED_MODULE_3__Quadrant__["a" /* default */].quadrant(pts[last - 1], pts[last]);
			if (quad !== chainQuad) break;
			last++;
		}
		return last - 1;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MonotoneChainIndexer;
	}
});
MonotoneChainIndexer.toIntArray = function (list) {
	var array = new Array(list.size()).fill(null);
	for (var i = 0; i < array.length; i++) {
		array[i] = list.get(i).intValue();
	}
	return array;
};


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Depth;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);



function Depth() {
	this._depth = Array(2).fill().map(() => Array(3));
	for (var i = 0; i < 2; i++) {
		for (var j = 0; j < 3; j++) {
			this._depth[i][j] = Depth.NULL_VALUE;
		}
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Depth.prototype, {
	getDepth: function (geomIndex, posIndex) {
		return this._depth[geomIndex][posIndex];
	},
	setDepth: function (geomIndex, posIndex, depthValue) {
		this._depth[geomIndex][posIndex] = depthValue;
	},
	isNull: function () {
		if (arguments.length === 0) {
			for (var i = 0; i < 2; i++) {
				for (var j = 0; j < 3; j++) {
					if (this._depth[i][j] !== Depth.NULL_VALUE) return false;
				}
			}
			return true;
		} else if (arguments.length === 1) {
			let geomIndex = arguments[0];
			return this._depth[geomIndex][1] === Depth.NULL_VALUE;
		} else if (arguments.length === 2) {
			let geomIndex = arguments[0], posIndex = arguments[1];
			return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;
		}
	},
	normalize: function () {
		for (var i = 0; i < 2; i++) {
			if (!this.isNull(i)) {
				var minDepth = this._depth[i][1];
				if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
				if (minDepth < 0) minDepth = 0;
				for (var j = 1; j < 3; j++) {
					var newValue = 0;
					if (this._depth[i][j] > minDepth) newValue = 1;
					this._depth[i][j] = newValue;
				}
			}
		}
	},
	getDelta: function (geomIndex) {
		return this._depth[geomIndex][__WEBPACK_IMPORTED_MODULE_1__Position__["a" /* default */].RIGHT] - this._depth[geomIndex][__WEBPACK_IMPORTED_MODULE_1__Position__["a" /* default */].LEFT];
	},
	getLocation: function (geomIndex, posIndex) {
		if (this._depth[geomIndex][posIndex] <= 0) return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR;
		return __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
	},
	toString: function () {
		return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
	},
	add: function () {
		if (arguments.length === 1) {
			let lbl = arguments[0];
			for (var i = 0; i < 2; i++) {
				for (var j = 1; j < 3; j++) {
					var loc = lbl.getLocation(i, j);
					if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR || loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) {
						if (this.isNull(i, j)) {
							this._depth[i][j] = Depth.depthAtLocation(loc);
						} else this._depth[i][j] += Depth.depthAtLocation(loc);
					}
				}
			}
		} else if (arguments.length === 3) {
			let geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];
			if (location === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) this._depth[geomIndex][posIndex]++;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Depth;
	}
});
Depth.depthAtLocation = function (location) {
	if (location === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR) return 0;
	if (location === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) return 1;
	return Depth.NULL_VALUE;
};
Depth.NULL_VALUE = -1;


/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OrientedCoordinateArray;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_CoordinateArrays__ = __webpack_require__(19);



function OrientedCoordinateArray() {
	this._pts = null;
	this._orientation = null;
	let pts = arguments[0];
	this._pts = pts;
	this._orientation = OrientedCoordinateArray.orientation(pts);
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(OrientedCoordinateArray.prototype, {
	compareTo: function (o1) {
		var oca = o1;
		var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
		return comp;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return OrientedCoordinateArray;
	}
});
OrientedCoordinateArray.orientation = function (pts) {
	return __WEBPACK_IMPORTED_MODULE_2__geom_CoordinateArrays__["a" /* default */].increasingDirection(pts) === 1;
};
OrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {
	var dir1 = orientation1 ? 1 : -1;
	var dir2 = orientation2 ? 1 : -1;
	var limit1 = orientation1 ? pts1.length : -1;
	var limit2 = orientation2 ? pts2.length : -1;
	var i1 = orientation1 ? 0 : pts1.length - 1;
	var i2 = orientation2 ? 0 : pts2.length - 1;
	var comp = 0;
	while (true) {
		var compPt = pts1[i1].compareTo(pts2[i2]);
		if (compPt !== 0) return compPt;
		i1 += dir1;
		i2 += dir2;
		var done1 = i1 === limit1;
		var done2 = i2 === limit2;
		if (done1 && !done2) return -1;
		if (!done1 && done2) return 1;
		if (done1 && done2) return 0;
	}
};


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollection__ = __webpack_require__(13);






function InteriorPointLine() {
	this._centroid = null;
	this._minDistance = __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].MAX_VALUE;
	this._interiorPoint = null;
	let g = arguments[0];
	this._centroid = g.getCentroid().getCoordinate();
	this.addInterior(g);
	if (this._interiorPoint === null) this.addEndpoints(g);
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(InteriorPointLine.prototype, {
	addEndpoints: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
				this.addEndpoints(geom.getCoordinates());
			} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollection__["a" /* default */]) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.addEndpoints(gc.getGeometryN(i));
				}
			}
		} else if (arguments[0] instanceof Array) {
			let pts = arguments[0];
			this.add(pts[0]);
			this.add(pts[pts.length - 1]);
		}
	},
	getInteriorPoint: function () {
		return this._interiorPoint;
	},
	addInterior: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
				this.addInterior(geom.getCoordinates());
			} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollection__["a" /* default */]) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.addInterior(gc.getGeometryN(i));
				}
			}
		} else if (arguments[0] instanceof Array) {
			let pts = arguments[0];
			for (var i = 1; i < pts.length - 1; i++) {
				this.add(pts[i]);
			}
		}
	},
	add: function (point) {
		var dist = point.distance(this._centroid);
		if (dist < this._minDistance) {
			this._interiorPoint = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](point);
			this._minDistance = dist;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return InteriorPointLine;
	}
});


/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollection__ = __webpack_require__(13);






function InteriorPointPoint() {
	this._centroid = null;
	this._minDistance = __WEBPACK_IMPORTED_MODULE_3__java_lang_Double__["a" /* default */].MAX_VALUE;
	this._interiorPoint = null;
	let g = arguments[0];
	this._centroid = g.getCentroid().getCoordinate();
	this.add(g);
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(InteriorPointPoint.prototype, {
	getInteriorPoint: function () {
		return this._interiorPoint;
	},
	add: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			if (geom instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Point__["a" /* default */]) {
				this.add(geom.getCoordinate());
			} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_5__geom_GeometryCollection__["a" /* default */]) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.add(gc.getGeometryN(i));
				}
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]) {
			let point = arguments[0];
			var dist = point.distance(this._centroid);
			if (dist < this._minDistance) {
				this._interiorPoint = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](point);
				this._minDistance = dist;
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return InteriorPointPoint;
	}
});


/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Bintree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Root__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Interval__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function Bintree() {
	this._root = null;
	this._minExtent = 1.0;
	this._root = new __WEBPACK_IMPORTED_MODULE_0__Root__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Bintree.prototype, {
	size: function () {
		if (this._root !== null) return this._root.size();
		return 0;
	},
	insert: function (itemInterval, item) {
		this.collectStats(itemInterval);
		var insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);
		this._root.insert(insertInterval, item);
	},
	query: function () {
		if (arguments.length === 1) {
			if (typeof arguments[0] === "number") {
				let x = arguments[0];
				return this.query(new __WEBPACK_IMPORTED_MODULE_1__Interval__["a" /* default */](x, x));
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__Interval__["a" /* default */]) {
				let interval = arguments[0];
				var foundItems = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
				this.query(interval, foundItems);
				return foundItems;
			}
		} else if (arguments.length === 2) {
			let interval = arguments[0], foundItems = arguments[1];
			this._root.addAllItemsFromOverlapping(interval, foundItems);
		}
	},
	iterator: function () {
		var foundItems = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
		this._root.addAllItems(foundItems);
		return foundItems.iterator();
	},
	remove: function (itemInterval, item) {
		var insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);
		return this._root.remove(insertInterval, item);
	},
	collectStats: function (interval) {
		var del = interval.getWidth();
		if (del < this._minExtent && del > 0.0) this._minExtent = del;
	},
	depth: function () {
		if (this._root !== null) return this._root.depth();
		return 0;
	},
	nodeSize: function () {
		if (this._root !== null) return this._root.nodeSize();
		return 0;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Bintree;
	}
});
Bintree.ensureExtent = function (itemInterval, minExtent) {
	var min = itemInterval.getMin();
	var max = itemInterval.getMax();
	if (min !== max) return itemInterval;
	if (min === max) {
		min = min - minExtent / 2.0;
		max = min + minExtent / 2.0;
	}
	return new __WEBPACK_IMPORTED_MODULE_1__Interval__["a" /* default */](min, max);
};


/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Root;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NodeBase__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Node__ = __webpack_require__(270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__quadtree_IntervalSize__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__inherits__ = __webpack_require__(3);






function Root() {
	__WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_5__inherits__["a" /* default */])(Root, __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Root.prototype, {
	insert: function (itemInterval, item) {
		var index = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(itemInterval, Root.origin);
		if (index === -1) {
			this.add(item);
			return null;
		}
		var node = this._subnode[index];
		if (node === null || !node.getInterval().contains(itemInterval)) {
			var largerNode = __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* default */].createExpanded(node, itemInterval);
			this._subnode[index] = largerNode;
		}
		this.insertContained(this._subnode[index], itemInterval, item);
	},
	isSearchMatch: function (interval) {
		return true;
	},
	insertContained: function (tree, itemInterval, item) {
		__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(tree.getInterval().contains(itemInterval));
		var isZeroArea = __WEBPACK_IMPORTED_MODULE_3__quadtree_IntervalSize__["a" /* default */].isZeroWidth(itemInterval.getMin(), itemInterval.getMax());
		var node = null;
		if (isZeroArea) node = tree.find(itemInterval); else node = tree.getNode(itemInterval);
		node.add(item);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Root;
	}
});
Root.origin = 0.0;


/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NodeBase__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Interval__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Key__ = __webpack_require__(271);






function Node() {
	__WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].apply(this);
	this._interval = null;
	this._centre = null;
	this._level = null;
	let interval = arguments[0], level = arguments[1];
	this._interval = interval;
	this._level = level;
	this._centre = (interval.getMin() + interval.getMax()) / 2;
}
Object(__WEBPACK_IMPORTED_MODULE_4__inherits__["a" /* default */])(Node, __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(Node.prototype, {
	getInterval: function () {
		return this._interval;
	},
	find: function (searchInterval) {
		var subnodeIndex = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(searchInterval, this._centre);
		if (subnodeIndex === -1) return this;
		if (this._subnode[subnodeIndex] !== null) {
			var node = this._subnode[subnodeIndex];
			return node.find(searchInterval);
		}
		return this;
	},
	insert: function (node) {
		__WEBPACK_IMPORTED_MODULE_3__util_Assert__["a" /* default */].isTrue(this._interval === null || this._interval.contains(node._interval));
		var index = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(node._interval, this._centre);
		if (node._level === this._level - 1) {
			this._subnode[index] = node;
		} else {
			var childNode = this.createSubnode(index);
			childNode.insert(node);
			this._subnode[index] = childNode;
		}
	},
	isSearchMatch: function (itemInterval) {
		return itemInterval.overlaps(this._interval);
	},
	getSubnode: function (index) {
		if (this._subnode[index] === null) {
			this._subnode[index] = this.createSubnode(index);
		}
		return this._subnode[index];
	},
	getNode: function (searchInterval) {
		var subnodeIndex = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(searchInterval, this._centre);
		if (subnodeIndex !== -1) {
			var node = this.getSubnode(subnodeIndex);
			return node.getNode(searchInterval);
		} else {
			return this;
		}
	},
	createSubnode: function (index) {
		var min = 0.0;
		var max = 0.0;
		switch (index) {
			case 0:
				min = this._interval.getMin();
				max = this._centre;
				break;
			case 1:
				min = this._centre;
				max = this._interval.getMax();
				break;
		}
		var subInt = new __WEBPACK_IMPORTED_MODULE_1__Interval__["a" /* default */](min, max);
		var node = new Node(subInt, this._level - 1);
		return node;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Node;
	}
});
Node.createNode = function (itemInterval) {
	var key = new __WEBPACK_IMPORTED_MODULE_5__Key__["a" /* default */](itemInterval);
	var node = new Node(key.getInterval(), key.getLevel());
	return node;
};
Node.createExpanded = function (node, addInterval) {
	var expandInt = new __WEBPACK_IMPORTED_MODULE_1__Interval__["a" /* default */](addInterval);
	if (node !== null) expandInt.expandToInclude(node._interval);
	var largerNode = Node.createNode(expandInt);
	if (node !== null) largerNode.insert(node);
	return largerNode;
};


/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Key;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Interval__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__quadtree_DoubleBits__ = __webpack_require__(103);



function Key() {
	this._pt = 0.0;
	this._level = 0;
	this._interval = null;
	let interval = arguments[0];
	this.computeKey(interval);
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Key.prototype, {
	getInterval: function () {
		return this._interval;
	},
	getLevel: function () {
		return this._level;
	},
	computeKey: function (itemInterval) {
		this._level = Key.computeLevel(itemInterval);
		this._interval = new __WEBPACK_IMPORTED_MODULE_0__Interval__["a" /* default */]();
		this.computeInterval(this._level, itemInterval);
		while (!this._interval.contains(itemInterval)) {
			this._level += 1;
			this.computeInterval(this._level, itemInterval);
		}
	},
	computeInterval: function (level, itemInterval) {
		var size = __WEBPACK_IMPORTED_MODULE_2__quadtree_DoubleBits__["a" /* default */].powerOf2(level);
		this._pt = Math.floor(itemInterval.getMin() / size) * size;
		this._interval.init(this._pt, this._pt + size);
	},
	getPoint: function () {
		return this._pt;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Key;
	}
});
Key.computeLevel = function (interval) {
	var dx = interval.getWidth();
	var level = __WEBPACK_IMPORTED_MODULE_2__quadtree_DoubleBits__["a" /* default */].exponent(dx) + 1;
	return level;
};


/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PointInRing;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function PointInRing() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(PointInRing.prototype, {
	isInside: function (pt) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PointInRing;
	}
});


/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Angle__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_Triangle__ = __webpack_require__(79);







function MinimumBoundingCircle() {
	this._input = null;
	this._extremalPts = null;
	this._centre = null;
	this._radius = 0.0;
	let geom = arguments[0];
	this._input = geom;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(MinimumBoundingCircle.prototype, {
	getRadius: function () {
		this.compute();
		return this._radius;
	},
	getDiameter: function () {
		this.compute();
		switch (this._extremalPts.length) {
			case 0:
				return this._input.getFactory().createLineString();
			case 1:
				return this._input.getFactory().createPoint(this._centre);
		}
		var p0 = this._extremalPts[0];
		var p1 = this._extremalPts[1];
		return this._input.getFactory().createLineString([p0, p1]);
	},
	getExtremalPoints: function () {
		this.compute();
		return this._extremalPts;
	},
	computeCirclePoints: function () {
		if (this._input.isEmpty()) {
			this._extremalPts = new Array(0).fill(null);
			return null;
		}
		if (this._input.getNumPoints() === 1) {
			var pts = this._input.getCoordinates();
			this._extremalPts = [new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](pts[0])];
			return null;
		}
		var convexHull = this._input.convexHull();
		var hullPts = convexHull.getCoordinates();
		var pts = hullPts;
		if (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {
			pts = new Array(hullPts.length - 1).fill(null);
			__WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__["a" /* default */].copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);
		}
		if (pts.length <= 2) {
			this._extremalPts = __WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__["a" /* default */].copyDeep(pts);
			return null;
		}
		var P = MinimumBoundingCircle.lowestPoint(pts);
		var Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);
		for (var i = 0; i < pts.length; i++) {
			var R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);
			if (__WEBPACK_IMPORTED_MODULE_4__Angle__["a" /* default */].isObtuse(P, R, Q)) {
				this._extremalPts = [new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](P), new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](Q)];
				return null;
			}
			if (__WEBPACK_IMPORTED_MODULE_4__Angle__["a" /* default */].isObtuse(R, P, Q)) {
				P = R;
				continue;
			}
			if (__WEBPACK_IMPORTED_MODULE_4__Angle__["a" /* default */].isObtuse(R, Q, P)) {
				Q = R;
				continue;
			}
			this._extremalPts = [new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](P), new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](Q), new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](R)];
			return null;
		}
		__WEBPACK_IMPORTED_MODULE_5__util_Assert__["a" /* default */].shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!");
	},
	compute: function () {
		if (this._extremalPts !== null) return null;
		this.computeCirclePoints();
		this.computeCentre();
		if (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);
	},
	getFarthestPoints: function () {
		this.compute();
		switch (this._extremalPts.length) {
			case 0:
				return this._input.getFactory().createLineString();
			case 1:
				return this._input.getFactory().createPoint(this._centre);
		}
		var p0 = this._extremalPts[0];
		var p1 = this._extremalPts[this._extremalPts.length - 1];
		return this._input.getFactory().createLineString([p0, p1]);
	},
	getCircle: function () {
		this.compute();
		if (this._centre === null) return this._input.getFactory().createPolygon();
		var centrePoint = this._input.getFactory().createPoint(this._centre);
		if (this._radius === 0.0) return centrePoint;
		return centrePoint.buffer(this._radius);
	},
	getCentre: function () {
		this.compute();
		return this._centre;
	},
	computeCentre: function () {
		switch (this._extremalPts.length) {
			case 0:
				this._centre = null;
				break;
			case 1:
				this._centre = this._extremalPts[0];
				break;
			case 2:
				this._centre = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);
				break;
			case 3:
				this._centre = __WEBPACK_IMPORTED_MODULE_6__geom_Triangle__["a" /* default */].circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);
				break;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MinimumBoundingCircle;
	}
});
MinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {
	var minSin = __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].MAX_VALUE;
	var minAngPt = null;
	for (var i = 0; i < pts.length; i++) {
		var p = pts[i];
		if (p === P) continue;
		var dx = p.x - P.x;
		var dy = p.y - P.y;
		if (dy < 0) dy = -dy;
		var len = Math.sqrt(dx * dx + dy * dy);
		var sin = dy / len;
		if (sin < minSin) {
			minSin = sin;
			minAngPt = p;
		}
	}
	return minAngPt;
};
MinimumBoundingCircle.lowestPoint = function (pts) {
	var min = pts[0];
	for (var i = 1; i < pts.length; i++) {
		if (pts[i].y < min.y) min = pts[i];
	}
	return min;
};
MinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {
	var minAng = __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].MAX_VALUE;
	var minAngPt = null;
	for (var i = 0; i < pts.length; i++) {
		var p = pts[i];
		if (p === P) continue;
		if (p === Q) continue;
		var ang = __WEBPACK_IMPORTED_MODULE_4__Angle__["a" /* default */].angleBetween(P, p, Q);
		if (ang < minAng) {
			minAng = ang;
			minAngPt = p;
		}
	}
	return minAngPt;
};


/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ConvexHull__ = __webpack_require__(93);






function MinimumDiameter() {
	this._inputGeom = null;
	this._isConvex = null;
	this._convexHullPts = null;
	this._minBaseSeg = new __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__["a" /* default */]();
	this._minWidthPt = null;
	this._minPtIndex = null;
	this._minWidth = 0.0;
	if (arguments.length === 1) {
		let inputGeom = arguments[0];
		MinimumDiameter.call(this, inputGeom, false);
	} else if (arguments.length === 2) {
		let inputGeom = arguments[0], isConvex = arguments[1];
		this._inputGeom = inputGeom;
		this._isConvex = isConvex;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(MinimumDiameter.prototype, {
	getWidthCoordinate: function () {
		this.computeMinimumDiameter();
		return this._minWidthPt;
	},
	getSupportingSegment: function () {
		this.computeMinimumDiameter();
		return this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);
	},
	getDiameter: function () {
		this.computeMinimumDiameter();
		if (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString(null);
		var basePt = this._minBaseSeg.project(this._minWidthPt);
		return this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);
	},
	computeWidthConvex: function (convexGeom) {
		if (convexGeom instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Polygon__["a" /* default */]) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates(); else this._convexHullPts = convexGeom.getCoordinates();
		if (this._convexHullPts.length === 0) {
			this._minWidth = 0.0;
			this._minWidthPt = null;
			this._minBaseSeg = null;
		} else if (this._convexHullPts.length === 1) {
			this._minWidth = 0.0;
			this._minWidthPt = this._convexHullPts[0];
			this._minBaseSeg.p0 = this._convexHullPts[0];
			this._minBaseSeg.p1 = this._convexHullPts[0];
		} else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {
			this._minWidth = 0.0;
			this._minWidthPt = this._convexHullPts[0];
			this._minBaseSeg.p0 = this._convexHullPts[0];
			this._minBaseSeg.p1 = this._convexHullPts[1];
		} else this.computeConvexRingMinDiameter(this._convexHullPts);
	},
	computeConvexRingMinDiameter: function (pts) {
		this._minWidth = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE;
		var currMaxIndex = 1;
		var seg = new __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__["a" /* default */]();
		for (var i = 0; i < pts.length - 1; i++) {
			seg.p0 = pts[i];
			seg.p1 = pts[i + 1];
			currMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);
		}
	},
	computeMinimumDiameter: function () {
		if (this._minWidthPt !== null) return null;
		if (this._isConvex) this.computeWidthConvex(this._inputGeom); else {
			var convexGeom = new __WEBPACK_IMPORTED_MODULE_5__ConvexHull__["a" /* default */](this._inputGeom).getConvexHull();
			this.computeWidthConvex(convexGeom);
		}
	},
	getLength: function () {
		this.computeMinimumDiameter();
		return this._minWidth;
	},
	findMaxPerpDistance: function (pts, seg, startIndex) {
		var maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);
		var nextPerpDistance = maxPerpDistance;
		var maxIndex = startIndex;
		var nextIndex = maxIndex;
		while (nextPerpDistance >= maxPerpDistance) {
			maxPerpDistance = nextPerpDistance;
			maxIndex = nextIndex;
			nextIndex = MinimumDiameter.nextIndex(pts, maxIndex);
			nextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);
		}
		if (maxPerpDistance < this._minWidth) {
			this._minPtIndex = maxIndex;
			this._minWidth = maxPerpDistance;
			this._minWidthPt = pts[this._minPtIndex];
			this._minBaseSeg = new __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__["a" /* default */](seg);
		}
		return maxIndex;
	},
	getMinimumRectangle: function () {
		this.computeMinimumDiameter();
		if (this._minWidth === 0.0) {
			if (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) {
				return this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);
			}
			return this._minBaseSeg.toGeometry(this._inputGeom.getFactory());
		}
		var dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;
		var dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;
		var minPara = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE;
		var maxPara = -__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE;
		var minPerp = __WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE;
		var maxPerp = -__WEBPACK_IMPORTED_MODULE_2__java_lang_Double__["a" /* default */].MAX_VALUE;
		for (var i = 0; i < this._convexHullPts.length; i++) {
			var paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);
			if (paraC > maxPara) maxPara = paraC;
			if (paraC < minPara) minPara = paraC;
			var perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);
			if (perpC > maxPerp) maxPerp = perpC;
			if (perpC < minPerp) minPerp = perpC;
		}
		var maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);
		var minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);
		var maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);
		var minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);
		var p0 = maxParaLine.lineIntersection(maxPerpLine);
		var p1 = minParaLine.lineIntersection(maxPerpLine);
		var p2 = minParaLine.lineIntersection(minPerpLine);
		var p3 = maxParaLine.lineIntersection(minPerpLine);
		var shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);
		return this._inputGeom.getFactory().createPolygon(shell, null);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MinimumDiameter;
	}
});
MinimumDiameter.nextIndex = function (pts, index) {
	index++;
	if (index >= pts.length) index = 0;
	return index;
};
MinimumDiameter.computeC = function (a, b, p) {
	return a * p.y - b * p.x;
};
MinimumDiameter.getMinimumDiameter = function (geom) {
	return new MinimumDiameter(geom).getDiameter();
};
MinimumDiameter.getMinimumRectangle = function (geom) {
	return new MinimumDiameter(geom).getMinimumRectangle();
};
MinimumDiameter.computeSegmentForLine = function (a, b, c) {
	var p0 = null;
	var p1 = null;
	if (Math.abs(b) > Math.abs(a)) {
		p0 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](0.0, c / b);
		p1 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](1.0, c / b - a / b);
	} else {
		p0 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](c / a, 0.0);
		p1 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](c / a - b / a, 1.0);
	}
	return new __WEBPACK_IMPORTED_MODULE_4__geom_LineSegment__["a" /* default */](p0, p1);
};


/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__densify_Densifier__ = __webpack_require__(276);
/* unused harmony reexport Densifier */





/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__inherits__ = __webpack_require__(3);








function Densifier() {
	this._inputGeom = null;
	this._distanceTolerance = null;
	let inputGeom = arguments[0];
	this._inputGeom = inputGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(Densifier.prototype, {
	getResultGeometry: function () {
		return new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);
	},
	setDistanceTolerance: function (distanceTolerance) {
		if (distanceTolerance <= 0.0) throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_IllegalArgumentException__["a" /* default */]("Tolerance must be positive");
		this._distanceTolerance = distanceTolerance;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Densifier;
	}
});
Densifier.densifyPoints = function (pts, distanceTolerance, precModel) {
	var seg = new __WEBPACK_IMPORTED_MODULE_6__geom_LineSegment__["a" /* default */]();
	var coordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
	for (var i = 0; i < pts.length - 1; i++) {
		seg.p0 = pts[i];
		seg.p1 = pts[i + 1];
		coordList.add(seg.p0, false);
		var len = seg.getLength();
		var densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;
		if (densifiedSegCount > 1) {
			var densifiedSegLen = len / densifiedSegCount;
			for (var j = 1; j < densifiedSegCount; j++) {
				var segFract = j * densifiedSegLen / len;
				var p = seg.pointAlong(segFract);
				precModel.makePrecise(p);
				coordList.add(p, false);
			}
		}
	}
	coordList.add(pts[pts.length - 1], false);
	return coordList.toCoordinateArray();
};
Densifier.densify = function (geom, distanceTolerance) {
	var densifier = new Densifier(geom);
	densifier.setDistanceTolerance(distanceTolerance);
	return densifier.getResultGeometry();
};
function DensifyTransformer() {
	__WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */].apply(this);
	this.distanceTolerance = null;
	let distanceTolerance = arguments[0];
	this.distanceTolerance = distanceTolerance;
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(DensifyTransformer, __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(DensifyTransformer.prototype, {
	transformMultiPolygon: function (geom, parent) {
		var roughGeom = __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */].prototype.transformMultiPolygon.call(this, geom, parent);
		return this.createValidArea(roughGeom);
	},
	transformPolygon: function (geom, parent) {
		var roughGeom = __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */].prototype.transformPolygon.call(this, geom, parent);
		if (parent instanceof __WEBPACK_IMPORTED_MODULE_5__geom_MultiPolygon__["a" /* default */]) {
			return roughGeom;
		}
		return this.createValidArea(roughGeom);
	},
	transformCoordinates: function (coords, parent) {
		var inputPts = coords.toCoordinateArray();
		var newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());
		if (parent instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */] && newPts.length === 1) {
			newPts = new Array(0).fill(null);
		}
		return this._factory.getCoordinateSequenceFactory().create(newPts);
	},
	createValidArea: function (roughAreaGeom) {
		return roughAreaGeom.buffer(0.0);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DensifyTransformer;
	}
});
Densifier.DensifyTransformer = DensifyTransformer;


/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dissolve_LineDissolver__ = __webpack_require__(278);
/* unused harmony reexport LineDissolver */





/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_Stack__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__edgegraph_MarkHalfEdge__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__DissolveEdgeGraph__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__ = __webpack_require__(1);











function LineDissolver() {
	this._result = null;
	this._factory = null;
	this._graph = null;
	this._lines = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	this._nodeEdgeStack = new __WEBPACK_IMPORTED_MODULE_5__java_util_Stack__["a" /* default */]();
	this._ringStartEdge = null;
	this._graph = new __WEBPACK_IMPORTED_MODULE_8__DissolveEdgeGraph__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(LineDissolver.prototype, {
	addLine: function (line) {
		this._lines.add(this._factory.createLineString(line.toCoordinateArray()));
	},
	updateRingStartEdge: function (e) {
		if (!e.isStart()) {
			e = e.sym();
			if (!e.isStart()) return null;
		}
		if (this._ringStartEdge === null) {
			this._ringStartEdge = e;
			return null;
		}
		if (e.orig().compareTo(this._ringStartEdge.orig()) < 0) {
			this._ringStartEdge = e;
		}
	},
	getResult: function () {
		if (this._result === null) this.computeResult();
		return this._result;
	},
	process: function (e) {
		var eNode = e.prevNode();
		if (eNode === null) eNode = e;
		this.stackEdges(eNode);
		this.buildLines();
	},
	buildRing: function (eStartRing) {
		var line = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
		var e = eStartRing;
		line.add(e.orig().copy(), false);
		while (e.sym().degree() === 2) {
			var eNext = e.next();
			if (eNext === eStartRing) break;
			line.add(eNext.orig().copy(), false);
			e = eNext;
		}
		line.add(e.dest().copy(), false);
		this.addLine(line);
	},
	buildLine: function (eStart) {
		var line = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
		var e = eStart;
		this._ringStartEdge = null;
		__WEBPACK_IMPORTED_MODULE_7__edgegraph_MarkHalfEdge__["a" /* default */].markBoth(e);
		line.add(e.orig().copy(), false);
		while (e.sym().degree() === 2) {
			this.updateRingStartEdge(e);
			var eNext = e.next();
			if (eNext === eStart) {
				this.buildRing(this._ringStartEdge);
				return null;
			}
			line.add(eNext.orig().copy(), false);
			e = eNext;
			__WEBPACK_IMPORTED_MODULE_7__edgegraph_MarkHalfEdge__["a" /* default */].markBoth(e);
		}
		line.add(e.dest().copy(), false);
		this.stackEdges(e.sym());
		this.addLine(line);
	},
	stackEdges: function (node) {
		var e = node;
		do {
			if (!__WEBPACK_IMPORTED_MODULE_7__edgegraph_MarkHalfEdge__["a" /* default */].isMarked(e)) this._nodeEdgeStack.add(e);
			e = e.oNext();
		} while (e !== node);
	},
	computeResult: function () {
		var edges = this._graph.getVertexEdges();
		for (var i = edges.iterator(); i.hasNext(); ) {
			var e = i.next();
			if (__WEBPACK_IMPORTED_MODULE_7__edgegraph_MarkHalfEdge__["a" /* default */].isMarked(e)) continue;
			this.process(e);
		}
		this._result = this._factory.buildGeometry(this._lines);
	},
	buildLines: function () {
		while (!this._nodeEdgeStack.empty()) {
			var e = this._nodeEdgeStack.pop();
			if (__WEBPACK_IMPORTED_MODULE_7__edgegraph_MarkHalfEdge__["a" /* default */].isMarked(e)) continue;
			this.buildLine(e);
		}
	},
	add: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Geometry__["a" /* default */]) {
			let geometry = arguments[0];
			geometry.apply({
				interfaces_: function () {
					return [__WEBPACK_IMPORTED_MODULE_9__geom_GeometryComponentFilter__["a" /* default */]];
				},
				filter: function (component) {
					if (component instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
						this.add(component);
					}
				}
			});
		} else if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_4__java_util_Collection__["a" /* default */])) {
			let geometries = arguments[0];
			for (var i = geometries.iterator(); i.hasNext(); ) {
				var geometry = i.next();
				this.add(geometry);
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
			let lineString = arguments[0];
			if (this._factory === null) {
				this._factory = lineString.getFactory();
			}
			var seq = lineString.getCoordinateSequence();
			var doneStart = false;
			for (var i = 1; i < seq.size(); i++) {
				var e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));
				if (e === null) continue;
				if (!doneStart) {
					e.setStart();
					doneStart = true;
				}
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineDissolver;
	}
});
LineDissolver.dissolve = function (g) {
	var d = new LineDissolver();
	d.add(g);
	return d.getResult();
};


/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DissolveEdgeGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__edgegraph_EdgeGraph__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__DissolveHalfEdge__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);




function DissolveEdgeGraph() {
	__WEBPACK_IMPORTED_MODULE_0__edgegraph_EdgeGraph__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(DissolveEdgeGraph, __WEBPACK_IMPORTED_MODULE_0__edgegraph_EdgeGraph__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(DissolveEdgeGraph.prototype, {
	createEdge: function (p0) {
		return new __WEBPACK_IMPORTED_MODULE_2__DissolveHalfEdge__["a" /* default */](p0);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DissolveEdgeGraph;
	}
});


/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_HashMap__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__HalfEdge__ = __webpack_require__(149);



function EdgeGraph() {
	this._vertexMap = new __WEBPACK_IMPORTED_MODULE_0__java_util_HashMap__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeGraph.prototype, {
	insert: function (orig, dest, eAdj) {
		var e = this.create(orig, dest);
		if (eAdj !== null) {
			eAdj.insert(e);
		} else {
			this._vertexMap.put(orig, e);
		}
		var eAdjDest = this._vertexMap.get(dest);
		if (eAdjDest !== null) {
			eAdjDest.insert(e.sym());
		} else {
			this._vertexMap.put(dest, e.sym());
		}
		return e;
	},
	create: function (p0, p1) {
		var e0 = this.createEdge(p0);
		var e1 = this.createEdge(p1);
		__WEBPACK_IMPORTED_MODULE_2__HalfEdge__["a" /* default */].init(e0, e1);
		return e0;
	},
	createEdge: function (orig) {
		return new __WEBPACK_IMPORTED_MODULE_2__HalfEdge__["a" /* default */](orig);
	},
	addEdge: function (orig, dest) {
		if (!EdgeGraph.isValidEdge(orig, dest)) return null;
		var eAdj = this._vertexMap.get(orig);
		var eSame = null;
		if (eAdj !== null) {
			eSame = eAdj.find(dest);
		}
		if (eSame !== null) {
			return eSame;
		}
		var e = this.insert(orig, dest, eAdj);
		return e;
	},
	getVertexEdges: function () {
		return this._vertexMap.values();
	},
	findEdge: function (orig, dest) {
		var e = this._vertexMap.get(orig);
		if (e === null) return null;
		return e.find(dest);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeGraph;
	}
});
EdgeGraph.isValidEdge = function (orig, dest) {
	var cmp = dest.compareTo(orig);
	return cmp !== 0;
};


/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DissolveHalfEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__edgegraph_MarkHalfEdge__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function DissolveHalfEdge() {
	this._isStart = false;
	let orig = arguments[0];
	__WEBPACK_IMPORTED_MODULE_1__edgegraph_MarkHalfEdge__["a" /* default */].call(this, orig);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(DissolveHalfEdge, __WEBPACK_IMPORTED_MODULE_1__edgegraph_MarkHalfEdge__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(DissolveHalfEdge.prototype, {
	setStart: function () {
		this._isStart = true;
	},
	isStart: function () {
		return this._isStart;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DissolveHalfEdge;
	}
});


/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geomgraph_GeometryGraph__ = __webpack_require__(66);
/* unused harmony reexport GeometryGraph */





/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_quadtree__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_strtree__ = __webpack_require__(288);
/* unused harmony reexport quadtree */
/* unused harmony reexport strtree */






/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__quadtree_Quadtree__ = __webpack_require__(150);
/* unused harmony reexport Quadtree */





/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Root;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__NodeBase__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Node__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__IntervalSize__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__inherits__ = __webpack_require__(3);







function Root() {
	__WEBPACK_IMPORTED_MODULE_1__NodeBase__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_6__inherits__["a" /* default */])(Root, __WEBPACK_IMPORTED_MODULE_1__NodeBase__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(Root.prototype, {
	insert: function (itemEnv, item) {
		var index = __WEBPACK_IMPORTED_MODULE_1__NodeBase__["a" /* default */].getSubnodeIndex(itemEnv, Root.origin.x, Root.origin.y);
		if (index === -1) {
			this.add(item);
			return null;
		}
		var node = this._subnode[index];
		if (node === null || !node.getEnvelope().contains(itemEnv)) {
			var largerNode = __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* default */].createExpanded(node, itemEnv);
			this._subnode[index] = largerNode;
		}
		this.insertContained(this._subnode[index], itemEnv, item);
	},
	isSearchMatch: function (searchEnv) {
		return true;
	},
	insertContained: function (tree, itemEnv, item) {
		__WEBPACK_IMPORTED_MODULE_5__util_Assert__["a" /* default */].isTrue(tree.getEnvelope().contains(itemEnv));
		var isZeroX = __WEBPACK_IMPORTED_MODULE_4__IntervalSize__["a" /* default */].isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());
		var isZeroY = __WEBPACK_IMPORTED_MODULE_4__IntervalSize__["a" /* default */].isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());
		var node = null;
		if (isZeroX || isZeroY) node = tree.find(itemEnv); else node = tree.getNode(itemEnv);
		node.add(item);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Root;
	}
});
Root.origin = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](0.0, 0.0);


/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NodeBase__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Key__ = __webpack_require__(287);






function Node() {
	__WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].apply(this);
	this._env = null;
	this._centrex = null;
	this._centrey = null;
	this._level = null;
	let env = arguments[0], level = arguments[1];
	this._env = env;
	this._level = level;
	this._centrex = (env.getMinX() + env.getMaxX()) / 2;
	this._centrey = (env.getMinY() + env.getMaxY()) / 2;
}
Object(__WEBPACK_IMPORTED_MODULE_4__inherits__["a" /* default */])(Node, __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Node.prototype, {
	find: function (searchEnv) {
		var subnodeIndex = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(searchEnv, this._centrex, this._centrey);
		if (subnodeIndex === -1) return this;
		if (this._subnode[subnodeIndex] !== null) {
			var node = this._subnode[subnodeIndex];
			return node.find(searchEnv);
		}
		return this;
	},
	isSearchMatch: function (searchEnv) {
		return this._env.intersects(searchEnv);
	},
	getSubnode: function (index) {
		if (this._subnode[index] === null) {
			this._subnode[index] = this.createSubnode(index);
		}
		return this._subnode[index];
	},
	getEnvelope: function () {
		return this._env;
	},
	getNode: function (searchEnv) {
		var subnodeIndex = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(searchEnv, this._centrex, this._centrey);
		if (subnodeIndex !== -1) {
			var node = this.getSubnode(subnodeIndex);
			return node.getNode(searchEnv);
		} else {
			return this;
		}
	},
	createSubnode: function (index) {
		var minx = 0.0;
		var maxx = 0.0;
		var miny = 0.0;
		var maxy = 0.0;
		switch (index) {
			case 0:
				minx = this._env.getMinX();
				maxx = this._centrex;
				miny = this._env.getMinY();
				maxy = this._centrey;
				break;
			case 1:
				minx = this._centrex;
				maxx = this._env.getMaxX();
				miny = this._env.getMinY();
				maxy = this._centrey;
				break;
			case 2:
				minx = this._env.getMinX();
				maxx = this._centrex;
				miny = this._centrey;
				maxy = this._env.getMaxY();
				break;
			case 3:
				minx = this._centrex;
				maxx = this._env.getMaxX();
				miny = this._centrey;
				maxy = this._env.getMaxY();
				break;
		}
		var sqEnv = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */](minx, maxx, miny, maxy);
		var node = new Node(sqEnv, this._level - 1);
		return node;
	},
	insertNode: function (node) {
		__WEBPACK_IMPORTED_MODULE_3__util_Assert__["a" /* default */].isTrue(this._env === null || this._env.contains(node._env));
		var index = __WEBPACK_IMPORTED_MODULE_0__NodeBase__["a" /* default */].getSubnodeIndex(node._env, this._centrex, this._centrey);
		if (node._level === this._level - 1) {
			this._subnode[index] = node;
		} else {
			var childNode = this.createSubnode(index);
			childNode.insertNode(node);
			this._subnode[index] = childNode;
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Node;
	}
});
Node.createNode = function (env) {
	var key = new __WEBPACK_IMPORTED_MODULE_5__Key__["a" /* default */](env);
	var node = new Node(key.getEnvelope(), key.getLevel());
	return node;
};
Node.createExpanded = function (node, addEnv) {
	var expandEnv = new __WEBPACK_IMPORTED_MODULE_2__geom_Envelope__["a" /* default */](addEnv);
	if (node !== null) expandEnv.expandToInclude(node._env);
	var largerNode = Node.createNode(expandEnv);
	if (node !== null) largerNode.insertNode(node);
	return largerNode;
};


/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Key;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__DoubleBits__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Envelope__ = __webpack_require__(7);




function Key() {
	this._pt = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
	this._level = 0;
	this._env = null;
	let itemEnv = arguments[0];
	this.computeKey(itemEnv);
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(Key.prototype, {
	getLevel: function () {
		return this._level;
	},
	computeKey: function () {
		if (arguments.length === 1) {
			let itemEnv = arguments[0];
			this._level = Key.computeQuadLevel(itemEnv);
			this._env = new __WEBPACK_IMPORTED_MODULE_3__geom_Envelope__["a" /* default */]();
			this.computeKey(this._level, itemEnv);
			while (!this._env.contains(itemEnv)) {
				this._level += 1;
				this.computeKey(this._level, itemEnv);
			}
		} else if (arguments.length === 2) {
			let level = arguments[0], itemEnv = arguments[1];
			var quadSize = __WEBPACK_IMPORTED_MODULE_2__DoubleBits__["a" /* default */].powerOf2(level);
			this._pt.x = Math.floor(itemEnv.getMinX() / quadSize) * quadSize;
			this._pt.y = Math.floor(itemEnv.getMinY() / quadSize) * quadSize;
			this._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);
		}
	},
	getEnvelope: function () {
		return this._env;
	},
	getCentre: function () {
		return new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);
	},
	getPoint: function () {
		return this._pt;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Key;
	}
});
Key.computeQuadLevel = function (env) {
	var dx = env.getWidth();
	var dy = env.getHeight();
	var dMax = dx > dy ? dx : dy;
	var level = __WEBPACK_IMPORTED_MODULE_2__DoubleBits__["a" /* default */].exponent(dMax) + 1;
	return level;
};


/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__strtree_STRtree__ = __webpack_require__(76);
/* unused harmony reexport STRtree */





/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_GeoJSONReader__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__io_GeoJSONWriter__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__io_WKTReader__ = __webpack_require__(292);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__io_OL3Parser__ = __webpack_require__(293);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__io_GeoJSONReader__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__io_GeoJSONWriter__["a"]; });
/* unused harmony reexport OL3Parser */
/* unused harmony reexport WKTReader */
/* unused harmony reexport WKTWriter */






/**
 * @module jsts/io
 */



/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeoJSONReader;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_PrecisionModel__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__GeoJSONParser__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);





/**
 * Converts a geometry in GeoJSON to a {@link Geometry}.
 */

/**
 * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function GeoJSONReader (geometryFactory) {
  this.geometryFactory = geometryFactory || new __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__["a" /* default */]()
  this.precisionModel = this.geometryFactory.getPrecisionModel()
  this.parser = new __WEBPACK_IMPORTED_MODULE_2__GeoJSONParser__["a" /* default */](this.geometryFactory)
}

Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(GeoJSONReader.prototype, {
  /**
   * Reads a GeoJSON representation of a {@link Geometry}
   *
   * Will also parse GeoJSON Features/FeatureCollections as custom objects.
   *
   * @param {Object|String} geoJson a GeoJSON Object or String.
   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
   * @memberof GeoJSONReader
   */
  read (geoJson) {
    var geometry = this.parser.read(geoJson)

    if (this.precisionModel.getType() === __WEBPACK_IMPORTED_MODULE_1__geom_PrecisionModel__["a" /* default */].FIXED) {
      this.reducePrecision(geometry)
    }

    return geometry
  },

  // NOTE: this is a hack
  reducePrecision (geometry) {
    var i, len

    if (geometry.coordinate) {
      this.precisionModel.makePrecise(geometry.coordinate)
    } else if (geometry.points) {
      for (i = 0, len = geometry.points.length; i < len; i++) {
        this.precisionModel.makePrecise(geometry.points[i])
      }
    } else if (geometry.geometries) {
      for (i = 0, len = geometry.geometries.length; i < len; i++) {
        this.reducePrecision(geometry.geometries[i])
      }
    }
  }
})


/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeoJSONWriter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeoJSONParser__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/**
 * @module GeoJSONWriter
 */




/**
 * Writes the GeoJSON representation of a {@link Geometry}. The
 * The GeoJSON format is defined <A
 * HREF="http://geojson.org/geojson-spec.html">here</A>.
 */

/**
 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function GeoJSONWriter () {
  this.parser = new __WEBPACK_IMPORTED_MODULE_0__GeoJSONParser__["a" /* default */](this.geometryFactory)
}

Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(GeoJSONWriter.prototype, {
  /**
   * Converts a <code>Geometry</code> to its GeoJSON representation.
   *
   * @param {Geometry}
   *          geometry a <code>Geometry</code> to process.
   * @return {Object} The GeoJSON representation of the Geometry.
   * @memberof GeoJSONWriter
   */
  write (geometry) {
    return this.parser.write(geometry)
  }
})


/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_PrecisionModel__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__WKTParser__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);





/**
 * Converts a geometry in Well-Known Text format to a {@link Geometry}.
 * <p>
 * <code>WKTReader</code> supports extracting <code>Geometry</code> objects
 * from either {@link Reader}s or {@link String}s. This allows it to function
 * as a parser to read <code>Geometry</code> objects from text blocks embedded
 * in other data formats (e.g. XML).
 */

/**
 * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function WKTReader (geometryFactory) {
  this.geometryFactory = geometryFactory || new __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__["a" /* default */]()
  this.precisionModel = this.geometryFactory.getPrecisionModel()
  this.parser = new __WEBPACK_IMPORTED_MODULE_2__WKTParser__["a" /* default */](this.geometryFactory)
}

Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(WKTReader.prototype, {
  /**
   * Reads a Well-Known Text representation of a {@link Geometry}
   *
   * @param {string}
   *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features
   *          Specification).
   * @return {Geometry} a <code>Geometry</code> read from
   *         <code>string.</code>
   * @memberof WKTReader
   */
  read (wkt) {
    var geometry = this.parser.read(wkt)

    // TODO: port and use GeometryPrecisionReducer, this is a hack
    if (this.precisionModel.getType() === __WEBPACK_IMPORTED_MODULE_1__geom_PrecisionModel__["a" /* default */].FIXED) {
      this.reducePrecision(geometry)
    }

    return geometry
  },

  reducePrecision (geometry) {
    if (geometry.coordinate) {
      this.precisionModel.makePrecise(geometry.coordinate)
    } else if (geometry._points) {
      for (let i = 0, len = geometry._points._coordinates.length; i < len; i++) {
        this.precisionModel.makePrecise(geometry._points._coordinates[i])
      }
    } else if (geometry._geometries) {
      for (let i = 0, len = geometry._geometries.length; i < len; i++) {
        this.reducePrecision(geometry._geometries[i])
      }
    }
  }
})


/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/*eslint-disable no-undef */





function p2c (p) { return [p.x, p.y] }

/**
 * OpenLayers 3 Geometry parser and writer
 * @param {GeometryFactory} geometryFactory
 * @param {ol} olReference
 * @constructor
 */
function OL3Parser (geometryFactory, olReference) {
  this.geometryFactory = geometryFactory || new __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__["a" /* default */]()
  this.ol = olReference || (typeof ol !== 'undefined' && ol)
}

Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(OL3Parser.prototype, {
  /**
   * @param geometry {ol.geom.Geometry}
   * @return {Geometry}
   * @memberof OL3Parser
   */
  read (geometry) {
    const ol = this.ol
    if (geometry instanceof ol.geom.Point) {
      return this.convertFromPoint(geometry)
    } else if (geometry instanceof ol.geom.LineString) {
      return this.convertFromLineString(geometry)
    } else if (geometry instanceof ol.geom.LinearRing) {
      return this.convertFromLinearRing(geometry)
    } else if (geometry instanceof ol.geom.Polygon) {
      return this.convertFromPolygon(geometry)
    } else if (geometry instanceof ol.geom.MultiPoint) {
      return this.convertFromMultiPoint(geometry)
    } else if (geometry instanceof ol.geom.MultiLineString) {
      return this.convertFromMultiLineString(geometry)
    } else if (geometry instanceof ol.geom.MultiPolygon) {
      return this.convertFromMultiPolygon(geometry)
    } else if (geometry instanceof ol.geom.GeometryCollection) {
      return this.convertFromCollection(geometry)
    }
  },

  convertFromPoint (point) {
    const coordinates = point.getCoordinates()
    return this.geometryFactory.createPoint(new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](coordinates[0], coordinates[1]))
  },

  convertFromLineString (lineString) {
    return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {
      return new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](coordinates[0], coordinates[1])
    }))
  },

  convertFromLinearRing (linearRing) {
    return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {
      return new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](coordinates[0], coordinates[1])
    }))
  },

  convertFromPolygon (polygon) {
    const linearRings = polygon.getLinearRings()
    var shell = null
    var holes = []
    for (let i = 0; i < linearRings.length; i++) {
      const linearRing = this.convertFromLinearRing(linearRings[i])
      if (i === 0) {
        shell = linearRing
      } else {
        holes.push(linearRing)
      }
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  convertFromMultiPoint (multiPoint) {
    const points = multiPoint.getPoints().map(function (point) {
      return this.convertFromPoint(point)
    }, this)
    return this.geometryFactory.createMultiPoint(points)
  },

  convertFromMultiLineString (multiLineString) {
    const lineStrings = multiLineString.getLineStrings().map(function (lineString) {
      return this.convertFromLineString(lineString)
    }, this)
    return this.geometryFactory.createMultiLineString(lineStrings)
  },

  convertFromMultiPolygon (multiPolygon) {
    const polygons = multiPolygon.getPolygons().map(function (polygon) {
      return this.convertFromPolygon(polygon)
    }, this)
    return this.geometryFactory.createMultiPolygon(polygons)
  },

  convertFromCollection (collection) {
    const geometries = collection.getGeometries().map(function (geometry) {
      return this.read(geometry)
    }, this)
    return this.geometryFactory.createGeometryCollection(geometries)
  },

  /**
   * @param geometry
   *          {Geometry}
   * @return {ol.geom.Geometry}
   * @memberof! OL3Parser
   */
  write (geometry) {
    if (geometry.getGeometryType() === 'Point') {
      return this.convertToPoint(geometry.getCoordinate())
    } else if (geometry.getGeometryType() === 'LineString') {
      return this.convertToLineString(geometry)
    } else if (geometry.getGeometryType() === 'LinearRing') {
      return this.convertToLinearRing(geometry)
    } else if (geometry.getGeometryType() === 'Polygon') {
      return this.convertToPolygon(geometry)
    } else if (geometry.getGeometryType() === 'MultiPoint') {
      return this.convertToMultiPoint(geometry)
    } else if (geometry.getGeometryType() === 'MultiLineString') {
      return this.convertToMultiLineString(geometry)
    } else if (geometry.getGeometryType() === 'MultiPolygon') {
      return this.convertToMultiPolygon(geometry)
    } else if (geometry.getGeometryType() === 'GeometryCollection') {
      return this.convertToCollection(geometry)
    }
  },

  convertToPoint (coordinate) {
    return new this.ol.geom.Point([coordinate.x, coordinate.y])
  },

  convertToLineString (lineString) {
    var points = lineString.points.coordinates.map(p2c)
    return new this.ol.geom.LineString(points)
  },

  convertToLinearRing (linearRing) {
    var points = linearRing.points.coordinates.map(p2c)
    return new this.ol.geom.LinearRing(points)
  },

  convertToPolygon (polygon) {
    var rings = [polygon.shell.points.coordinates.map(p2c)]
    for (let i = 0; i < polygon.holes.length; i++) {
      rings.push(polygon.holes[i].points.coordinates.map(p2c))
    }
    return new this.ol.geom.Polygon(rings)
  },

  convertToMultiPoint (multiPoint) {
    return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c))
  },

  convertToMultiLineString (multiLineString) {
    var lineStrings = []
    for (let i = 0; i < multiLineString.geometries.length; i++) {
      lineStrings.push(this.convertToLineString(multiLineString.geometries[i]).getCoordinates())
    }
    return new this.ol.geom.MultiLineString(lineStrings)
  },

  convertToMultiPolygon (multiPolygon) {
    var polygons = []
    for (let i = 0; i < multiPolygon.geometries.length; i++) {
      polygons.push(this.convertToPolygon(multiPolygon.geometries[i]).getCoordinates())
    }
    return new this.ol.geom.MultiPolygon(polygons)
  },

  convertToCollection (geometryCollection) {
    var geometries = []
    for (let i = 0; i < geometryCollection.geometries.length; i++) {
      var geometry = geometryCollection.geometries[i]
      geometries.push(this.write(geometry))
    }
    return new this.ol.geom.GeometryCollection(geometries)
  }
})


/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noding_MCIndexNoder__ = __webpack_require__(75);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noding_ScaledNoder__ = __webpack_require__(153);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__noding_SegmentString__ = __webpack_require__(94);
/* unused harmony namespace reexport */





/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation_BoundaryOp__ = __webpack_require__(89);
/* unused harmony reexport BoundaryOp */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__operation_IsSimpleOp__ = __webpack_require__(296);
/* unused harmony reexport IsSimpleOp */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__operation_buffer__ = __webpack_require__(297);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_distance__ = __webpack_require__(315);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__operation_GeometryGraphOperation__ = __webpack_require__(102);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_linemerge__ = __webpack_require__(319);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_overlay__ = __webpack_require__(327);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_polygonize__ = __webpack_require__(328);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__operation_relate__ = __webpack_require__(340);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__operation_union__ = __webpack_require__(347);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_9__operation_union__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__operation_valid__ = __webpack_require__(352);
/* unused harmony namespace reexport */













/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geomgraph_GeometryGraph__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_util_LinearComponentExtracter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_TreeMap__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geom_MultiLineString__ = __webpack_require__(28);












function IsSimpleOp() {
	this._inputGeom = null;
	this._isClosedEndpointsInInterior = true;
	this._nonSimpleLocation = null;
	if (arguments.length === 1) {
		let geom = arguments[0];
		this._inputGeom = geom;
	} else if (arguments.length === 2) {
		let geom = arguments[0], boundaryNodeRule = arguments[1];
		this._inputGeom = geom;
		this._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(IsSimpleOp.prototype, {
	isSimpleMultiPoint: function (mp) {
		if (mp.isEmpty()) return true;
		var points = new __WEBPACK_IMPORTED_MODULE_0__java_util_TreeSet__["a" /* default */]();
		for (var i = 0; i < mp.getNumGeometries(); i++) {
			var pt = mp.getGeometryN(i);
			var p = pt.getCoordinate();
			if (points.contains(p)) {
				this._nonSimpleLocation = p;
				return false;
			}
			points.add(p);
		}
		return true;
	},
	isSimplePolygonal: function (geom) {
		var rings = __WEBPACK_IMPORTED_MODULE_9__geom_util_LinearComponentExtracter__["a" /* default */].getLines(geom);
		for (var i = rings.iterator(); i.hasNext(); ) {
			var ring = i.next();
			if (!this.isSimpleLinearGeometry(ring)) return false;
		}
		return true;
	},
	hasClosedEndpointIntersection: function (graph) {
		var endPoints = new __WEBPACK_IMPORTED_MODULE_10__java_util_TreeMap__["a" /* default */]();
		for (var i = graph.getEdgeIterator(); i.hasNext(); ) {
			var e = i.next();
			var maxSegmentIndex = e.getMaximumSegmentIndex();
			var isClosed = e.isClosed();
			var p0 = e.getCoordinate(0);
			this.addEndpoint(endPoints, p0, isClosed);
			var p1 = e.getCoordinate(e.getNumPoints() - 1);
			this.addEndpoint(endPoints, p1, isClosed);
		}
		for (var i = endPoints.values().iterator(); i.hasNext(); ) {
			var eiInfo = i.next();
			if (eiInfo.isClosed && eiInfo.degree !== 2) {
				this._nonSimpleLocation = eiInfo.getCoordinate();
				return true;
			}
		}
		return false;
	},
	getNonSimpleLocation: function () {
		return this._nonSimpleLocation;
	},
	isSimpleLinearGeometry: function (geom) {
		if (geom.isEmpty()) return true;
		var graph = new __WEBPACK_IMPORTED_MODULE_5__geomgraph_GeometryGraph__["a" /* default */](0, geom);
		var li = new __WEBPACK_IMPORTED_MODULE_8__algorithm_RobustLineIntersector__["a" /* default */]();
		var si = graph.computeSelfNodes(li, true);
		if (!si.hasIntersection()) return true;
		if (si.hasProperIntersection()) {
			this._nonSimpleLocation = si.getProperIntersectionPoint();
			return false;
		}
		if (this.hasNonEndpointIntersection(graph)) return false;
		if (this._isClosedEndpointsInInterior) {
			if (this.hasClosedEndpointIntersection(graph)) return false;
		}
		return true;
	},
	hasNonEndpointIntersection: function (graph) {
		for (var i = graph.getEdgeIterator(); i.hasNext(); ) {
			var e = i.next();
			var maxSegmentIndex = e.getMaximumSegmentIndex();
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {
				var ei = eiIt.next();
				if (!ei.isEndPoint(maxSegmentIndex)) {
					this._nonSimpleLocation = ei.getCoordinate();
					return true;
				}
			}
		}
		return false;
	},
	addEndpoint: function (endPoints, p, isClosed) {
		var eiInfo = endPoints.get(p);
		if (eiInfo === null) {
			eiInfo = new EndpointInfo(p);
			endPoints.put(p, eiInfo);
		}
		eiInfo.addEndpoint(isClosed);
	},
	computeSimple: function (geom) {
		this._nonSimpleLocation = null;
		if (geom.isEmpty()) return true;
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) return this.isSimpleLinearGeometry(geom);
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_11__geom_MultiLineString__["a" /* default */]) return this.isSimpleLinearGeometry(geom);
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_3__geom_MultiPoint__["a" /* default */]) return this.isSimpleMultiPoint(geom);
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(geom, __WEBPACK_IMPORTED_MODULE_7__geom_Polygonal__["a" /* default */])) return this.isSimplePolygonal(geom);
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_6__geom_GeometryCollection__["a" /* default */]) return this.isSimpleGeometryCollection(geom);
		return true;
	},
	isSimple: function () {
		this._nonSimpleLocation = null;
		return this.computeSimple(this._inputGeom);
	},
	isSimpleGeometryCollection: function (geom) {
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var comp = geom.getGeometryN(i);
			if (!this.computeSimple(comp)) return false;
		}
		return true;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IsSimpleOp;
	}
});
function EndpointInfo() {
	this.pt = null;
	this.isClosed = null;
	this.degree = null;
	let pt = arguments[0];
	this.pt = pt;
	this.isClosed = false;
	this.degree = 0;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(EndpointInfo.prototype, {
	addEndpoint: function (isClosed) {
		this.degree++;
		this.isClosed |= isClosed;
	},
	getCoordinate: function () {
		return this.pt;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EndpointInfo;
	}
});
IsSimpleOp.EndpointInfo = EndpointInfo;


/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buffer_BufferOp__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__buffer_BufferParameters__ = __webpack_require__(80);
/* unused harmony reexport BufferOp */
/* unused harmony reexport BufferParameters */






/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BufferParameters__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__BufferBuilder__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__noding_ScaledNoder__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_MathUtil__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_PrecisionModel__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_lang_RuntimeException__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__noding_snapround_MCIndexSnapRounder__ = __webpack_require__(310);










function BufferOp() {
	this._argGeom = null;
	this._distance = null;
	this._bufParams = new __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */]();
	this._resultGeometry = null;
	this._saveException = null;
	if (arguments.length === 1) {
		let g = arguments[0];
		this._argGeom = g;
	} else if (arguments.length === 2) {
		let g = arguments[0], bufParams = arguments[1];
		this._argGeom = g;
		this._bufParams = bufParams;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(BufferOp.prototype, {
	bufferFixedPrecision: function (fixedPM) {
		var noder = new __WEBPACK_IMPORTED_MODULE_3__noding_ScaledNoder__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_9__noding_snapround_MCIndexSnapRounder__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_7__geom_PrecisionModel__["a" /* default */](1.0)), fixedPM.getScale());
		var bufBuilder = new __WEBPACK_IMPORTED_MODULE_2__BufferBuilder__["a" /* default */](this._bufParams);
		bufBuilder.setWorkingPrecisionModel(fixedPM);
		bufBuilder.setNoder(noder);
		this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
	},
	bufferReducedPrecision: function () {
		if (arguments.length === 0) {
			for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
				try {
					this.bufferReducedPrecision(precDigits);
				} catch (ex) {
					if (ex instanceof __WEBPACK_IMPORTED_MODULE_4__geom_TopologyException__["a" /* default */]) {
						this._saveException = ex;
					} else throw ex;
				} finally {}
				if (this._resultGeometry !== null) return null;
			}
			throw this._saveException;
		} else if (arguments.length === 1) {
			let precisionDigits = arguments[0];
			var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
			var fixedPM = new __WEBPACK_IMPORTED_MODULE_7__geom_PrecisionModel__["a" /* default */](sizeBasedScaleFactor);
			this.bufferFixedPrecision(fixedPM);
		}
	},
	computeGeometry: function () {
		this.bufferOriginalPrecision();
		if (this._resultGeometry !== null) return null;
		var argPM = this._argGeom.getFactory().getPrecisionModel();
		if (argPM.getType() === __WEBPACK_IMPORTED_MODULE_7__geom_PrecisionModel__["a" /* default */].FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision();
	},
	setQuadrantSegments: function (quadrantSegments) {
		this._bufParams.setQuadrantSegments(quadrantSegments);
	},
	bufferOriginalPrecision: function () {
		try {
			var bufBuilder = new __WEBPACK_IMPORTED_MODULE_2__BufferBuilder__["a" /* default */](this._bufParams);
			this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_8__java_lang_RuntimeException__["a" /* default */]) {
				this._saveException = ex;
			} else throw ex;
		} finally {}
	},
	getResultGeometry: function (distance) {
		this._distance = distance;
		this.computeGeometry();
		return this._resultGeometry;
	},
	setEndCapStyle: function (endCapStyle) {
		this._bufParams.setEndCapStyle(endCapStyle);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return BufferOp;
	}
});
BufferOp.bufferOp = function () {
	if (arguments.length === 2) {
		let g = arguments[0], distance = arguments[1];
		var gBuf = new BufferOp(g);
		var geomBuf = gBuf.getResultGeometry(distance);
		return geomBuf;
	} else if (arguments.length === 3) {
		if (Number.isInteger(arguments[2]) && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */] && typeof arguments[1] === "number")) {
			let g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2];
			var bufOp = new BufferOp(g);
			bufOp.setQuadrantSegments(quadrantSegments);
			var geomBuf = bufOp.getResultGeometry(distance);
			return geomBuf;
		} else if (arguments[2] instanceof __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */] && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */] && typeof arguments[1] === "number")) {
			let g = arguments[0], distance = arguments[1], params = arguments[2];
			var bufOp = new BufferOp(g, params);
			var geomBuf = bufOp.getResultGeometry(distance);
			return geomBuf;
		}
	} else if (arguments.length === 4) {
		let g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3];
		var bufOp = new BufferOp(g);
		bufOp.setQuadrantSegments(quadrantSegments);
		bufOp.setEndCapStyle(endCapStyle);
		var geomBuf = bufOp.getResultGeometry(distance);
		return geomBuf;
	}
};
BufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {
	var env = g.getEnvelopeInternal();
	var envMax = __WEBPACK_IMPORTED_MODULE_6__math_MathUtil__["a" /* default */].max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
	var expandByDistance = distance > 0.0 ? distance : 0.0;
	var bufEnvMax = envMax + 2 * expandByDistance;
	var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
	var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
	var scaleFactor = Math.pow(10.0, minUnitLog10);
	return scaleFactor;
};
BufferOp.CAP_ROUND = __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_ROUND;
BufferOp.CAP_BUTT = __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_FLAT;
BufferOp.CAP_FLAT = __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_FLAT;
BufferOp.CAP_SQUARE = __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_SQUARE;
BufferOp.MAX_PRECISION_DIGITS = 12;


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BufferSubgraph__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__overlay_PolygonBuilder__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__noding_MCIndexNoder__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__OffsetCurveBuilder__ = __webpack_require__(303);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__SubgraphDepthLocater__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__OffsetCurveSetBuilder__ = __webpack_require__(308);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geomgraph_Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__overlay_OverlayNodeFactory__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geomgraph_EdgeList__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__noding_IntersectionAdder__ = __webpack_require__(309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__geomgraph_Edge__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__geomgraph_PlanarGraph__ = __webpack_require__(64);



















function BufferBuilder() {
	this._bufParams = null;
	this._workingPrecisionModel = null;
	this._workingNoder = null;
	this._geomFact = null;
	this._graph = null;
	this._edgeList = new __WEBPACK_IMPORTED_MODULE_13__geomgraph_EdgeList__["a" /* default */]();
	let bufParams = arguments[0];
	this._bufParams = bufParams;
}
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(BufferBuilder.prototype, {
	setWorkingPrecisionModel: function (pm) {
		this._workingPrecisionModel = pm;
	},
	insertUniqueEdge: function (e) {
		var existingEdge = this._edgeList.findEqualEdge(e);
		if (existingEdge !== null) {
			var existingLabel = existingEdge.getLabel();
			var labelToMerge = e.getLabel();
			if (!existingEdge.isPointwiseEqual(e)) {
				labelToMerge = new __WEBPACK_IMPORTED_MODULE_11__geomgraph_Label__["a" /* default */](e.getLabel());
				labelToMerge.flip();
			}
			existingLabel.merge(labelToMerge);
			var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
			var existingDelta = existingEdge.getDepthDelta();
			var newDelta = existingDelta + mergeDelta;
			existingEdge.setDepthDelta(newDelta);
		} else {
			this._edgeList.add(e);
			e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
		}
	},
	buildSubgraphs: function (subgraphList, polyBuilder) {
		var processedGraphs = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		for (var i = subgraphList.iterator(); i.hasNext(); ) {
			var subgraph = i.next();
			var p = subgraph.getRightmostCoordinate();
			var locater = new __WEBPACK_IMPORTED_MODULE_9__SubgraphDepthLocater__["a" /* default */](processedGraphs);
			var outsideDepth = locater.getDepth(p);
			subgraph.computeDepth(outsideDepth);
			subgraph.findResultEdges();
			processedGraphs.add(subgraph);
			polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
		}
	},
	createSubgraphs: function (graph) {
		var subgraphList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
		for (var i = graph.getNodes().iterator(); i.hasNext(); ) {
			var node = i.next();
			if (!node.isVisited()) {
				var subgraph = new __WEBPACK_IMPORTED_MODULE_1__BufferSubgraph__["a" /* default */]();
				subgraph.create(node);
				subgraphList.add(subgraph);
			}
		}
		__WEBPACK_IMPORTED_MODULE_8__java_util_Collections__["a" /* default */].sort(subgraphList, __WEBPACK_IMPORTED_MODULE_8__java_util_Collections__["a" /* default */].reverseOrder());
		return subgraphList;
	},
	createEmptyResultGeometry: function () {
		var emptyGeom = this._geomFact.createPolygon();
		return emptyGeom;
	},
	getNoder: function (precisionModel) {
		if (this._workingNoder !== null) return this._workingNoder;
		var noder = new __WEBPACK_IMPORTED_MODULE_5__noding_MCIndexNoder__["a" /* default */]();
		var li = new __WEBPACK_IMPORTED_MODULE_15__algorithm_RobustLineIntersector__["a" /* default */]();
		li.setPrecisionModel(precisionModel);
		noder.setSegmentIntersector(new __WEBPACK_IMPORTED_MODULE_16__noding_IntersectionAdder__["a" /* default */](li));
		return noder;
	},
	buffer: function (g, distance) {
		var precisionModel = this._workingPrecisionModel;
		if (precisionModel === null) precisionModel = g.getPrecisionModel();
		this._geomFact = g.getFactory();
		var curveBuilder = new __WEBPACK_IMPORTED_MODULE_6__OffsetCurveBuilder__["a" /* default */](precisionModel, this._bufParams);
		var curveSetBuilder = new __WEBPACK_IMPORTED_MODULE_10__OffsetCurveSetBuilder__["a" /* default */](g, distance, curveBuilder);
		var bufferSegStrList = curveSetBuilder.getCurves();
		if (bufferSegStrList.size() <= 0) {
			return this.createEmptyResultGeometry();
		}
		this.computeNodedEdges(bufferSegStrList, precisionModel);
		this._graph = new __WEBPACK_IMPORTED_MODULE_18__geomgraph_PlanarGraph__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_12__overlay_OverlayNodeFactory__["a" /* default */]());
		this._graph.addEdges(this._edgeList.getEdges());
		var subgraphList = this.createSubgraphs(this._graph);
		var polyBuilder = new __WEBPACK_IMPORTED_MODULE_2__overlay_PolygonBuilder__["a" /* default */](this._geomFact);
		this.buildSubgraphs(subgraphList, polyBuilder);
		var resultPolyList = polyBuilder.getPolygons();
		if (resultPolyList.size() <= 0) {
			return this.createEmptyResultGeometry();
		}
		var resultGeom = this._geomFact.buildGeometry(resultPolyList);
		return resultGeom;
	},
	computeNodedEdges: function (bufferSegStrList, precisionModel) {
		var noder = this.getNoder(precisionModel);
		noder.computeNodes(bufferSegStrList);
		var nodedSegStrings = noder.getNodedSubstrings();
		for (var i = nodedSegStrings.iterator(); i.hasNext(); ) {
			var segStr = i.next();
			var pts = segStr.getCoordinates();
			if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;
			var oldLabel = segStr.getData();
			var edge = new __WEBPACK_IMPORTED_MODULE_17__geomgraph_Edge__["a" /* default */](segStr.getCoordinates(), new __WEBPACK_IMPORTED_MODULE_11__geomgraph_Label__["a" /* default */](oldLabel));
			this.insertUniqueEdge(edge);
		}
	},
	setNoder: function (noder) {
		this._workingNoder = noder;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return BufferBuilder;
	}
});
BufferBuilder.depthDelta = function (label) {
	var lLoc = label.getLocation(0, __WEBPACK_IMPORTED_MODULE_4__geomgraph_Position__["a" /* default */].LEFT);
	var rLoc = label.getLocation(0, __WEBPACK_IMPORTED_MODULE_4__geomgraph_Position__["a" /* default */].RIGHT);
	if (lLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR && rLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR) return 1; else if (lLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR && rLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) return -1;
	return 0;
};
BufferBuilder.convertSegStrings = function (it) {
	var fact = new __WEBPACK_IMPORTED_MODULE_3__geom_GeometryFactory__["a" /* default */]();
	var lines = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
	while (it.hasNext()) {
		var ss = it.next();
		var line = fact.createLineString(ss.getCoordinates());
		lines.add(line);
	}
	return fact.buildGeometry(lines);
};


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferSubgraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__java_util_HashSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Stack__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__RightmostEdgeFinder__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_TopologyException__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_LinkedList__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_Envelope__ = __webpack_require__(7);










function BufferSubgraph() {
	this._finder = null;
	this._dirEdgeList = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
	this._nodes = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
	this._rightMostCoord = null;
	this._env = null;
	this._finder = new __WEBPACK_IMPORTED_MODULE_3__RightmostEdgeFinder__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(BufferSubgraph.prototype, {
	clearVisitedEdges: function () {
		for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
			var de = it.next();
			de.setVisited(false);
		}
	},
	getRightmostCoordinate: function () {
		return this._rightMostCoord;
	},
	computeNodeDepth: function (n) {
		var startEdge = null;
		for (var i = n.getEdges().iterator(); i.hasNext(); ) {
			var de = i.next();
			if (de.isVisited() || de.getSym().isVisited()) {
				startEdge = de;
				break;
			}
		}
		if (startEdge === null) throw new __WEBPACK_IMPORTED_MODULE_4__geom_TopologyException__["a" /* default */]("unable to find edge to compute depths at " + n.getCoordinate());
		n.getEdges().computeDepths(startEdge);
		for (var i = n.getEdges().iterator(); i.hasNext(); ) {
			var de = i.next();
			de.setVisited(true);
			this.copySymDepths(de);
		}
	},
	computeDepth: function (outsideDepth) {
		this.clearVisitedEdges();
		var de = this._finder.getEdge();
		var n = de.getNode();
		var label = de.getLabel();
		de.setEdgeDepths(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].RIGHT, outsideDepth);
		this.copySymDepths(de);
		this.computeDepths(de);
	},
	create: function (node) {
		this.addReachable(node);
		this._finder.findEdge(this._dirEdgeList);
		this._rightMostCoord = this._finder.getCoordinate();
	},
	findResultEdges: function () {
		for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
			var de = it.next();
			if (de.getDepth(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].RIGHT) >= 1 && de.getDepth(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT) <= 0 && !de.isInteriorAreaEdge()) {
				de.setInResult(true);
			}
		}
	},
	computeDepths: function (startEdge) {
		var nodesVisited = new __WEBPACK_IMPORTED_MODULE_0__java_util_HashSet__["a" /* default */]();
		var nodeQueue = new __WEBPACK_IMPORTED_MODULE_6__java_util_LinkedList__["a" /* default */]();
		var startNode = startEdge.getNode();
		nodeQueue.addLast(startNode);
		nodesVisited.add(startNode);
		startEdge.setVisited(true);
		while (!nodeQueue.isEmpty()) {
			var n = nodeQueue.removeFirst();
			nodesVisited.add(n);
			this.computeNodeDepth(n);
			for (var i = n.getEdges().iterator(); i.hasNext(); ) {
				var de = i.next();
				var sym = de.getSym();
				if (sym.isVisited()) continue;
				var adjNode = sym.getNode();
				if (!nodesVisited.contains(adjNode)) {
					nodeQueue.addLast(adjNode);
					nodesVisited.add(adjNode);
				}
			}
		}
	},
	compareTo: function (o) {
		var graph = o;
		if (this._rightMostCoord.x < graph._rightMostCoord.x) {
			return -1;
		}
		if (this._rightMostCoord.x > graph._rightMostCoord.x) {
			return 1;
		}
		return 0;
	},
	getEnvelope: function () {
		if (this._env === null) {
			var edgeEnv = new __WEBPACK_IMPORTED_MODULE_9__geom_Envelope__["a" /* default */]();
			for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
				var dirEdge = it.next();
				var pts = dirEdge.getEdge().getCoordinates();
				for (var i = 0; i < pts.length - 1; i++) {
					edgeEnv.expandToInclude(pts[i]);
				}
			}
			this._env = edgeEnv;
		}
		return this._env;
	},
	addReachable: function (startNode) {
		var nodeStack = new __WEBPACK_IMPORTED_MODULE_2__java_util_Stack__["a" /* default */]();
		nodeStack.add(startNode);
		while (!nodeStack.empty()) {
			var node = nodeStack.pop();
			this.add(node, nodeStack);
		}
	},
	copySymDepths: function (de) {
		var sym = de.getSym();
		sym.setDepth(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT, de.getDepth(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].RIGHT));
		sym.setDepth(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].RIGHT, de.getDepth(__WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT));
	},
	add: function (node, nodeStack) {
		node.setVisited(true);
		this._nodes.add(node);
		for (var i = node.getEdges().iterator(); i.hasNext(); ) {
			var de = i.next();
			this._dirEdgeList.add(de);
			var sym = de.getSym();
			var symNode = sym.getNode();
			if (!symNode.isVisited()) nodeStack.push(symNode);
		}
	},
	getNodes: function () {
		return this._nodes;
	},
	getDirectedEdges: function () {
		return this._dirEdgeList;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_7__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return BufferSubgraph;
	}
});


/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RightmostEdgeFinder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_Assert__ = __webpack_require__(4);




function RightmostEdgeFinder() {
	this._minIndex = -1;
	this._minCoord = null;
	this._minDe = null;
	this._orientedDe = null;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(RightmostEdgeFinder.prototype, {
	getCoordinate: function () {
		return this._minCoord;
	},
	getRightmostSide: function (de, index) {
		var side = this.getRightmostSideOfSegment(de, index);
		if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
		if (side < 0) {
			this._minCoord = null;
			this.checkForRightmostCoordinate(de);
		}
		return side;
	},
	findRightmostEdgeAtVertex: function () {
		var pts = this._minDe.getEdge().getCoordinates();
		__WEBPACK_IMPORTED_MODULE_3__util_Assert__["a" /* default */].isTrue(this._minIndex > 0 && this._minIndex < pts.length, "rightmost point expected to be interior vertex of edge");
		var pPrev = pts[this._minIndex - 1];
		var pNext = pts[this._minIndex + 1];
		var orientation = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(this._minCoord, pNext, pPrev);
		var usePrev = false;
		if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].COUNTERCLOCKWISE) {
			usePrev = true;
		} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE) {
			usePrev = true;
		}
		if (usePrev) {
			this._minIndex = this._minIndex - 1;
		}
	},
	getRightmostSideOfSegment: function (de, i) {
		var e = de.getEdge();
		var coord = e.getCoordinates();
		if (i < 0 || i + 1 >= coord.length) return -1;
		if (coord[i].y === coord[i + 1].y) return -1;
		var pos = __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT;
		if (coord[i].y < coord[i + 1].y) pos = __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].RIGHT;
		return pos;
	},
	getEdge: function () {
		return this._orientedDe;
	},
	checkForRightmostCoordinate: function (de) {
		var coord = de.getEdge().getCoordinates();
		for (var i = 0; i < coord.length - 1; i++) {
			if (this._minCoord === null || coord[i].x > this._minCoord.x) {
				this._minDe = de;
				this._minIndex = i;
				this._minCoord = coord[i];
			}
		}
	},
	findRightmostEdgeAtNode: function () {
		var node = this._minDe.getNode();
		var star = node.getEdges();
		this._minDe = star.getRightmostEdge();
		if (!this._minDe.isForward()) {
			this._minDe = this._minDe.getSym();
			this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
		}
	},
	findEdge: function (dirEdgeList) {
		for (var i = dirEdgeList.iterator(); i.hasNext(); ) {
			var de = i.next();
			if (!de.isForward()) continue;
			this.checkForRightmostCoordinate(de);
		}
		__WEBPACK_IMPORTED_MODULE_3__util_Assert__["a" /* default */].isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing");
		if (this._minIndex === 0) {
			this.findRightmostEdgeAtNode();
		} else {
			this.findRightmostEdgeAtVertex();
		}
		this._orientedDe = this._minDe;
		var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
		if (rightmostSide === __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT) {
			this._orientedDe = this._minDe.getSym();
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RightmostEdgeFinder;
	}
});


/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkedList;
function LinkedList () {
  this.array_ = []
}
LinkedList.prototype.addLast = function (e) {
  this.array_.push(e)
}
LinkedList.prototype.removeFirst = function () {
  return this.array_.shift()
}
LinkedList.prototype.isEmpty = function () {
  return this.array_.length === 0
}


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OffsetCurveBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BufferParameters__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__ = __webpack_require__(304);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__OffsetSegmentGenerator__ = __webpack_require__(305);







function OffsetCurveBuilder() {
	this._distance = 0.0;
	this._precisionModel = null;
	this._bufParams = null;
	let precisionModel = arguments[0], bufParams = arguments[1];
	this._precisionModel = precisionModel;
	this._bufParams = bufParams;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(OffsetCurveBuilder.prototype, {
	getOffsetCurve: function (inputPts, distance) {
		this._distance = distance;
		if (distance === 0.0) return null;
		var isRightSide = distance < 0.0;
		var posDistance = Math.abs(distance);
		var segGen = this.getSegGen(posDistance);
		if (inputPts.length <= 1) {
			this.computePointCurve(inputPts[0], segGen);
		} else {
			this.computeOffsetCurve(inputPts, isRightSide, segGen);
		}
		var curvePts = segGen.getCoordinates();
		if (isRightSide) __WEBPACK_IMPORTED_MODULE_5__geom_CoordinateArrays__["a" /* default */].reverse(curvePts);
		return curvePts;
	},
	computeSingleSidedBufferCurve: function (inputPts, isRightSide, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (isRightSide) {
			segGen.addSegments(inputPts, true);
			var simp2 = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, -distTol);
			var n2 = simp2.length - 1;
			segGen.initSideSegments(simp2[n2], simp2[n2 - 1], __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT);
			segGen.addFirstSegment();
			for (var i = n2 - 2; i >= 0; i--) {
				segGen.addNextSegment(simp2[i], true);
			}
		} else {
			segGen.addSegments(inputPts, false);
			var simp1 = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, distTol);
			var n1 = simp1.length - 1;
			segGen.initSideSegments(simp1[0], simp1[1], __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT);
			segGen.addFirstSegment();
			for (var i = 2; i <= n1; i++) {
				segGen.addNextSegment(simp1[i], true);
			}
		}
		segGen.addLastSegment();
		segGen.closeRing();
	},
	computeRingBufferCurve: function (inputPts, side, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (side === __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].RIGHT) distTol = -distTol;
		var simp = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, distTol);
		var n = simp.length - 1;
		segGen.initSideSegments(simp[n - 1], simp[0], side);
		for (var i = 1; i <= n; i++) {
			var addStartPoint = i !== 1;
			segGen.addNextSegment(simp[i], addStartPoint);
		}
		segGen.closeRing();
	},
	computeLineBufferCurve: function (inputPts, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		var simp1 = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, distTol);
		var n1 = simp1.length - 1;
		segGen.initSideSegments(simp1[0], simp1[1], __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT);
		for (var i = 2; i <= n1; i++) {
			segGen.addNextSegment(simp1[i], true);
		}
		segGen.addLastSegment();
		segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
		var simp2 = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, -distTol);
		var n2 = simp2.length - 1;
		segGen.initSideSegments(simp2[n2], simp2[n2 - 1], __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT);
		for (var i = n2 - 2; i >= 0; i--) {
			segGen.addNextSegment(simp2[i], true);
		}
		segGen.addLastSegment();
		segGen.addLineEndCap(simp2[1], simp2[0]);
		segGen.closeRing();
	},
	computePointCurve: function (pt, segGen) {
		switch (this._bufParams.getEndCapStyle()) {
			case __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_ROUND:
				segGen.createCircle(pt);
				break;
			case __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_SQUARE:
				segGen.createSquare(pt);
				break;
		}
	},
	getLineCurve: function (inputPts, distance) {
		this._distance = distance;
		if (distance < 0.0 && !this._bufParams.isSingleSided()) return null;
		if (distance === 0.0) return null;
		var posDistance = Math.abs(distance);
		var segGen = this.getSegGen(posDistance);
		if (inputPts.length <= 1) {
			this.computePointCurve(inputPts[0], segGen);
		} else {
			if (this._bufParams.isSingleSided()) {
				var isRightSide = distance < 0.0;
				this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
			} else this.computeLineBufferCurve(inputPts, segGen);
		}
		var lineCoord = segGen.getCoordinates();
		return lineCoord;
	},
	getBufferParameters: function () {
		return this._bufParams;
	},
	simplifyTolerance: function (bufDistance) {
		return bufDistance * this._bufParams.getSimplifyFactor();
	},
	getRingCurve: function (inputPts, side, distance) {
		this._distance = distance;
		if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);
		if (distance === 0.0) {
			return OffsetCurveBuilder.copyCoordinates(inputPts);
		}
		var segGen = this.getSegGen(distance);
		this.computeRingBufferCurve(inputPts, side, segGen);
		return segGen.getCoordinates();
	},
	computeOffsetCurve: function (inputPts, isRightSide, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (isRightSide) {
			var simp2 = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, -distTol);
			var n2 = simp2.length - 1;
			segGen.initSideSegments(simp2[n2], simp2[n2 - 1], __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT);
			segGen.addFirstSegment();
			for (var i = n2 - 2; i >= 0; i--) {
				segGen.addNextSegment(simp2[i], true);
			}
		} else {
			var simp1 = __WEBPACK_IMPORTED_MODULE_4__BufferInputLineSimplifier__["a" /* default */].simplify(inputPts, distTol);
			var n1 = simp1.length - 1;
			segGen.initSideSegments(simp1[0], simp1[1], __WEBPACK_IMPORTED_MODULE_1__geomgraph_Position__["a" /* default */].LEFT);
			segGen.addFirstSegment();
			for (var i = 2; i <= n1; i++) {
				segGen.addNextSegment(simp1[i], true);
			}
		}
		segGen.addLastSegment();
	},
	getSegGen: function (distance) {
		return new __WEBPACK_IMPORTED_MODULE_6__OffsetSegmentGenerator__["a" /* default */](this._precisionModel, this._bufParams, distance);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return OffsetCurveBuilder;
	}
});
OffsetCurveBuilder.copyCoordinates = function (pts) {
	var copy = new Array(pts.length).fill(null);
	for (var i = 0; i < copy.length; i++) {
		copy[i] = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](pts[i]);
	}
	return copy;
};


/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferInputLineSimplifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);



function BufferInputLineSimplifier() {
	this._inputLine = null;
	this._distanceTol = null;
	this._isDeleted = null;
	this._angleOrientation = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].COUNTERCLOCKWISE;
	let inputLine = arguments[0];
	this._inputLine = inputLine;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(BufferInputLineSimplifier.prototype, {
	isDeletable: function (i0, i1, i2, distanceTol) {
		var p0 = this._inputLine[i0];
		var p1 = this._inputLine[i1];
		var p2 = this._inputLine[i2];
		if (!this.isConcave(p0, p1, p2)) return false;
		if (!this.isShallow(p0, p1, p2, distanceTol)) return false;
		return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
	},
	deleteShallowConcavities: function () {
		var index = 1;
		var maxIndex = this._inputLine.length - 1;
		var midIndex = this.findNextNonDeletedIndex(index);
		var lastIndex = this.findNextNonDeletedIndex(midIndex);
		var isChanged = false;
		while (lastIndex < this._inputLine.length) {
			var isMiddleVertexDeleted = false;
			if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
				this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
				isMiddleVertexDeleted = true;
				isChanged = true;
			}
			if (isMiddleVertexDeleted) index = lastIndex; else index = midIndex;
			midIndex = this.findNextNonDeletedIndex(index);
			lastIndex = this.findNextNonDeletedIndex(midIndex);
		}
		return isChanged;
	},
	isShallowConcavity: function (p0, p1, p2, distanceTol) {
		var orientation = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(p0, p1, p2);
		var isAngleToSimplify = orientation === this._angleOrientation;
		if (!isAngleToSimplify) return false;
		var dist = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].distancePointLine(p1, p0, p2);
		return dist < distanceTol;
	},
	isShallowSampled: function (p0, p2, i0, i2, distanceTol) {
		var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
		if (inc <= 0) inc = 1;
		for (var i = i0; i < i2; i += inc) {
			if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;
		}
		return true;
	},
	isConcave: function (p0, p1, p2) {
		var orientation = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(p0, p1, p2);
		var isConcave = orientation === this._angleOrientation;
		return isConcave;
	},
	simplify: function (distanceTol) {
		this._distanceTol = Math.abs(distanceTol);
		if (distanceTol < 0) this._angleOrientation = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE;
		this._isDeleted = new Array(this._inputLine.length).fill(null);
		var isChanged = false;
		do {
			isChanged = this.deleteShallowConcavities();
		} while (isChanged);
		return this.collapseLine();
	},
	findNextNonDeletedIndex: function (index) {
		var next = index + 1;
		while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++;
		return next;
	},
	isShallow: function (p0, p1, p2, distanceTol) {
		var dist = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].distancePointLine(p1, p0, p2);
		return dist < distanceTol;
	},
	collapseLine: function () {
		var coordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */]();
		for (var i = 0; i < this._inputLine.length; i++) {
			if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
		}
		return coordList.toCoordinateArray();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return BufferInputLineSimplifier;
	}
});
BufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {
	var simp = new BufferInputLineSimplifier(inputLine);
	return simp.simplify(distanceTol);
};
BufferInputLineSimplifier.INIT = 0;
BufferInputLineSimplifier.DELETE = 1;
BufferInputLineSimplifier.KEEP = 1;
BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;


/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OffsetSegmentGenerator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BufferParameters__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_NotRepresentableException__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__OffsetSegmentString__ = __webpack_require__(306);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__algorithm_Angle__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__algorithm_HCoordinate__ = __webpack_require__(56);











function OffsetSegmentGenerator() {
	this._maxCurveSegmentError = 0.0;
	this._filletAngleQuantum = null;
	this._closingSegLengthFactor = 1;
	this._segList = null;
	this._distance = 0.0;
	this._precisionModel = null;
	this._bufParams = null;
	this._li = null;
	this._s0 = null;
	this._s1 = null;
	this._s2 = null;
	this._seg0 = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
	this._seg1 = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
	this._offset0 = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
	this._offset1 = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
	this._side = 0;
	this._hasNarrowConcaveAngle = false;
	let precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2];
	this._precisionModel = precisionModel;
	this._bufParams = bufParams;
	this._li = new __WEBPACK_IMPORTED_MODULE_9__algorithm_RobustLineIntersector__["a" /* default */]();
	this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
	if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
	this.init(distance);
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(OffsetSegmentGenerator.prototype, {
	addNextSegment: function (p, addStartPoint) {
		this._s0 = this._s1;
		this._s1 = this._s2;
		this._s2 = p;
		this._seg0.setCoordinates(this._s0, this._s1);
		this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
		this._seg1.setCoordinates(this._s1, this._s2);
		this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
		if (this._s1.equals(this._s2)) return null;
		var orientation = __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(this._s0, this._s1, this._s2);
		var outsideTurn = orientation === __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE && this._side === __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].LEFT || orientation === __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].COUNTERCLOCKWISE && this._side === __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].RIGHT;
		if (orientation === 0) {
			this.addCollinear(addStartPoint);
		} else if (outsideTurn) {
			this.addOutsideTurn(orientation, addStartPoint);
		} else {
			this.addInsideTurn(orientation, addStartPoint);
		}
	},
	addLineEndCap: function (p0, p1) {
		var seg = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */](p0, p1);
		var offsetL = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
		this.computeOffsetSegment(seg, __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].LEFT, this._distance, offsetL);
		var offsetR = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
		this.computeOffsetSegment(seg, __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].RIGHT, this._distance, offsetR);
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		var angle = Math.atan2(dy, dx);
		switch (this._bufParams.getEndCapStyle()) {
			case __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_ROUND:
				this._segList.addPt(offsetL.p1);
				this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE, this._distance);
				this._segList.addPt(offsetR.p1);
				break;
			case __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_FLAT:
				this._segList.addPt(offsetL.p1);
				this._segList.addPt(offsetR.p1);
				break;
			case __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].CAP_SQUARE:
				var squareCapSideOffset = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */]();
				squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
				squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
				var squareCapLOffset = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
				var squareCapROffset = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
				this._segList.addPt(squareCapLOffset);
				this._segList.addPt(squareCapROffset);
				break;
		}
	},
	getCoordinates: function () {
		var pts = this._segList.getCoordinates();
		return pts;
	},
	addMitreJoin: function (p, offset0, offset1, distance) {
		var isMitreWithinLimit = true;
		var intPt = null;
		try {
			intPt = __WEBPACK_IMPORTED_MODULE_10__algorithm_HCoordinate__["a" /* default */].intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
			var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
			if (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_1__algorithm_NotRepresentableException__["a" /* default */]) {
				intPt = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](0, 0);
				isMitreWithinLimit = false;
			} else throw ex;
		} finally {}
		if (isMitreWithinLimit) {
			this._segList.addPt(intPt);
		} else {
			this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
		}
	},
	addFilletCorner: function (p, p0, p1, direction, radius) {
		var dx0 = p0.x - p.x;
		var dy0 = p0.y - p.y;
		var startAngle = Math.atan2(dy0, dx0);
		var dx1 = p1.x - p.x;
		var dy1 = p1.y - p.y;
		var endAngle = Math.atan2(dy1, dx1);
		if (direction === __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE) {
			if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
		} else {
			if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
		}
		this._segList.addPt(p0);
		this.addFilletArc(p, startAngle, endAngle, direction, radius);
		this._segList.addPt(p1);
	},
	addOutsideTurn: function (orientation, addStartPoint) {
		if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
			this._segList.addPt(this._offset0.p1);
			return null;
		}
		if (this._bufParams.getJoinStyle() === __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].JOIN_MITRE) {
			this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
		} else if (this._bufParams.getJoinStyle() === __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].JOIN_BEVEL) {
			this.addBevelJoin(this._offset0, this._offset1);
		} else {
			if (addStartPoint) this._segList.addPt(this._offset0.p1);
			this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
			this._segList.addPt(this._offset1.p0);
		}
	},
	createSquare: function (p) {
		this._segList.addPt(new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](p.x + this._distance, p.y + this._distance));
		this._segList.addPt(new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](p.x + this._distance, p.y - this._distance));
		this._segList.addPt(new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](p.x - this._distance, p.y - this._distance));
		this._segList.addPt(new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](p.x - this._distance, p.y + this._distance));
		this._segList.closeRing();
	},
	addSegments: function (pt, isForward) {
		this._segList.addPts(pt, isForward);
	},
	addFirstSegment: function () {
		this._segList.addPt(this._offset1.p0);
	},
	addLastSegment: function () {
		this._segList.addPt(this._offset1.p1);
	},
	initSideSegments: function (s1, s2, side) {
		this._s1 = s1;
		this._s2 = s2;
		this._side = side;
		this._seg1.setCoordinates(s1, s2);
		this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
	},
	addLimitedMitreJoin: function (offset0, offset1, distance, mitreLimit) {
		var basePt = this._seg0.p1;
		var ang0 = __WEBPACK_IMPORTED_MODULE_8__algorithm_Angle__["a" /* default */].angle(basePt, this._seg0.p0);
		var ang1 = __WEBPACK_IMPORTED_MODULE_8__algorithm_Angle__["a" /* default */].angle(basePt, this._seg1.p1);
		var angDiff = __WEBPACK_IMPORTED_MODULE_8__algorithm_Angle__["a" /* default */].angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
		var angDiffHalf = angDiff / 2;
		var midAng = __WEBPACK_IMPORTED_MODULE_8__algorithm_Angle__["a" /* default */].normalize(ang0 + angDiffHalf);
		var mitreMidAng = __WEBPACK_IMPORTED_MODULE_8__algorithm_Angle__["a" /* default */].normalize(midAng + Math.PI);
		var mitreDist = mitreLimit * distance;
		var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
		var bevelHalfLen = distance - bevelDelta;
		var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
		var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
		var bevelMidPt = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](bevelMidX, bevelMidY);
		var mitreMidLine = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */](basePt, bevelMidPt);
		var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
		var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
		if (this._side === __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].LEFT) {
			this._segList.addPt(bevelEndLeft);
			this._segList.addPt(bevelEndRight);
		} else {
			this._segList.addPt(bevelEndRight);
			this._segList.addPt(bevelEndLeft);
		}
	},
	computeOffsetSegment: function (seg, side, distance, offset) {
		var sideSign = side === __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].LEFT ? 1 : -1;
		var dx = seg.p1.x - seg.p0.x;
		var dy = seg.p1.y - seg.p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = sideSign * distance * dx / len;
		var uy = sideSign * distance * dy / len;
		offset.p0.x = seg.p0.x - uy;
		offset.p0.y = seg.p0.y + ux;
		offset.p1.x = seg.p1.x - uy;
		offset.p1.y = seg.p1.y + ux;
	},
	addFilletArc: function (p, startAngle, endAngle, direction, radius) {
		var directionFactor = direction === __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE ? -1 : 1;
		var totalAngle = Math.abs(startAngle - endAngle);
		var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
		if (nSegs < 1) return null;
		var initAngle = null, currAngleInc = null;
		initAngle = 0.0;
		currAngleInc = totalAngle / nSegs;
		var currAngle = initAngle;
		var pt = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */]();
		while (currAngle < totalAngle) {
			var angle = startAngle + directionFactor * currAngle;
			pt.x = p.x + radius * Math.cos(angle);
			pt.y = p.y + radius * Math.sin(angle);
			this._segList.addPt(pt);
			currAngle += currAngleInc;
		}
	},
	addInsideTurn: function (orientation, addStartPoint) {
		this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
		if (this._li.hasIntersection()) {
			this._segList.addPt(this._li.getIntersection(0));
		} else {
			this._hasNarrowConcaveAngle = true;
			if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
				this._segList.addPt(this._offset0.p1);
			} else {
				this._segList.addPt(this._offset0.p1);
				if (this._closingSegLengthFactor > 0) {
					var mid0 = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */]((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
					this._segList.addPt(mid0);
					var mid1 = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */]((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
					this._segList.addPt(mid1);
				} else {
					this._segList.addPt(this._s1);
				}
				this._segList.addPt(this._offset1.p0);
			}
		}
	},
	createCircle: function (p) {
		var pt = new __WEBPACK_IMPORTED_MODULE_4__geom_Coordinate__["a" /* default */](p.x + this._distance, p.y);
		this._segList.addPt(pt);
		this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);
		this._segList.closeRing();
	},
	addBevelJoin: function (offset0, offset1) {
		this._segList.addPt(offset0.p1);
		this._segList.addPt(offset1.p0);
	},
	init: function (distance) {
		this._distance = distance;
		this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
		this._segList = new __WEBPACK_IMPORTED_MODULE_6__OffsetSegmentString__["a" /* default */]();
		this._segList.setPrecisionModel(this._precisionModel);
		this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
	},
	addCollinear: function (addStartPoint) {
		this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
		var numInt = this._li.getIntersectionNum();
		if (numInt >= 2) {
			if (this._bufParams.getJoinStyle() === __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].JOIN_BEVEL || this._bufParams.getJoinStyle() === __WEBPACK_IMPORTED_MODULE_0__BufferParameters__["a" /* default */].JOIN_MITRE) {
				if (addStartPoint) this._segList.addPt(this._offset0.p1);
				this._segList.addPt(this._offset1.p0);
			} else {
				this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].CLOCKWISE, this._distance);
			}
		}
	},
	closeRing: function () {
		this._segList.closeRing();
	},
	hasNarrowConcaveAngle: function () {
		return this._hasNarrowConcaveAngle;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return OffsetSegmentGenerator;
	}
});
OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;
OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;
OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;
OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;


/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OffsetSegmentString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function OffsetSegmentString() {
	this._ptList = null;
	this._precisionModel = null;
	this._minimimVertexDistance = 0.0;
	this._ptList = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(OffsetSegmentString.prototype, {
	getCoordinates: function () {
		var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
		return coord;
	},
	setPrecisionModel: function (precisionModel) {
		this._precisionModel = precisionModel;
	},
	addPt: function (pt) {
		var bufPt = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](pt);
		this._precisionModel.makePrecise(bufPt);
		if (this.isRedundant(bufPt)) return null;
		this._ptList.add(bufPt);
	},
	reverse: function () {},
	addPts: function (pt, isForward) {
		if (isForward) {
			for (var i = 0; i < pt.length; i++) {
				this.addPt(pt[i]);
			}
		} else {
			for (var i = pt.length - 1; i >= 0; i--) {
				this.addPt(pt[i]);
			}
		}
	},
	isRedundant: function (pt) {
		if (this._ptList.size() < 1) return false;
		var lastPt = this._ptList.get(this._ptList.size() - 1);
		var ptDist = pt.distance(lastPt);
		if (ptDist < this._minimimVertexDistance) return true;
		return false;
	},
	toString: function () {
		var fact = new __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__["a" /* default */]();
		var line = fact.createLineString(this.getCoordinates());
		return line.toString();
	},
	closeRing: function () {
		if (this._ptList.size() < 1) return null;
		var startPt = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](this._ptList.get(0));
		var lastPt = this._ptList.get(this._ptList.size() - 1);
		var last2Pt = null;
		if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);
		if (startPt.equals(lastPt)) return null;
		this._ptList.add(startPt);
	},
	setMinimumVertexDistance: function (minimimVertexDistance) {
		this._minimimVertexDistance = minimimVertexDistance;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return OffsetSegmentString;
	}
});
OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);


/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SubgraphDepthLocater;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geomgraph_DirectedEdge__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_lang_Comparable__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_List__ = __webpack_require__(33);











function SubgraphDepthLocater() {
	this._subgraphs = null;
	this._seg = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */]();
	this._cga = new __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */]();
	let subgraphs = arguments[0];
	this._subgraphs = subgraphs;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(SubgraphDepthLocater.prototype, {
	findStabbedSegments: function () {
		if (arguments.length === 1) {
			let stabbingRayLeftPt = arguments[0];
			var stabbedSegments = new __WEBPACK_IMPORTED_MODULE_9__java_util_ArrayList__["a" /* default */]();
			for (var i = this._subgraphs.iterator(); i.hasNext(); ) {
				var bsg = i.next();
				var env = bsg.getEnvelope();
				if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;
				this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
			}
			return stabbedSegments;
		} else if (arguments.length === 3) {
			if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_10__java_util_List__["a" /* default */]) && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_6__geomgraph_DirectedEdge__["a" /* default */])) {
				let stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2];
				var pts = dirEdge.getEdge().getCoordinates();
				for (var i = 0; i < pts.length - 1; i++) {
					this._seg.p0 = pts[i];
					this._seg.p1 = pts[i + 1];
					if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
					var maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
					if (maxx < stabbingRayLeftPt.x) continue;
					if (this._seg.isHorizontal()) continue;
					if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;
					if (__WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].computeOrientation(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].RIGHT) continue;
					var depth = dirEdge.getDepth(__WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].LEFT);
					if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(__WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].RIGHT);
					var ds = new DepthSegment(this._seg, depth);
					stabbedSegments.add(ds);
				}
			} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_10__java_util_List__["a" /* default */]) && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */] && Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_10__java_util_List__["a" /* default */]))) {
				let stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2];
				for (var i = dirEdges.iterator(); i.hasNext(); ) {
					var de = i.next();
					if (!de.isForward()) continue;
					this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);
				}
			}
		}
	},
	getDepth: function (p) {
		var stabbedSegments = this.findStabbedSegments(p);
		if (stabbedSegments.size() === 0) return 0;
		var ds = __WEBPACK_IMPORTED_MODULE_5__java_util_Collections__["a" /* default */].min(stabbedSegments);
		return ds._leftDepth;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SubgraphDepthLocater;
	}
});
function DepthSegment() {
	this._upwardSeg = null;
	this._leftDepth = null;
	let seg = arguments[0], depth = arguments[1];
	this._upwardSeg = new __WEBPACK_IMPORTED_MODULE_7__geom_LineSegment__["a" /* default */](seg);
	this._leftDepth = depth;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(DepthSegment.prototype, {
	compareTo: function (obj) {
		var other = obj;
		if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;
		if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;
		var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
		if (orientIndex !== 0) return orientIndex;
		orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
		if (orientIndex !== 0) return orientIndex;
		return this._upwardSeg.compareTo(other._upwardSeg);
	},
	compareX: function (seg0, seg1) {
		var compare0 = seg0.p0.compareTo(seg1.p0);
		if (compare0 !== 0) return compare0;
		return seg0.p1.compareTo(seg1.p1);
	},
	toString: function () {
		return this._upwardSeg.toString();
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_8__java_lang_Comparable__["a" /* default */]];
	},
	getClass: function () {
		return DepthSegment;
	}
});
SubgraphDepthLocater.DepthSegment = DepthSegment;


/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = OffsetCurveSetBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__noding_NodedSegmentString__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_MultiPoint__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geomgraph_Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__geom_GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__geom_MultiLineString__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__geom_Triangle__ = __webpack_require__(79);

















function OffsetCurveSetBuilder() {
	this._inputGeom = null;
	this._distance = null;
	this._curveBuilder = null;
	this._curveList = new __WEBPACK_IMPORTED_MODULE_14__java_util_ArrayList__["a" /* default */]();
	let inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2];
	this._inputGeom = inputGeom;
	this._distance = distance;
	this._curveBuilder = curveBuilder;
}
Object(__WEBPACK_IMPORTED_MODULE_9__extend__["a" /* default */])(OffsetCurveSetBuilder.prototype, {
	addPoint: function (p) {
		if (this._distance <= 0.0) return null;
		var coord = p.getCoordinates();
		var curve = this._curveBuilder.getLineCurve(coord, this._distance);
		this.addCurve(curve, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
	},
	addPolygon: function (p) {
		var offsetDistance = this._distance;
		var offsetSide = __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].LEFT;
		if (this._distance < 0.0) {
			offsetDistance = -this._distance;
			offsetSide = __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].RIGHT;
		}
		var shell = p.getExteriorRing();
		var shellCoord = __WEBPACK_IMPORTED_MODULE_13__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(shell.getCoordinates());
		if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;
		if (this._distance <= 0.0 && shellCoord.length < 3) return null;
		this.addPolygonRing(shellCoord, offsetDistance, offsetSide, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			var holeCoord = __WEBPACK_IMPORTED_MODULE_13__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(hole.getCoordinates());
			if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;
			this.addPolygonRing(holeCoord, offsetDistance, __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].opposite(offsetSide), __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR);
		}
	},
	isTriangleErodedCompletely: function (triangleCoord, bufferDistance) {
		var tri = new __WEBPACK_IMPORTED_MODULE_16__geom_Triangle__["a" /* default */](triangleCoord[0], triangleCoord[1], triangleCoord[2]);
		var inCentre = tri.inCentre();
		var distToCentre = __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].distancePointLine(inCentre, tri.p0, tri.p1);
		return distToCentre < Math.abs(bufferDistance);
	},
	addLineString: function (line) {
		if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;
		var coord = __WEBPACK_IMPORTED_MODULE_13__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(line.getCoordinates());
		var curve = this._curveBuilder.getLineCurve(coord, this._distance);
		this.addCurve(curve, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
	},
	addCurve: function (coord, leftLoc, rightLoc) {
		if (coord === null || coord.length < 2) return null;
		var e = new __WEBPACK_IMPORTED_MODULE_5__noding_NodedSegmentString__["a" /* default */](coord, new __WEBPACK_IMPORTED_MODULE_11__geomgraph_Label__["a" /* default */](0, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY, leftLoc, rightLoc));
		this._curveList.add(e);
	},
	getCurves: function () {
		this.add(this._inputGeom);
		return this._curveList;
	},
	addPolygonRing: function (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
		if (offsetDistance === 0.0 && coord.length < __WEBPACK_IMPORTED_MODULE_8__geom_LinearRing__["a" /* default */].MINIMUM_VALID_SIZE) return null;
		var leftLoc = cwLeftLoc;
		var rightLoc = cwRightLoc;
		if (coord.length >= __WEBPACK_IMPORTED_MODULE_8__geom_LinearRing__["a" /* default */].MINIMUM_VALID_SIZE && __WEBPACK_IMPORTED_MODULE_2__algorithm_CGAlgorithms__["a" /* default */].isCCW(coord)) {
			leftLoc = cwRightLoc;
			rightLoc = cwLeftLoc;
			side = __WEBPACK_IMPORTED_MODULE_3__geomgraph_Position__["a" /* default */].opposite(side);
		}
		var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
		this.addCurve(curve, leftLoc, rightLoc);
	},
	add: function (g) {
		if (g.isEmpty()) return null;
		if (g instanceof __WEBPACK_IMPORTED_MODULE_6__geom_Polygon__["a" /* default */]) this.addPolygon(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineString__["a" /* default */]) this.addLineString(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_4__geom_Point__["a" /* default */]) this.addPoint(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_7__geom_MultiPoint__["a" /* default */]) this.addCollection(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_15__geom_MultiLineString__["a" /* default */]) this.addCollection(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_10__geom_MultiPolygon__["a" /* default */]) this.addCollection(g); else if (g instanceof __WEBPACK_IMPORTED_MODULE_12__geom_GeometryCollection__["a" /* default */]) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());
	},
	isErodedCompletely: function (ring, bufferDistance) {
		var ringCoord = ring.getCoordinates();
		var minDiam = 0.0;
		if (ringCoord.length < 4) return bufferDistance < 0;
		if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
		var env = ring.getEnvelopeInternal();
		var envMinDimension = Math.min(env.getHeight(), env.getWidth());
		if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;
		return false;
	},
	addCollection: function (gc) {
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = gc.getGeometryN(i);
			this.add(g);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return OffsetCurveSetBuilder;
	}
});


/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IntersectionAdder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SegmentIntersector__ = __webpack_require__(97);


function IntersectionAdder() {
	this._hasIntersection = false;
	this._hasProper = false;
	this._hasProperInterior = false;
	this._hasInterior = false;
	this._properIntersectionPoint = null;
	this._li = null;
	this._isSelfIntersection = null;
	this.numIntersections = 0;
	this.numInteriorIntersections = 0;
	this.numProperIntersections = 0;
	this.numTests = 0;
	let li = arguments[0];
	this._li = li;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(IntersectionAdder.prototype, {
	isTrivialIntersection: function (e0, segIndex0, e1, segIndex1) {
		if (e0 === e1) {
			if (this._li.getIntersectionNum() === 1) {
				if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;
				if (e0.isClosed()) {
					var maxSegIndex = e0.size() - 1;
					if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
						return true;
					}
				}
			}
		}
		return false;
	},
	getProperIntersectionPoint: function () {
		return this._properIntersectionPoint;
	},
	hasProperInteriorIntersection: function () {
		return this._hasProperInterior;
	},
	getLineIntersector: function () {
		return this._li;
	},
	hasProperIntersection: function () {
		return this._hasProper;
	},
	processIntersections: function (e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		this.numTests++;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			this.numIntersections++;
			if (this._li.isInteriorIntersection()) {
				this.numInteriorIntersections++;
				this._hasInterior = true;
			}
			if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
				this._hasIntersection = true;
				e0.addIntersections(this._li, segIndex0, 0);
				e1.addIntersections(this._li, segIndex1, 1);
				if (this._li.isProper()) {
					this.numProperIntersections++;
					this._hasProper = true;
					this._hasProperInterior = true;
				}
			}
		}
	},
	hasIntersection: function () {
		return this._hasIntersection;
	},
	isDone: function () {
		return false;
	},
	hasInteriorIntersection: function () {
		return this._hasInterior;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__SegmentIntersector__["a" /* default */]];
	},
	getClass: function () {
		return IntersectionAdder;
	}
});
IntersectionAdder.isAdjacentSegments = function (i1, i2) {
	return Math.abs(i1 - i2) === 1;
};


/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MCIndexSnapRounder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NodingValidator__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Noder__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__MCIndexNoder__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__NodedSegmentString__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__HotPixel__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_lang_Exception__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__MCIndexPointSnapper__ = __webpack_require__(313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__InteriorIntersectionFinderAdder__ = __webpack_require__(314);












function MCIndexSnapRounder() {
	this._pm = null;
	this._li = null;
	this._scaleFactor = null;
	this._noder = null;
	this._pointSnapper = null;
	this._nodedSegStrings = null;
	let pm = arguments[0];
	this._pm = pm;
	this._li = new __WEBPACK_IMPORTED_MODULE_10__algorithm_RobustLineIntersector__["a" /* default */]();
	this._li.setPrecisionModel(pm);
	this._scaleFactor = pm.getScale();
}
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(MCIndexSnapRounder.prototype, {
	checkCorrectness: function (inputSegmentStrings) {
		var resultSegStrings = __WEBPACK_IMPORTED_MODULE_5__NodedSegmentString__["a" /* default */].getNodedSubstrings(inputSegmentStrings);
		var nv = new __WEBPACK_IMPORTED_MODULE_0__NodingValidator__["a" /* default */](resultSegStrings);
		try {
			nv.checkValid();
		} catch (ex) {
			if (ex instanceof __WEBPACK_IMPORTED_MODULE_8__java_lang_Exception__["a" /* default */]) {
				ex.printStackTrace();
			} else throw ex;
		} finally {}
	},
	getNodedSubstrings: function () {
		return __WEBPACK_IMPORTED_MODULE_5__NodedSegmentString__["a" /* default */].getNodedSubstrings(this._nodedSegStrings);
	},
	snapRound: function (segStrings, li) {
		var intersections = this.findInteriorIntersections(segStrings, li);
		this.computeIntersectionSnaps(intersections);
		this.computeVertexSnaps(segStrings);
	},
	findInteriorIntersections: function (segStrings, li) {
		var intFinderAdder = new __WEBPACK_IMPORTED_MODULE_11__InteriorIntersectionFinderAdder__["a" /* default */](li);
		this._noder.setSegmentIntersector(intFinderAdder);
		this._noder.computeNodes(segStrings);
		return intFinderAdder.getInteriorIntersections();
	},
	computeVertexSnaps: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_2__java_util_Collection__["a" /* default */])) {
			let edges = arguments[0];
			for (var i0 = edges.iterator(); i0.hasNext(); ) {
				var edge0 = i0.next();
				this.computeVertexSnaps(edge0);
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__NodedSegmentString__["a" /* default */]) {
			let e = arguments[0];
			var pts0 = e.getCoordinates();
			for (var i = 0; i < pts0.length; i++) {
				var hotPixel = new __WEBPACK_IMPORTED_MODULE_6__HotPixel__["a" /* default */](pts0[i], this._scaleFactor, this._li);
				var isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
				if (isNodeAdded) {
					e.addIntersection(pts0[i], i);
				}
			}
		}
	},
	computeNodes: function (inputSegmentStrings) {
		this._nodedSegStrings = inputSegmentStrings;
		this._noder = new __WEBPACK_IMPORTED_MODULE_4__MCIndexNoder__["a" /* default */]();
		this._pointSnapper = new __WEBPACK_IMPORTED_MODULE_9__MCIndexPointSnapper__["a" /* default */](this._noder.getIndex());
		this.snapRound(inputSegmentStrings, this._li);
	},
	computeIntersectionSnaps: function (snapPts) {
		for (var it = snapPts.iterator(); it.hasNext(); ) {
			var snapPt = it.next();
			var hotPixel = new __WEBPACK_IMPORTED_MODULE_6__HotPixel__["a" /* default */](snapPt, this._scaleFactor, this._li);
			this._pointSnapper.snap(hotPixel);
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__Noder__["a" /* default */]];
	},
	getClass: function () {
		return MCIndexSnapRounder;
	}
});


/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodingValidator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_lang_RuntimeException__ = __webpack_require__(44);




function NodingValidator() {
	this._li = new __WEBPACK_IMPORTED_MODULE_2__algorithm_RobustLineIntersector__["a" /* default */]();
	this._segStrings = null;
	let segStrings = arguments[0];
	this._segStrings = segStrings;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(NodingValidator.prototype, {
	checkEndPtVertexIntersections: function () {
		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext(); ) {
				var ss = i.next();
				var pts = ss.getCoordinates();
				this.checkEndPtVertexIntersections(pts[0], this._segStrings);
				this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
			}
		} else if (arguments.length === 2) {
			let testPt = arguments[0], segStrings = arguments[1];
			for (var i = segStrings.iterator(); i.hasNext(); ) {
				var ss = i.next();
				var pts = ss.getCoordinates();
				for (var j = 1; j < pts.length - 1; j++) {
					if (pts[j].equals(testPt)) throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_RuntimeException__["a" /* default */]("found endpt/interior pt intersection at index " + j + " :pt " + testPt);
				}
			}
		}
	},
	checkInteriorIntersections: function () {
		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext(); ) {
				var ss0 = i.next();
				for (var j = this._segStrings.iterator(); j.hasNext(); ) {
					var ss1 = j.next();
					this.checkInteriorIntersections(ss0, ss1);
				}
			}
		} else if (arguments.length === 2) {
			let ss0 = arguments[0], ss1 = arguments[1];
			var pts0 = ss0.getCoordinates();
			var pts1 = ss1.getCoordinates();
			for (var i0 = 0; i0 < pts0.length - 1; i0++) {
				for (var i1 = 0; i1 < pts1.length - 1; i1++) {
					this.checkInteriorIntersections(ss0, i0, ss1, i1);
				}
			}
		} else if (arguments.length === 4) {
			let e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3];
			if (e0 === e1 && segIndex0 === segIndex1) return null;
			var p00 = e0.getCoordinates()[segIndex0];
			var p01 = e0.getCoordinates()[segIndex0 + 1];
			var p10 = e1.getCoordinates()[segIndex1];
			var p11 = e1.getCoordinates()[segIndex1 + 1];
			this._li.computeIntersection(p00, p01, p10, p11);
			if (this._li.hasIntersection()) {
				if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
					throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_RuntimeException__["a" /* default */]("found non-noded intersection at " + p00 + "-" + p01 + " and " + p10 + "-" + p11);
				}
			}
		}
	},
	checkValid: function () {
		this.checkEndPtVertexIntersections();
		this.checkInteriorIntersections();
		this.checkCollapses();
	},
	checkCollapses: function () {
		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext(); ) {
				var ss = i.next();
				this.checkCollapses(ss);
			}
		} else if (arguments.length === 1) {
			let ss = arguments[0];
			var pts = ss.getCoordinates();
			for (var i = 0; i < pts.length - 2; i++) {
				this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);
			}
		}
	},
	hasInteriorIntersection: function (li, p0, p1) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			var intPt = li.getIntersection(i);
			if (!(intPt.equals(p0) || intPt.equals(p1))) return true;
		}
		return false;
	},
	checkCollapse: function (p0, p1, p2) {
		if (p0.equals(p2)) throw new __WEBPACK_IMPORTED_MODULE_3__java_lang_RuntimeException__["a" /* default */]("found non-noded collapse at " + NodingValidator.fact.createLineString([p0, p1, p2]));
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NodingValidator;
	}
});
NodingValidator.fact = new __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__["a" /* default */]();


/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = HotPixel;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);





function HotPixel() {
	this._li = null;
	this._pt = null;
	this._originalPt = null;
	this._ptScaled = null;
	this._p0Scaled = null;
	this._p1Scaled = null;
	this._scaleFactor = null;
	this._minx = null;
	this._maxx = null;
	this._miny = null;
	this._maxy = null;
	this._corner = new Array(4).fill(null);
	this._safeEnv = null;
	let pt = arguments[0], scaleFactor = arguments[1], li = arguments[2];
	this._originalPt = pt;
	this._pt = pt;
	this._scaleFactor = scaleFactor;
	this._li = li;
	if (scaleFactor <= 0) throw new __WEBPACK_IMPORTED_MODULE_1__java_lang_IllegalArgumentException__["a" /* default */]("Scale factor must be non-zero");
	if (scaleFactor !== 1.0) {
		this._pt = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](this.scale(pt.x), this.scale(pt.y));
		this._p0Scaled = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
		this._p1Scaled = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
	}
	this.initCorners(this._pt);
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(HotPixel.prototype, {
	intersectsScaled: function (p0, p1) {
		var segMinx = Math.min(p0.x, p1.x);
		var segMaxx = Math.max(p0.x, p1.x);
		var segMiny = Math.min(p0.y, p1.y);
		var segMaxy = Math.max(p0.y, p1.y);
		var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
		if (isOutsidePixelEnv) return false;
		var intersects = this.intersectsToleranceSquare(p0, p1);
		__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(!(isOutsidePixelEnv && intersects), "Found bad envelope test");
		return intersects;
	},
	initCorners: function (pt) {
		var tolerance = 0.5;
		this._minx = pt.x - tolerance;
		this._maxx = pt.x + tolerance;
		this._miny = pt.y - tolerance;
		this._maxy = pt.y + tolerance;
		this._corner[0] = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](this._maxx, this._maxy);
		this._corner[1] = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](this._minx, this._maxy);
		this._corner[2] = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](this._minx, this._miny);
		this._corner[3] = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](this._maxx, this._miny);
	},
	intersects: function (p0, p1) {
		if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);
		this.copyScaled(p0, this._p0Scaled);
		this.copyScaled(p1, this._p1Scaled);
		return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
	},
	scale: function (val) {
		return Math.round(val * this._scaleFactor);
	},
	getCoordinate: function () {
		return this._originalPt;
	},
	copyScaled: function (p, pScaled) {
		pScaled.x = this.scale(p.x);
		pScaled.y = this.scale(p.y);
	},
	getSafeEnvelope: function () {
		if (this._safeEnv === null) {
			var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
			this._safeEnv = new __WEBPACK_IMPORTED_MODULE_3__geom_Envelope__["a" /* default */](this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
		}
		return this._safeEnv;
	},
	intersectsPixelClosure: function (p0, p1) {
		this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
		if (this._li.hasIntersection()) return true;
		this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
		if (this._li.hasIntersection()) return true;
		this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
		if (this._li.hasIntersection()) return true;
		this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
		if (this._li.hasIntersection()) return true;
		return false;
	},
	intersectsToleranceSquare: function (p0, p1) {
		var intersectsLeft = false;
		var intersectsBottom = false;
		this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
		if (this._li.isProper()) return true;
		this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
		if (this._li.isProper()) return true;
		if (this._li.hasIntersection()) intersectsLeft = true;
		this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
		if (this._li.isProper()) return true;
		if (this._li.hasIntersection()) intersectsBottom = true;
		this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
		if (this._li.isProper()) return true;
		if (intersectsLeft && intersectsBottom) return true;
		if (p0.equals(this._pt)) return true;
		if (p1.equals(this._pt)) return true;
		return false;
	},
	addSnappedNode: function (segStr, segIndex) {
		var p0 = segStr.getCoordinate(segIndex);
		var p1 = segStr.getCoordinate(segIndex + 1);
		if (this.intersects(p0, p1)) {
			segStr.addIntersection(this.getCoordinate(), segIndex);
			return true;
		}
		return false;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return HotPixel;
	}
});
HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;


/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = MCIndexPointSnapper;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_ItemVisitor__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);




function MCIndexPointSnapper() {
	this._index = null;
	let index = arguments[0];
	this._index = index;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(MCIndexPointSnapper.prototype, {
	snap: function () {
		if (arguments.length === 1) {
			let hotPixel = arguments[0];
			return this.snap(hotPixel, null, -1);
		} else if (arguments.length === 3) {
			let hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];
			var pixelEnv = hotPixel.getSafeEnvelope();
			var hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);
			this._index.query(pixelEnv, {
				interfaces_: function () {
					return [__WEBPACK_IMPORTED_MODULE_1__index_ItemVisitor__["a" /* default */]];
				},
				visitItem: function (item) {
					var testChain = item;
					testChain.select(pixelEnv, hotPixelSnapAction);
				}
			});
			return hotPixelSnapAction.isNodeAdded();
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return MCIndexPointSnapper;
	}
});
function HotPixelSnapAction() {
	__WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__["a" /* default */].apply(this);
	this._hotPixel = null;
	this._parentEdge = null;
	this._hotPixelVertexIndex = null;
	this._isNodeAdded = false;
	let hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];
	this._hotPixel = hotPixel;
	this._parentEdge = parentEdge;
	this._hotPixelVertexIndex = hotPixelVertexIndex;
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(HotPixelSnapAction, __WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(HotPixelSnapAction.prototype, {
	isNodeAdded: function () {
		return this._isNodeAdded;
	},
	select: function () {
		if (arguments.length === 2) {
			let mc = arguments[0], startIndex = arguments[1];
			var ss = mc.getContext();
			if (this._parentEdge !== null) {
				if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;
			}
			this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
		} else return __WEBPACK_IMPORTED_MODULE_0__index_chain_MonotoneChainSelectAction__["a" /* default */].prototype.select.apply(this, arguments);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return HotPixelSnapAction;
	}
});
MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;


/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = InteriorIntersectionFinderAdder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SegmentIntersector__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);



function InteriorIntersectionFinderAdder() {
	this._li = null;
	this._interiorIntersections = null;
	let li = arguments[0];
	this._li = li;
	this._interiorIntersections = new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(InteriorIntersectionFinderAdder.prototype, {
	processIntersections: function (e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._li.isInteriorIntersection()) {
				for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
					this._interiorIntersections.add(this._li.getIntersection(intIndex));
				}
				e0.addIntersections(this._li, segIndex0, 0);
				e1.addIntersections(this._li, segIndex1, 1);
			}
		}
	},
	isDone: function () {
		return false;
	},
	getInteriorIntersections: function () {
		return this._interiorIntersections;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_1__SegmentIntersector__["a" /* default */]];
	},
	getClass: function () {
		return InteriorIntersectionFinderAdder;
	}
});


/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__distance_DistanceOp__ = __webpack_require__(316);
/* unused harmony reexport DistanceOp */





/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_util_PolygonExtracter__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geom_util_PointExtracter__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ConnectedElementLocationFilter__ = __webpack_require__(318);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__geom_util_LinearComponentExtracter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__java_util_List__ = __webpack_require__(33);

















function DistanceOp() {
	this._geom = null;
	this._terminateDistance = 0.0;
	this._ptLocator = new __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__["a" /* default */]();
	this._minDistanceLocation = null;
	this._minDistance = __WEBPACK_IMPORTED_MODULE_10__java_lang_Double__["a" /* default */].MAX_VALUE;
	if (arguments.length === 2) {
		let g0 = arguments[0], g1 = arguments[1];
		DistanceOp.call(this, g0, g1, 0.0);
	} else if (arguments.length === 3) {
		let g0 = arguments[0], g1 = arguments[1], terminateDistance = arguments[2];
		this._geom = new Array(2).fill(null);
		this._geom[0] = g0;
		this._geom[1] = g1;
		this._terminateDistance = terminateDistance;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_12__extend__["a" /* default */])(DistanceOp.prototype, {
	computeContainmentDistance: function () {
		if (arguments.length === 0) {
			var locPtPoly = new Array(2).fill(null);
			this.computeContainmentDistance(0, locPtPoly);
			if (this._minDistance <= this._terminateDistance) return null;
			this.computeContainmentDistance(1, locPtPoly);
		} else if (arguments.length === 2) {
			let polyGeomIndex = arguments[0], locPtPoly = arguments[1];
			var locationsIndex = 1 - polyGeomIndex;
			var polys = __WEBPACK_IMPORTED_MODULE_1__geom_util_PolygonExtracter__["a" /* default */].getPolygons(this._geom[polyGeomIndex]);
			if (polys.size() > 0) {
				var insideLocs = __WEBPACK_IMPORTED_MODULE_13__ConnectedElementLocationFilter__["a" /* default */].getLocations(this._geom[locationsIndex]);
				this.computeContainmentDistance(insideLocs, polys, locPtPoly);
				if (this._minDistance <= this._terminateDistance) {
					this._minDistanceLocation[locationsIndex] = locPtPoly[0];
					this._minDistanceLocation[polyGeomIndex] = locPtPoly[1];
					return null;
				}
			}
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof Array && (Object(__WEBPACK_IMPORTED_MODULE_5__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_16__java_util_List__["a" /* default */]) && Object(__WEBPACK_IMPORTED_MODULE_5__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_16__java_util_List__["a" /* default */]))) {
				let locs = arguments[0], polys = arguments[1], locPtPoly = arguments[2];
				for (var i = 0; i < locs.size(); i++) {
					var loc = locs.get(i);
					for (var j = 0; j < polys.size(); j++) {
						this.computeContainmentDistance(loc, polys.get(j), locPtPoly);
						if (this._minDistance <= this._terminateDistance) return null;
					}
				}
			} else if (arguments[2] instanceof Array && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_8__geom_Polygon__["a" /* default */])) {
				let ptLoc = arguments[0], poly = arguments[1], locPtPoly = arguments[2];
				var pt = ptLoc.getCoordinate();
				if (__WEBPACK_IMPORTED_MODULE_2__geom_Location__["a" /* default */].EXTERIOR !== this._ptLocator.locate(pt, poly)) {
					this._minDistance = 0.0;
					locPtPoly[0] = ptLoc;
					locPtPoly[1] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](poly, pt);
					;
					return null;
				}
			}
		}
	},
	computeMinDistanceLinesPoints: function (lines, points, locGeom) {
		for (var i = 0; i < lines.size(); i++) {
			var line = lines.get(i);
			for (var j = 0; j < points.size(); j++) {
				var pt = points.get(j);
				this.computeMinDistance(line, pt, locGeom);
				if (this._minDistance <= this._terminateDistance) return null;
			}
		}
	},
	computeFacetDistance: function () {
		var locGeom = new Array(2).fill(null);
		var lines0 = __WEBPACK_IMPORTED_MODULE_15__geom_util_LinearComponentExtracter__["a" /* default */].getLines(this._geom[0]);
		var lines1 = __WEBPACK_IMPORTED_MODULE_15__geom_util_LinearComponentExtracter__["a" /* default */].getLines(this._geom[1]);
		var pts0 = __WEBPACK_IMPORTED_MODULE_11__geom_util_PointExtracter__["a" /* default */].getPoints(this._geom[0]);
		var pts1 = __WEBPACK_IMPORTED_MODULE_11__geom_util_PointExtracter__["a" /* default */].getPoints(this._geom[1]);
		this.computeMinDistanceLines(lines0, lines1, locGeom);
		this.updateMinDistance(locGeom, false);
		if (this._minDistance <= this._terminateDistance) return null;
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
		this.updateMinDistance(locGeom, false);
		if (this._minDistance <= this._terminateDistance) return null;
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
		this.updateMinDistance(locGeom, true);
		if (this._minDistance <= this._terminateDistance) return null;
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistancePoints(pts0, pts1, locGeom);
		this.updateMinDistance(locGeom, false);
	},
	nearestLocations: function () {
		this.computeMinDistance();
		return this._minDistanceLocation;
	},
	updateMinDistance: function (locGeom, flip) {
		if (locGeom[0] === null) return null;
		if (flip) {
			this._minDistanceLocation[0] = locGeom[1];
			this._minDistanceLocation[1] = locGeom[0];
		} else {
			this._minDistanceLocation[0] = locGeom[0];
			this._minDistanceLocation[1] = locGeom[1];
		}
	},
	nearestPoints: function () {
		this.computeMinDistance();
		var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
		return nearestPts;
	},
	computeMinDistance: function () {
		if (arguments.length === 0) {
			if (this._minDistanceLocation !== null) return null;
			this._minDistanceLocation = new Array(2).fill(null);
			this.computeContainmentDistance();
			if (this._minDistance <= this._terminateDistance) return null;
			this.computeFacetDistance();
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof Array && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_LineString__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_7__geom_Point__["a" /* default */])) {
				let line = arguments[0], pt = arguments[1], locGeom = arguments[2];
				if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;
				var coord0 = line.getCoordinates();
				var coord = pt.getCoordinate();
				for (var i = 0; i < coord0.length - 1; i++) {
					var dist = __WEBPACK_IMPORTED_MODULE_4__algorithm_CGAlgorithms__["a" /* default */].distancePointLine(coord, coord0[i], coord0[i + 1]);
					if (dist < this._minDistance) {
						this._minDistance = dist;
						var seg = new __WEBPACK_IMPORTED_MODULE_14__geom_LineSegment__["a" /* default */](coord0[i], coord0[i + 1]);
						var segClosestPoint = seg.closestPoint(coord);
						locGeom[0] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](line, i, segClosestPoint);
						locGeom[1] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](pt, 0, coord);
					}
					if (this._minDistance <= this._terminateDistance) return null;
				}
			} else if (arguments[2] instanceof Array && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_LineString__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_LineString__["a" /* default */])) {
				let line0 = arguments[0], line1 = arguments[1], locGeom = arguments[2];
				if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;
				var coord0 = line0.getCoordinates();
				var coord1 = line1.getCoordinates();
				for (var i = 0; i < coord0.length - 1; i++) {
					for (var j = 0; j < coord1.length - 1; j++) {
						var dist = __WEBPACK_IMPORTED_MODULE_4__algorithm_CGAlgorithms__["a" /* default */].distanceLineLine(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);
						if (dist < this._minDistance) {
							this._minDistance = dist;
							var seg0 = new __WEBPACK_IMPORTED_MODULE_14__geom_LineSegment__["a" /* default */](coord0[i], coord0[i + 1]);
							var seg1 = new __WEBPACK_IMPORTED_MODULE_14__geom_LineSegment__["a" /* default */](coord1[j], coord1[j + 1]);
							var closestPt = seg0.closestPoints(seg1);
							locGeom[0] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](line0, i, closestPt[0]);
							locGeom[1] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](line1, j, closestPt[1]);
						}
						if (this._minDistance <= this._terminateDistance) return null;
					}
				}
			}
		}
	},
	computeMinDistancePoints: function (points0, points1, locGeom) {
		for (var i = 0; i < points0.size(); i++) {
			var pt0 = points0.get(i);
			for (var j = 0; j < points1.size(); j++) {
				var pt1 = points1.get(j);
				var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
				if (dist < this._minDistance) {
					this._minDistance = dist;
					locGeom[0] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](pt0, 0, pt0.getCoordinate());
					locGeom[1] = new __WEBPACK_IMPORTED_MODULE_9__GeometryLocation__["a" /* default */](pt1, 0, pt1.getCoordinate());
				}
				if (this._minDistance <= this._terminateDistance) return null;
			}
		}
	},
	distance: function () {
		if (this._geom[0] === null || this._geom[1] === null) throw new __WEBPACK_IMPORTED_MODULE_6__java_lang_IllegalArgumentException__["a" /* default */]("null geometries are not supported");
		if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;
		this.computeMinDistance();
		return this._minDistance;
	},
	computeMinDistanceLines: function (lines0, lines1, locGeom) {
		for (var i = 0; i < lines0.size(); i++) {
			var line0 = lines0.get(i);
			for (var j = 0; j < lines1.size(); j++) {
				var line1 = lines1.get(j);
				this.computeMinDistance(line0, line1, locGeom);
				if (this._minDistance <= this._terminateDistance) return null;
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DistanceOp;
	}
});
DistanceOp.distance = function (g0, g1) {
	var distOp = new DistanceOp(g0, g1);
	return distOp.distance();
};
DistanceOp.isWithinDistance = function (g0, g1, distance) {
	var distOp = new DistanceOp(g0, g1, distance);
	return distOp.distance() <= distance;
};
DistanceOp.nearestPoints = function (g0, g1) {
	var distOp = new DistanceOp(g0, g1);
	return distOp.nearestPoints();
};


/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PointExtracter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__GeometryFilter__ = __webpack_require__(39);






function PointExtracter() {
	this._pts = null;
	let pts = arguments[0];
	this._pts = pts;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(PointExtracter.prototype, {
	filter: function (geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__Point__["a" /* default */]) this._pts.add(geom);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_5__GeometryFilter__["a" /* default */]];
	},
	getClass: function () {
		return PointExtracter;
	}
});
PointExtracter.getPoints = function () {
	if (arguments.length === 1) {
		let geom = arguments[0];
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__Point__["a" /* default */]) {
			return __WEBPACK_IMPORTED_MODULE_2__java_util_Collections__["a" /* default */].singletonList(geom);
		}
		return PointExtracter.getPoints(geom, new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]());
	} else if (arguments.length === 2) {
		let geom = arguments[0], list = arguments[1];
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__Point__["a" /* default */]) {
			list.add(geom);
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_3__GeometryCollection__["a" /* default */]) {
			geom.apply(new PointExtracter(list));
		}
		return list;
	}
};


/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConnectedElementLocationFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__GeometryLocation__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_GeometryFilter__ = __webpack_require__(39);







function ConnectedElementLocationFilter() {
	this._locations = null;
	let locations = arguments[0];
	this._locations = locations;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(ConnectedElementLocationFilter.prototype, {
	filter: function (geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Point__["a" /* default */] || geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */] || geom instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Polygon__["a" /* default */]) this._locations.add(new __WEBPACK_IMPORTED_MODULE_3__GeometryLocation__["a" /* default */](geom, 0, geom.getCoordinate()));
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__geom_GeometryFilter__["a" /* default */]];
	},
	getClass: function () {
		return ConnectedElementLocationFilter;
	}
});
ConnectedElementLocationFilter.getLocations = function (geom) {
	var locations = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
	geom.apply(new ConnectedElementLocationFilter(locations));
	return locations;
};


/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__linemerge_LineMerger__ = __webpack_require__(320);
/* unused harmony reexport LineMerger */





/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EdgeString__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__LineMergeGraph__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__planargraph_GraphComponent__ = __webpack_require__(81);











function LineMerger() {
	this._graph = new __WEBPACK_IMPORTED_MODULE_6__LineMergeGraph__["a" /* default */]();
	this._mergedLineStrings = null;
	this._factory = null;
	this._edgeStrings = null;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(LineMerger.prototype, {
	buildEdgeStringsForUnprocessedNodes: function () {
		for (var i = this._graph.getNodes().iterator(); i.hasNext(); ) {
			var node = i.next();
			if (!node.isMarked()) {
				__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(node.getDegree() === 2);
				this.buildEdgeStringsStartingAt(node);
				node.setMarked(true);
			}
		}
	},
	buildEdgeStringsForNonDegree2Nodes: function () {
		for (var i = this._graph.getNodes().iterator(); i.hasNext(); ) {
			var node = i.next();
			if (node.getDegree() !== 2) {
				this.buildEdgeStringsStartingAt(node);
				node.setMarked(true);
			}
		}
	},
	buildEdgeStringsForObviousStartNodes: function () {
		this.buildEdgeStringsForNonDegree2Nodes();
	},
	getMergedLineStrings: function () {
		this.merge();
		return this._mergedLineStrings;
	},
	buildEdgeStringsStartingAt: function (node) {
		for (var i = node.getOutEdges().iterator(); i.hasNext(); ) {
			var directedEdge = i.next();
			if (directedEdge.getEdge().isMarked()) {
				continue;
			}
			this._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));
		}
	},
	merge: function () {
		if (this._mergedLineStrings !== null) {
			return null;
		}
		__WEBPACK_IMPORTED_MODULE_10__planargraph_GraphComponent__["a" /* default */].setMarked(this._graph.nodeIterator(), false);
		__WEBPACK_IMPORTED_MODULE_10__planargraph_GraphComponent__["a" /* default */].setMarked(this._graph.edgeIterator(), false);
		this._edgeStrings = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		this.buildEdgeStringsForObviousStartNodes();
		this.buildEdgeStringsForIsolatedLoops();
		this._mergedLineStrings = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = this._edgeStrings.iterator(); i.hasNext(); ) {
			var edgeString = i.next();
			this._mergedLineStrings.add(edgeString.toLineString());
		}
	},
	buildEdgeStringStartingWith: function (start) {
		var edgeString = new __WEBPACK_IMPORTED_MODULE_4__EdgeString__["a" /* default */](this._factory);
		var current = start;
		do {
			edgeString.add(current);
			current.getEdge().setMarked(true);
			current = current.getNext();
		} while (current !== null && current !== start);
		return edgeString;
	},
	add: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */]) {
			let geometry = arguments[0];
			geometry.apply({
				interfaces_: function () {
					return [__WEBPACK_IMPORTED_MODULE_7__geom_GeometryComponentFilter__["a" /* default */]];
				},
				filter: function (component) {
					if (component instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
						this.add(component);
					}
				}
			});
		} else if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let geometries = arguments[0];
			this._mergedLineStrings = null;
			for (var i = geometries.iterator(); i.hasNext(); ) {
				var geometry = i.next();
				this.add(geometry);
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
			let lineString = arguments[0];
			if (this._factory === null) {
				this._factory = lineString.getFactory();
			}
			this._graph.addEdge(lineString);
		}
	},
	buildEdgeStringsForIsolatedLoops: function () {
		this.buildEdgeStringsForUnprocessedNodes();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineMerger;
	}
});


/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function EdgeString() {
	this._factory = null;
	this._directedEdges = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
	this._coordinates = null;
	let factory = arguments[0];
	this._factory = factory;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(EdgeString.prototype, {
	getCoordinates: function () {
		if (this._coordinates === null) {
			var forwardDirectedEdges = 0;
			var reverseDirectedEdges = 0;
			var coordinateList = new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */]();
			for (var i = this._directedEdges.iterator(); i.hasNext(); ) {
				var directedEdge = i.next();
				if (directedEdge.getEdgeDirection()) {
					forwardDirectedEdges++;
				} else {
					reverseDirectedEdges++;
				}
				coordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());
			}
			this._coordinates = coordinateList.toCoordinateArray();
			if (reverseDirectedEdges > forwardDirectedEdges) {
				__WEBPACK_IMPORTED_MODULE_2__geom_CoordinateArrays__["a" /* default */].reverse(this._coordinates);
			}
		}
		return this._coordinates;
	},
	toLineString: function () {
		return this._factory.createLineString(this.getCoordinates());
	},
	add: function (directedEdge) {
		this._directedEdges.add(directedEdge);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeString;
	}
});


/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineMergeGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LineMergeDirectedEdge__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__planargraph_Node__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LineMergeEdge__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__planargraph_PlanarGraph__ = __webpack_require__(156);







function LineMergeGraph() {
	__WEBPACK_IMPORTED_MODULE_6__planargraph_PlanarGraph__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_5__inherits__["a" /* default */])(LineMergeGraph, __WEBPACK_IMPORTED_MODULE_6__planargraph_PlanarGraph__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LineMergeGraph.prototype, {
	addEdge: function (lineString) {
		if (lineString.isEmpty()) {
			return null;
		}
		var coordinates = __WEBPACK_IMPORTED_MODULE_3__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(lineString.getCoordinates());
		if (coordinates.length <= 1) return null;
		var startCoordinate = coordinates[0];
		var endCoordinate = coordinates[coordinates.length - 1];
		var startNode = this.getNode(startCoordinate);
		var endNode = this.getNode(endCoordinate);
		var directedEdge0 = new __WEBPACK_IMPORTED_MODULE_0__LineMergeDirectedEdge__["a" /* default */](startNode, endNode, coordinates[1], true);
		var directedEdge1 = new __WEBPACK_IMPORTED_MODULE_0__LineMergeDirectedEdge__["a" /* default */](endNode, startNode, coordinates[coordinates.length - 2], false);
		var edge = new __WEBPACK_IMPORTED_MODULE_4__LineMergeEdge__["a" /* default */](lineString);
		edge.setDirectedEdges(directedEdge0, directedEdge1);
		this.add(edge);
	},
	getNode: function (coordinate) {
		var node = this.findNode(coordinate);
		if (node === null) {
			node = new __WEBPACK_IMPORTED_MODULE_1__planargraph_Node__["a" /* default */](coordinate);
			this.add(node);
		}
		return node;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineMergeGraph;
	}
});


/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineMergeDirectedEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__planargraph_DirectedEdge__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);




function LineMergeDirectedEdge() {
	let from = arguments[0], to = arguments[1], directionPt = arguments[2], edgeDirection = arguments[3];
	__WEBPACK_IMPORTED_MODULE_1__planargraph_DirectedEdge__["a" /* default */].call(this, from, to, directionPt, edgeDirection);
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(LineMergeDirectedEdge, __WEBPACK_IMPORTED_MODULE_1__planargraph_DirectedEdge__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(LineMergeDirectedEdge.prototype, {
	getNext: function () {
		if (this.getToNode().getDegree() !== 2) {
			return null;
		}
		if (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {
			return this.getToNode().getOutEdges().getEdges().get(1);
		}
		__WEBPACK_IMPORTED_MODULE_2__util_Assert__["a" /* default */].isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());
		return this.getToNode().getOutEdges().getEdges().get(0);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineMergeDirectedEdge;
	}
});


/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DirectedEdgeStar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__DirectedEdge__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Edge__ = __webpack_require__(83);





function DirectedEdgeStar() {
	this._outEdges = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
	this._sorted = false;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(DirectedEdgeStar.prototype, {
	getNextEdge: function (dirEdge) {
		var i = this.getIndex(dirEdge);
		return this._outEdges.get(this.getIndex(i + 1));
	},
	getCoordinate: function () {
		var it = this.iterator();
		if (!it.hasNext()) return null;
		var e = it.next();
		return e.getCoordinate();
	},
	iterator: function () {
		this.sortEdges();
		return this._outEdges.iterator();
	},
	sortEdges: function () {
		if (!this._sorted) {
			__WEBPACK_IMPORTED_MODULE_1__java_util_Collections__["a" /* default */].sort(this._outEdges);
			this._sorted = true;
		}
	},
	remove: function (de) {
		this._outEdges.remove(de);
	},
	getEdges: function () {
		this.sortEdges();
		return this._outEdges;
	},
	getNextCWEdge: function (dirEdge) {
		var i = this.getIndex(dirEdge);
		return this._outEdges.get(this.getIndex(i - 1));
	},
	getIndex: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_4__Edge__["a" /* default */]) {
			let edge = arguments[0];
			this.sortEdges();
			for (var i = 0; i < this._outEdges.size(); i++) {
				var de = this._outEdges.get(i);
				if (de.getEdge() === edge) return i;
			}
			return -1;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__DirectedEdge__["a" /* default */]) {
			let dirEdge = arguments[0];
			this.sortEdges();
			for (var i = 0; i < this._outEdges.size(); i++) {
				var de = this._outEdges.get(i);
				if (de === dirEdge) return i;
			}
			return -1;
		} else if (Number.isInteger(arguments[0])) {
			let i = arguments[0];
			var modi = i % this._outEdges.size();
			if (modi < 0) modi += this._outEdges.size();
			return modi;
		}
	},
	add: function (de) {
		this._outEdges.add(de);
		this._sorted = false;
	},
	getDegree: function () {
		return this._outEdges.size();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DirectedEdgeStar;
	}
});


/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LineMergeEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__planargraph_Edge__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function LineMergeEdge() {
	__WEBPACK_IMPORTED_MODULE_1__planargraph_Edge__["a" /* default */].apply(this);
	this._line = null;
	let line = arguments[0];
	this._line = line;
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(LineMergeEdge, __WEBPACK_IMPORTED_MODULE_1__planargraph_Edge__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(LineMergeEdge.prototype, {
	getLine: function () {
		return this._line;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineMergeEdge;
	}
});


/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NodeMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_TreeMap__ = __webpack_require__(35);


function NodeMap() {
	this._nodeMap = new __WEBPACK_IMPORTED_MODULE_1__java_util_TreeMap__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NodeMap.prototype, {
	find: function (coord) {
		return this._nodeMap.get(coord);
	},
	iterator: function () {
		return this._nodeMap.values().iterator();
	},
	remove: function (pt) {
		return this._nodeMap.remove(pt);
	},
	values: function () {
		return this._nodeMap.values();
	},
	add: function (n) {
		this._nodeMap.put(n.getCoordinate(), n);
		return n;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return NodeMap;
	}
});


/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overlay_OverlayOp__ = __webpack_require__(42);
/* unused harmony reexport OverlayOp */





/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygonize_Polygonizer__ = __webpack_require__(329);
/* unused harmony reexport Polygonizer */





/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PolygonizeGraph__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_Collections__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__EdgeRing__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__geom_GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__ = __webpack_require__(1);











function Polygonizer() {
	this._lineStringAdder = new LineStringAdder(this);
	this._graph = null;
	this._dangles = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	this._cutEdges = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	this._invalidRingLines = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	this._holeList = null;
	this._shellList = null;
	this._polyList = null;
	this._isCheckingRingsValid = true;
	this._extractOnlyPolygonal = null;
	this._geomFactory = null;
	if (arguments.length === 0) {
		Polygonizer.call(this, false);
	} else if (arguments.length === 1) {
		let extractOnlyPolygonal = arguments[0];
		this._extractOnlyPolygonal = extractOnlyPolygonal;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(Polygonizer.prototype, {
	getGeometry: function () {
		if (this._geomFactory === null) this._geomFactory = new __WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__["a" /* default */]();
		this.polygonize();
		if (this._extractOnlyPolygonal) {
			return this._geomFactory.buildGeometry(this._polyList);
		}
		return this._geomFactory.createGeometryCollection(__WEBPACK_IMPORTED_MODULE_4__geom_GeometryFactory__["a" /* default */].toGeometryArray(this._polyList));
	},
	getInvalidRingLines: function () {
		this.polygonize();
		return this._invalidRingLines;
	},
	findValidRings: function (edgeRingList, validEdgeRingList, invalidRingList) {
		for (var i = edgeRingList.iterator(); i.hasNext(); ) {
			var er = i.next();
			if (er.isValid()) validEdgeRingList.add(er); else invalidRingList.add(er.getLineString());
		}
	},
	polygonize: function () {
		if (this._polyList !== null) return null;
		this._polyList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		if (this._graph === null) return null;
		this._dangles = this._graph.deleteDangles();
		this._cutEdges = this._graph.deleteCutEdges();
		var edgeRingList = this._graph.getEdgeRings();
		var validEdgeRingList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		this._invalidRingLines = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		if (this._isCheckingRingsValid) {
			this.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);
		} else {
			validEdgeRingList = edgeRingList;
		}
		this.findShellsAndHoles(validEdgeRingList);
		Polygonizer.assignHolesToShells(this._holeList, this._shellList);
		__WEBPACK_IMPORTED_MODULE_7__java_util_Collections__["a" /* default */].sort(this._shellList, new __WEBPACK_IMPORTED_MODULE_8__EdgeRing__["a" /* default */].EnvelopeComparator());
		var includeAll = true;
		if (this._extractOnlyPolygonal) {
			Polygonizer.findDisjointShells(this._shellList);
			includeAll = false;
		}
		this._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);
	},
	getDangles: function () {
		this.polygonize();
		return this._dangles;
	},
	getCutEdges: function () {
		this.polygonize();
		return this._cutEdges;
	},
	getPolygons: function () {
		this.polygonize();
		return this._polyList;
	},
	add: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_3__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_5__java_util_Collection__["a" /* default */])) {
			let geomList = arguments[0];
			for (var i = geomList.iterator(); i.hasNext(); ) {
				var geometry = i.next();
				this.add(geometry);
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
			let line = arguments[0];
			this._geomFactory = line.getFactory();
			if (this._graph === null) this._graph = new __WEBPACK_IMPORTED_MODULE_2__PolygonizeGraph__["a" /* default */](this._geomFactory);
			this._graph.addEdge(line);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Geometry__["a" /* default */]) {
			let g = arguments[0];
			g.apply(this._lineStringAdder);
		}
	},
	setCheckRingsValid: function (isCheckingRingsValid) {
		this._isCheckingRingsValid = isCheckingRingsValid;
	},
	findShellsAndHoles: function (edgeRingList) {
		this._holeList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		this._shellList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
		for (var i = edgeRingList.iterator(); i.hasNext(); ) {
			var er = i.next();
			er.computeHole();
			if (er.isHole()) this._holeList.add(er); else this._shellList.add(er);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return Polygonizer;
	}
});
Polygonizer.findOuterShells = function (shellList) {
	for (var i = shellList.iterator(); i.hasNext(); ) {
		var er = i.next();
		var outerHoleER = er.getOuterHole();
		if (outerHoleER !== null && !outerHoleER.isProcessed()) {
			er.setIncluded(true);
			outerHoleER.setProcessed(true);
		}
	}
};
Polygonizer.extractPolygons = function (shellList, includeAll) {
	var polyList = new __WEBPACK_IMPORTED_MODULE_10__java_util_ArrayList__["a" /* default */]();
	for (var i = shellList.iterator(); i.hasNext(); ) {
		var er = i.next();
		if (includeAll || er.isIncluded()) {
			polyList.add(er.getPolygon());
		}
	}
	return polyList;
};
Polygonizer.assignHolesToShells = function (holeList, shellList) {
	for (var i = holeList.iterator(); i.hasNext(); ) {
		var holeER = i.next();
		Polygonizer.assignHoleToShell(holeER, shellList);
	}
};
Polygonizer.assignHoleToShell = function (holeER, shellList) {
	var shell = __WEBPACK_IMPORTED_MODULE_8__EdgeRing__["a" /* default */].findEdgeRingContaining(holeER, shellList);
	if (shell !== null) {
		shell.addHole(holeER);
	}
};
Polygonizer.findDisjointShells = function (shellList) {
	Polygonizer.findOuterShells(shellList);
	var isMoreToScan = null;
	do {
		isMoreToScan = false;
		for (var i = shellList.iterator(); i.hasNext(); ) {
			var er = i.next();
			if (er.isIncludedSet()) continue;
			er.updateIncluded();
			if (!er.isIncludedSet()) {
				isMoreToScan = true;
			}
		}
	} while (isMoreToScan);
};
function LineStringAdder() {
	this.p = null;
	let p = arguments[0];
	this.p = p;
}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(LineStringAdder.prototype, {
	filter: function (g) {
		if (g instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) this.p.add(g);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_9__geom_GeometryComponentFilter__["a" /* default */]];
	},
	getClass: function () {
		return LineStringAdder;
	}
});
Polygonizer.LineStringAdder = LineStringAdder;


/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonizeGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__PolygonizeDirectedEdge__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_HashSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_Stack__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__planargraph_Node__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PolygonizeEdge__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__EdgeRing__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__planargraph_PlanarGraph__ = __webpack_require__(156);












function PolygonizeGraph() {
	__WEBPACK_IMPORTED_MODULE_11__planargraph_PlanarGraph__["a" /* default */].apply(this);
	this._factory = null;
	let factory = arguments[0];
	this._factory = factory;
}
Object(__WEBPACK_IMPORTED_MODULE_10__inherits__["a" /* default */])(PolygonizeGraph, __WEBPACK_IMPORTED_MODULE_11__planargraph_PlanarGraph__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(PolygonizeGraph.prototype, {
	findEdgeRing: function (startDE) {
		var er = new __WEBPACK_IMPORTED_MODULE_6__EdgeRing__["a" /* default */](this._factory);
		er.build(startDE);
		return er;
	},
	computeDepthParity: function () {
		if (arguments.length === 0) {
			while (true) {
				var de = null;
				if (de === null) return null;
				this.computeDepthParity(de);
			}
		} else if (arguments.length === 1) {
			let de = arguments[0];
		}
	},
	computeNextCWEdges: function () {
		for (var iNode = this.nodeIterator(); iNode.hasNext(); ) {
			var node = iNode.next();
			PolygonizeGraph.computeNextCWEdges(node);
		}
	},
	addEdge: function (line) {
		if (line.isEmpty()) {
			return null;
		}
		var linePts = __WEBPACK_IMPORTED_MODULE_7__geom_CoordinateArrays__["a" /* default */].removeRepeatedPoints(line.getCoordinates());
		if (linePts.length < 2) {
			return null;
		}
		var startPt = linePts[0];
		var endPt = linePts[linePts.length - 1];
		var nStart = this.getNode(startPt);
		var nEnd = this.getNode(endPt);
		var de0 = new __WEBPACK_IMPORTED_MODULE_0__PolygonizeDirectedEdge__["a" /* default */](nStart, nEnd, linePts[1], true);
		var de1 = new __WEBPACK_IMPORTED_MODULE_0__PolygonizeDirectedEdge__["a" /* default */](nEnd, nStart, linePts[linePts.length - 2], false);
		var edge = new __WEBPACK_IMPORTED_MODULE_4__PolygonizeEdge__["a" /* default */](line);
		edge.setDirectedEdges(de0, de1);
		this.add(edge);
	},
	deleteCutEdges: function () {
		this.computeNextCWEdges();
		PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);
		var cutLines = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = this._dirEdges.iterator(); i.hasNext(); ) {
			var de = i.next();
			if (de.isMarked()) continue;
			var sym = de.getSym();
			if (de.getLabel() === sym.getLabel()) {
				de.setMarked(true);
				sym.setMarked(true);
				var e = de.getEdge();
				cutLines.add(e.getLine());
			}
		}
		return cutLines;
	},
	getEdgeRings: function () {
		this.computeNextCWEdges();
		PolygonizeGraph.label(this._dirEdges, -1);
		var maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);
		this.convertMaximalToMinimalEdgeRings(maximalRings);
		var edgeRingList = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var i = this._dirEdges.iterator(); i.hasNext(); ) {
			var de = i.next();
			if (de.isMarked()) continue;
			if (de.isInRing()) continue;
			var er = this.findEdgeRing(de);
			edgeRingList.add(er);
		}
		return edgeRingList;
	},
	getNode: function (pt) {
		var node = this.findNode(pt);
		if (node === null) {
			node = new __WEBPACK_IMPORTED_MODULE_3__planargraph_Node__["a" /* default */](pt);
			this.add(node);
		}
		return node;
	},
	convertMaximalToMinimalEdgeRings: function (ringEdges) {
		for (var i = ringEdges.iterator(); i.hasNext(); ) {
			var de = i.next();
			var label = de.getLabel();
			var intNodes = PolygonizeGraph.findIntersectionNodes(de, label);
			if (intNodes === null) continue;
			for (var iNode = intNodes.iterator(); iNode.hasNext(); ) {
				var node = iNode.next();
				PolygonizeGraph.computeNextCCWEdges(node, label);
			}
		}
	},
	deleteDangles: function () {
		var nodesToRemove = this.findNodesOfDegree(1);
		var dangleLines = new __WEBPACK_IMPORTED_MODULE_1__java_util_HashSet__["a" /* default */]();
		var nodeStack = new __WEBPACK_IMPORTED_MODULE_2__java_util_Stack__["a" /* default */]();
		for (var i = nodesToRemove.iterator(); i.hasNext(); ) {
			nodeStack.push(i.next());
		}
		while (!nodeStack.isEmpty()) {
			var node = nodeStack.pop();
			PolygonizeGraph.deleteAllEdges(node);
			var nodeOutEdges = node.getOutEdges().getEdges();
			for (var i = nodeOutEdges.iterator(); i.hasNext(); ) {
				var de = i.next();
				de.setMarked(true);
				var sym = de.getSym();
				if (sym !== null) sym.setMarked(true);
				var e = de.getEdge();
				dangleLines.add(e.getLine());
				var toNode = de.getToNode();
				if (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);
			}
		}
		return dangleLines;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PolygonizeGraph;
	}
});
PolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {
	var edgeRingStarts = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
	var currLabel = 1;
	for (var i = dirEdges.iterator(); i.hasNext(); ) {
		var de = i.next();
		if (de.isMarked()) continue;
		if (de.getLabel() >= 0) continue;
		edgeRingStarts.add(de);
		var edges = __WEBPACK_IMPORTED_MODULE_6__EdgeRing__["a" /* default */].findDirEdgesInRing(de);
		PolygonizeGraph.label(edges, currLabel);
		currLabel++;
	}
	return edgeRingStarts;
};
PolygonizeGraph.getDegreeNonDeleted = function (node) {
	var edges = node.getOutEdges().getEdges();
	var degree = 0;
	for (var i = edges.iterator(); i.hasNext(); ) {
		var de = i.next();
		if (!de.isMarked()) degree++;
	}
	return degree;
};
PolygonizeGraph.deleteAllEdges = function (node) {
	var edges = node.getOutEdges().getEdges();
	for (var i = edges.iterator(); i.hasNext(); ) {
		var de = i.next();
		de.setMarked(true);
		var sym = de.getSym();
		if (sym !== null) sym.setMarked(true);
	}
};
PolygonizeGraph.label = function (dirEdges, label) {
	for (var i = dirEdges.iterator(); i.hasNext(); ) {
		var de = i.next();
		de.setLabel(label);
	}
};
PolygonizeGraph.computeNextCWEdges = function (node) {
	var deStar = node.getOutEdges();
	var startDE = null;
	var prevDE = null;
	for (var i = deStar.getEdges().iterator(); i.hasNext(); ) {
		var outDE = i.next();
		if (outDE.isMarked()) continue;
		if (startDE === null) startDE = outDE;
		if (prevDE !== null) {
			var sym = prevDE.getSym();
			sym.setNext(outDE);
		}
		prevDE = outDE;
	}
	if (prevDE !== null) {
		var sym = prevDE.getSym();
		sym.setNext(startDE);
	}
};
PolygonizeGraph.computeNextCCWEdges = function (node, label) {
	var deStar = node.getOutEdges();
	var firstOutDE = null;
	var prevInDE = null;
	var edges = deStar.getEdges();
	for (var i = edges.size() - 1; i >= 0; i--) {
		var de = edges.get(i);
		var sym = de.getSym();
		var outDE = null;
		if (de.getLabel() === label) outDE = de;
		var inDE = null;
		if (sym.getLabel() === label) inDE = sym;
		if (outDE === null && inDE === null) continue;
		if (inDE !== null) {
			prevInDE = inDE;
		}
		if (outDE !== null) {
			if (prevInDE !== null) {
				prevInDE.setNext(outDE);
				prevInDE = null;
			}
			if (firstOutDE === null) firstOutDE = outDE;
		}
	}
	if (prevInDE !== null) {
		__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(firstOutDE !== null);
		prevInDE.setNext(firstOutDE);
	}
};
PolygonizeGraph.getDegree = function (node, label) {
	var edges = node.getOutEdges().getEdges();
	var degree = 0;
	for (var i = edges.iterator(); i.hasNext(); ) {
		var de = i.next();
		if (de.getLabel() === label) degree++;
	}
	return degree;
};
PolygonizeGraph.findIntersectionNodes = function (startDE, label) {
	var de = startDE;
	var intNodes = null;
	do {
		var node = de.getFromNode();
		if (PolygonizeGraph.getDegree(node, label) > 1) {
			if (intNodes === null) intNodes = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
			intNodes.add(node);
		}
		de = de.getNext();
		__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(de !== null, "found null DE in ring");
		__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(de === startDE || !de.isInRing(), "found DE already in ring");
	} while (de !== startDE);
	return intNodes;
};


/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonizeDirectedEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__planargraph_DirectedEdge__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function PolygonizeDirectedEdge() {
	this._edgeRing = null;
	this._next = null;
	this._label = -1;
	let from = arguments[0], to = arguments[1], directionPt = arguments[2], edgeDirection = arguments[3];
	__WEBPACK_IMPORTED_MODULE_1__planargraph_DirectedEdge__["a" /* default */].call(this, from, to, directionPt, edgeDirection);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(PolygonizeDirectedEdge, __WEBPACK_IMPORTED_MODULE_1__planargraph_DirectedEdge__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(PolygonizeDirectedEdge.prototype, {
	getNext: function () {
		return this._next;
	},
	isInRing: function () {
		return this._edgeRing !== null;
	},
	setRing: function (edgeRing) {
		this._edgeRing = edgeRing;
	},
	setLabel: function (label) {
		this._label = label;
	},
	getLabel: function () {
		return this._label;
	},
	setNext: function (next) {
		this._next = next;
	},
	getRing: function () {
		return this._edgeRing;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PolygonizeDirectedEdge;
	}
});


/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonizeEdge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__planargraph_Edge__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function PolygonizeEdge() {
	__WEBPACK_IMPORTED_MODULE_1__planargraph_Edge__["a" /* default */].apply(this);
	this._line = null;
	let line = arguments[0];
	this._line = line;
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(PolygonizeEdge, __WEBPACK_IMPORTED_MODULE_1__planargraph_Edge__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(PolygonizeEdge.prototype, {
	getLine: function () {
		return this._line;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PolygonizeEdge;
	}
});


/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConnectedInteriorTester;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__overlay_MaximalEdgeRing__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__overlay_OverlayNodeFactory__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__geomgraph_PlanarGraph__ = __webpack_require__(64);











function ConnectedInteriorTester() {
	this._geometryFactory = new __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__["a" /* default */]();
	this._geomGraph = null;
	this._disconnectedRingcoord = null;
	let geomGraph = arguments[0];
	this._geomGraph = geomGraph;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(ConnectedInteriorTester.prototype, {
	visitInteriorRing: function (ring, graph) {
		var pts = ring.getCoordinates();
		var pt0 = pts[0];
		var pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);
		var e = graph.findEdgeInSameDirection(pt0, pt1);
		var de = graph.findEdgeEnd(e);
		var intDe = null;
		if (de.getLabel().getLocation(0, __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].RIGHT) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) {
			intDe = de;
		} else if (de.getSym().getLabel().getLocation(0, __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].RIGHT) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) {
			intDe = de.getSym();
		}
		__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(intDe !== null, "unable to find dirEdge with Interior on RHS");
		this.visitLinkedDirectedEdges(intDe);
	},
	visitShellInteriors: function (g, graph) {
		if (g instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Polygon__["a" /* default */]) {
			var p = g;
			this.visitInteriorRing(p.getExteriorRing(), graph);
		}
		if (g instanceof __WEBPACK_IMPORTED_MODULE_5__geom_MultiPolygon__["a" /* default */]) {
			var mp = g;
			for (var i = 0; i < mp.getNumGeometries(); i++) {
				var p = mp.getGeometryN(i);
				this.visitInteriorRing(p.getExteriorRing(), graph);
			}
		}
	},
	getCoordinate: function () {
		return this._disconnectedRingcoord;
	},
	setInteriorEdgesInResult: function (graph) {
		for (var it = graph.getEdgeEnds().iterator(); it.hasNext(); ) {
			var de = it.next();
			if (de.getLabel().getLocation(0, __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].RIGHT) === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) {
				de.setInResult(true);
			}
		}
	},
	visitLinkedDirectedEdges: function (start) {
		var startDe = start;
		var de = start;
		do {
			__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(de !== null, "found null Directed Edge");
			de.setVisited(true);
			de = de.getNext();
		} while (de !== startDe);
	},
	buildEdgeRings: function (dirEdges) {
		var edgeRings = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		for (var it = dirEdges.iterator(); it.hasNext(); ) {
			var de = it.next();
			if (de.isInResult() && de.getEdgeRing() === null) {
				var er = new __WEBPACK_IMPORTED_MODULE_6__overlay_MaximalEdgeRing__["a" /* default */](de, this._geometryFactory);
				er.linkDirectedEdgesForMinimalEdgeRings();
				var minEdgeRings = er.buildMinimalRings();
				edgeRings.addAll(minEdgeRings);
			}
		}
		return edgeRings;
	},
	hasUnvisitedShellEdge: function (edgeRings) {
		for (var i = 0; i < edgeRings.size(); i++) {
			var er = edgeRings.get(i);
			if (er.isHole()) continue;
			var edges = er.getEdges();
			var de = edges.get(0);
			if (de.getLabel().getLocation(0, __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].RIGHT) !== __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) continue;
			for (var j = 0; j < edges.size(); j++) {
				de = edges.get(j);
				if (!de.isVisited()) {
					this._disconnectedRingcoord = de.getCoordinate();
					return true;
				}
			}
		}
		return false;
	},
	isInteriorsConnected: function () {
		var splitEdges = new __WEBPACK_IMPORTED_MODULE_8__java_util_ArrayList__["a" /* default */]();
		this._geomGraph.computeSplitEdges(splitEdges);
		var graph = new __WEBPACK_IMPORTED_MODULE_10__geomgraph_PlanarGraph__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_7__overlay_OverlayNodeFactory__["a" /* default */]());
		graph.addEdges(splitEdges);
		this.setInteriorEdgesInResult(graph);
		graph.linkResultDirectedEdges();
		var edgeRings = this.buildEdgeRings(graph.getEdgeEnds());
		this.visitShellInteriors(this._geomGraph.getGeometry(), graph);
		return !this.hasUnvisitedShellEdge(edgeRings);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConnectedInteriorTester;
	}
});
ConnectedInteriorTester.findDifferentPoint = function (coord, pt) {
	for (var i = 0; i < coord.length; i++) {
		if (!coord[i].equals(pt)) return coord[i];
	}
	return null;
};


/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RelateNodeGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EdgeEndBuilder__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geomgraph_NodeMap__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__RelateNodeFactory__ = __webpack_require__(160);





function RelateNodeGraph() {
	this._nodes = new __WEBPACK_IMPORTED_MODULE_3__geomgraph_NodeMap__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_4__RelateNodeFactory__["a" /* default */]());
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(RelateNodeGraph.prototype, {
	insertEdgeEnds: function (ee) {
		for (var i = ee.iterator(); i.hasNext(); ) {
			var e = i.next();
			this._nodes.add(e);
		}
	},
	getNodeIterator: function () {
		return this._nodes.iterator();
	},
	copyNodesAndLabels: function (geomGraph, argIndex) {
		for (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext(); ) {
			var graphNode = nodeIt.next();
			var newNode = this._nodes.addNode(graphNode.getCoordinate());
			newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
		}
	},
	build: function (geomGraph) {
		this.computeIntersectionNodes(geomGraph, 0);
		this.copyNodesAndLabels(geomGraph, 0);
		var eeBuilder = new __WEBPACK_IMPORTED_MODULE_1__EdgeEndBuilder__["a" /* default */]();
		var eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());
		this.insertEdgeEnds(eeList);
	},
	computeIntersectionNodes: function (geomGraph, argIndex) {
		for (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext(); ) {
			var e = edgeIt.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {
				var ei = eiIt.next();
				var n = this._nodes.addNode(ei.coord);
				if (eLoc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) n.setLabelBoundary(argIndex); else {
					if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
				}
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RelateNodeGraph;
	}
});


/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeEndBundleStar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeEndStar__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__EdgeEndBundle__ = __webpack_require__(336);




function EdgeEndBundleStar() {
	__WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeEndStar__["a" /* default */].apply(this);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(EdgeEndBundleStar, __WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeEndStar__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(EdgeEndBundleStar.prototype, {
	updateIM: function (im) {
		for (var it = this.iterator(); it.hasNext(); ) {
			var esb = it.next();
			esb.updateIM(im);
		}
	},
	insert: function (e) {
		var eb = this._edgeMap.get(e);
		if (eb === null) {
			eb = new __WEBPACK_IMPORTED_MODULE_3__EdgeEndBundle__["a" /* default */](e);
			this.insertEdgeEnd(e, eb);
		} else {
			eb.insert(e);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeEndBundleStar;
	}
});


/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EdgeEndBundle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeEnd__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geomgraph_GeometryGraph__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geomgraph_Label__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geomgraph_Edge__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__inherits__ = __webpack_require__(3);









function EdgeEndBundle() {
	this._edgeEnds = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	if (arguments.length === 1) {
		let e = arguments[0];
		EdgeEndBundle.call(this, null, e);
	} else if (arguments.length === 2) {
		let boundaryNodeRule = arguments[0], e = arguments[1];
		__WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeEnd__["a" /* default */].call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new __WEBPACK_IMPORTED_MODULE_5__geomgraph_Label__["a" /* default */](e.getLabel()));
		this.insert(e);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_8__inherits__["a" /* default */])(EdgeEndBundle, __WEBPACK_IMPORTED_MODULE_1__geomgraph_EdgeEnd__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(EdgeEndBundle.prototype, {
	insert: function (e) {
		this._edgeEnds.add(e);
	},
	print: function (out) {
		out.println("EdgeEndBundle--> Label: " + this._label);
		for (var it = this.iterator(); it.hasNext(); ) {
			var ee = it.next();
			ee.print(out);
			out.println();
		}
	},
	iterator: function () {
		return this._edgeEnds.iterator();
	},
	getEdgeEnds: function () {
		return this._edgeEnds;
	},
	computeLabelOn: function (geomIndex, boundaryNodeRule) {
		var boundaryCount = 0;
		var foundInterior = false;
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			var loc = e.getLabel().getLocation(geomIndex);
			if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].BOUNDARY) boundaryCount++;
			if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) foundInterior = true;
		}
		var loc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE;
		if (foundInterior) loc = __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR;
		if (boundaryCount > 0) {
			loc = __WEBPACK_IMPORTED_MODULE_4__geomgraph_GeometryGraph__["a" /* default */].determineBoundary(boundaryNodeRule, boundaryCount);
		}
		this._label.setLocation(geomIndex, loc);
	},
	computeLabelSide: function (geomIndex, side) {
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			if (e.getLabel().isArea()) {
				var loc = e.getLabel().getLocation(geomIndex, side);
				if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR) {
					this._label.setLocation(geomIndex, side, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].INTERIOR);
					return null;
				} else if (loc === __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR) this._label.setLocation(geomIndex, side, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].EXTERIOR);
			}
		}
	},
	getLabel: function () {
		return this._label;
	},
	computeLabelSides: function (geomIndex) {
		this.computeLabelSide(geomIndex, __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].LEFT);
		this.computeLabelSide(geomIndex, __WEBPACK_IMPORTED_MODULE_2__geomgraph_Position__["a" /* default */].RIGHT);
	},
	updateIM: function (im) {
		__WEBPACK_IMPORTED_MODULE_7__geomgraph_Edge__["a" /* default */].updateIM(this._label, im);
	},
	computeLabel: function (boundaryNodeRule) {
		var isArea = false;
		for (var it = this.iterator(); it.hasNext(); ) {
			var e = it.next();
			if (e.getLabel().isArea()) isArea = true;
		}
		if (isArea) this._label = new __WEBPACK_IMPORTED_MODULE_5__geomgraph_Label__["a" /* default */](__WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE, __WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE); else this._label = new __WEBPACK_IMPORTED_MODULE_5__geomgraph_Label__["a" /* default */](__WEBPACK_IMPORTED_MODULE_0__geom_Location__["a" /* default */].NONE);
		for (var i = 0; i < 2; i++) {
			this.computeLabelOn(i, boundaryNodeRule);
			if (isArea) this.computeLabelSides(i);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EdgeEndBundle;
	}
});


/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RelateNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geomgraph_Node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function RelateNode() {
	let coord = arguments[0], edges = arguments[1];
	__WEBPACK_IMPORTED_MODULE_0__geomgraph_Node__["a" /* default */].call(this, coord, edges);
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(RelateNode, __WEBPACK_IMPORTED_MODULE_0__geomgraph_Node__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(RelateNode.prototype, {
	updateIMFromEdges: function (im) {
		this._edges.updateIM(im);
	},
	computeIM: function (im) {
		im.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RelateNode;
	}
});


/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = IndexedNestedRingTester;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_strtree_STRtree__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__IsValidOp__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__ = __webpack_require__(7);






function IndexedNestedRingTester() {
	this._graph = null;
	this._rings = new __WEBPACK_IMPORTED_MODULE_4__java_util_ArrayList__["a" /* default */]();
	this._totalEnv = new __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */]();
	this._index = null;
	this._nestedPt = null;
	let graph = arguments[0];
	this._graph = graph;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(IndexedNestedRingTester.prototype, {
	buildIndex: function () {
		this._index = new __WEBPACK_IMPORTED_MODULE_1__index_strtree_STRtree__["a" /* default */]();
		for (var i = 0; i < this._rings.size(); i++) {
			var ring = this._rings.get(i);
			var env = ring.getEnvelopeInternal();
			this._index.insert(env, ring);
		}
	},
	getNestedPoint: function () {
		return this._nestedPt;
	},
	isNonNested: function () {
		this.buildIndex();
		for (var i = 0; i < this._rings.size(); i++) {
			var innerRing = this._rings.get(i);
			var innerRingPts = innerRing.getCoordinates();
			var results = this._index.query(innerRing.getEnvelopeInternal());
			for (var j = 0; j < results.size(); j++) {
				var searchRing = results.get(j);
				var searchRingPts = searchRing.getCoordinates();
				if (innerRing === searchRing) continue;
				if (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;
				var innerRingPt = __WEBPACK_IMPORTED_MODULE_2__IsValidOp__["a" /* default */].findPtNotNode(innerRingPts, searchRing, this._graph);
				if (innerRingPt === null) continue;
				var isInside = __WEBPACK_IMPORTED_MODULE_0__algorithm_CGAlgorithms__["a" /* default */].isPointInRing(innerRingPt, searchRingPts);
				if (isInside) {
					this._nestedPt = innerRingPt;
					return false;
				}
			}
		}
		return true;
	},
	add: function (ring) {
		this._rings.add(ring);
		this._totalEnv.expandToInclude(ring.getEnvelopeInternal());
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return IndexedNestedRingTester;
	}
});


/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TopologyValidationError;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function TopologyValidationError() {
	this._errorType = null;
	this._pt = null;
	if (arguments.length === 1) {
		let errorType = arguments[0];
		TopologyValidationError.call(this, errorType, null);
	} else if (arguments.length === 2) {
		let errorType = arguments[0], pt = arguments[1];
		this._errorType = errorType;
		if (pt !== null) this._pt = pt.copy();
	}
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(TopologyValidationError.prototype, {
	getErrorType: function () {
		return this._errorType;
	},
	getMessage: function () {
		return TopologyValidationError.errMsg[this._errorType];
	},
	getCoordinate: function () {
		return this._pt;
	},
	toString: function () {
		var locStr = "";
		if (this._pt !== null) locStr = " at or near point " + this._pt;
		return this.getMessage() + locStr;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TopologyValidationError;
	}
});
TopologyValidationError.ERROR = 0;
TopologyValidationError.REPEATED_POINT = 1;
TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;
TopologyValidationError.NESTED_HOLES = 3;
TopologyValidationError.DISCONNECTED_INTERIOR = 4;
TopologyValidationError.SELF_INTERSECTION = 5;
TopologyValidationError.RING_SELF_INTERSECTION = 6;
TopologyValidationError.NESTED_SHELLS = 7;
TopologyValidationError.DUPLICATE_RINGS = 8;
TopologyValidationError.TOO_FEW_POINTS = 9;
TopologyValidationError.INVALID_COORDINATE = 10;
TopologyValidationError.RING_NOT_CLOSED = 11;
TopologyValidationError.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"];


/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__relate_RelateOp__ = __webpack_require__(341);
/* unused harmony reexport RelateOp */





/***/ }),
/* 341 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RelateComputer__ = __webpack_require__(342);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__algorithm_BoundaryNodeRule__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__GeometryGraphOperation__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__predicate_RectangleContains__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__predicate_RectangleIntersects__ = __webpack_require__(344);









function RelateOp() {
	this._relate = null;
	if (arguments.length === 2) {
		let g0 = arguments[0], g1 = arguments[1];
		__WEBPACK_IMPORTED_MODULE_5__GeometryGraphOperation__["a" /* default */].call(this, g0, g1);
		this._relate = new __WEBPACK_IMPORTED_MODULE_2__RelateComputer__["a" /* default */](this._arg);
	} else if (arguments.length === 3) {
		let g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];
		__WEBPACK_IMPORTED_MODULE_5__GeometryGraphOperation__["a" /* default */].call(this, g0, g1, boundaryNodeRule);
		this._relate = new __WEBPACK_IMPORTED_MODULE_2__RelateComputer__["a" /* default */](this._arg);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(RelateOp, __WEBPACK_IMPORTED_MODULE_5__GeometryGraphOperation__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(RelateOp.prototype, {
	getIntersectionMatrix: function () {
		return this._relate.computeIM();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RelateOp;
	}
});
RelateOp.covers = function (g1, g2) {
	if (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;
	if (g1.isRectangle()) {
		return true;
	}
	return RelateOp.relate(g1, g2).isCovers();
};
RelateOp.intersects = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	if (g1.isRectangle()) {
		return __WEBPACK_IMPORTED_MODULE_8__predicate_RectangleIntersects__["a" /* default */].intersects(g1, g2);
	}
	if (g2.isRectangle()) {
		return __WEBPACK_IMPORTED_MODULE_8__predicate_RectangleIntersects__["a" /* default */].intersects(g2, g1);
	}
	return RelateOp.relate(g1, g2).isIntersects();
};
RelateOp.touches = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	return RelateOp.relate(g1, g2).isTouches(g1.getDimension(), g2.getDimension());
};
RelateOp.within = function (g1, g2) {
	return g2.contains(g1);
};
RelateOp.coveredBy = function (g1, g2) {
	return RelateOp.covers(g2, g1);
};
RelateOp.relate = function () {
	if (arguments.length === 2) {
		let a = arguments[0], b = arguments[1];
		var relOp = new RelateOp(a, b);
		var im = relOp.getIntersectionMatrix();
		return im;
	} else if (arguments.length === 3) {
		if (typeof arguments[2] === "string" && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */])) {
			let g1 = arguments[0], g2 = arguments[1], intersectionPattern = arguments[2];
			return RelateOp.relateWithCheck(g1, g2).matches(intersectionPattern);
		} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[2], __WEBPACK_IMPORTED_MODULE_3__algorithm_BoundaryNodeRule__["a" /* default */]) && (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */] && arguments[1] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */])) {
			let a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];
			var relOp = new RelateOp(a, b, boundaryNodeRule);
			var im = relOp.getIntersectionMatrix();
			return im;
		}
	}
};
RelateOp.overlaps = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	return RelateOp.relate(g1, g2).isOverlaps(g1.getDimension(), g2.getDimension());
};
RelateOp.disjoint = function (g1, g2) {
	return !g1.intersects(g2);
};
RelateOp.relateWithCheck = function (g1, g2) {
	g1.checkNotGeometryCollection(g1);
	g1.checkNotGeometryCollection(g2);
	return RelateOp.relate(g1, g2);
};
RelateOp.crosses = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	return RelateOp.relate(g1, g2).isCrosses(g1.getDimension(), g2.getDimension());
};
RelateOp.contains = function (g1, g2) {
	if (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;
	if (g1.isRectangle()) {
		return __WEBPACK_IMPORTED_MODULE_6__predicate_RectangleContains__["a" /* default */].contains(g1, g2);
	}
	return RelateOp.relate(g1, g2).isContains();
};


/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RelateComputer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Location__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_IntersectionMatrix__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__EdgeEndBuilder__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geomgraph_NodeMap__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__RelateNodeFactory__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__algorithm_RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Assert__ = __webpack_require__(4);










function RelateComputer() {
	this._li = new __WEBPACK_IMPORTED_MODULE_8__algorithm_RobustLineIntersector__["a" /* default */]();
	this._ptLocator = new __WEBPACK_IMPORTED_MODULE_0__algorithm_PointLocator__["a" /* default */]();
	this._arg = null;
	this._nodes = new __WEBPACK_IMPORTED_MODULE_5__geomgraph_NodeMap__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_6__RelateNodeFactory__["a" /* default */]());
	this._im = null;
	this._isolatedEdges = new __WEBPACK_IMPORTED_MODULE_7__java_util_ArrayList__["a" /* default */]();
	this._invalidPoint = null;
	let arg = arguments[0];
	this._arg = arg;
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(RelateComputer.prototype, {
	insertEdgeEnds: function (ee) {
		for (var i = ee.iterator(); i.hasNext(); ) {
			var e = i.next();
			this._nodes.add(e);
		}
	},
	computeProperIntersectionIM: function (intersector, im) {
		var dimA = this._arg[0].getGeometry().getDimension();
		var dimB = this._arg[1].getGeometry().getDimension();
		var hasProper = intersector.hasProperIntersection();
		var hasProperInterior = intersector.hasProperInteriorIntersection();
		if (dimA === 2 && dimB === 2) {
			if (hasProper) im.setAtLeast("212101212");
		} else if (dimA === 2 && dimB === 1) {
			if (hasProper) im.setAtLeast("FFF0FFFF2");
			if (hasProperInterior) im.setAtLeast("1FFFFF1FF");
		} else if (dimA === 1 && dimB === 2) {
			if (hasProper) im.setAtLeast("F0FFFFFF2");
			if (hasProperInterior) im.setAtLeast("1F1FFFFFF");
		} else if (dimA === 1 && dimB === 1) {
			if (hasProperInterior) im.setAtLeast("0FFFFFFFF");
		}
	},
	labelIsolatedEdges: function (thisIndex, targetIndex) {
		for (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext(); ) {
			var e = ei.next();
			if (e.isIsolated()) {
				this.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());
				this._isolatedEdges.add(e);
			}
		}
	},
	labelIsolatedEdge: function (e, targetIndex, target) {
		if (target.getDimension() > 0) {
			var loc = this._ptLocator.locate(e.getCoordinate(), target);
			e.getLabel().setAllLocations(targetIndex, loc);
		} else {
			e.getLabel().setAllLocations(targetIndex, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR);
		}
	},
	computeIM: function () {
		var im = new __WEBPACK_IMPORTED_MODULE_2__geom_IntersectionMatrix__["a" /* default */]();
		im.set(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, 2);
		if (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {
			this.computeDisjointIM(im);
			return im;
		}
		this._arg[0].computeSelfNodes(this._li, false);
		this._arg[1].computeSelfNodes(this._li, false);
		var intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);
		this.computeIntersectionNodes(0);
		this.computeIntersectionNodes(1);
		this.copyNodesAndLabels(0);
		this.copyNodesAndLabels(1);
		this.labelIsolatedNodes();
		this.computeProperIntersectionIM(intersector, im);
		var eeBuilder = new __WEBPACK_IMPORTED_MODULE_3__EdgeEndBuilder__["a" /* default */]();
		var ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());
		this.insertEdgeEnds(ee0);
		var ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());
		this.insertEdgeEnds(ee1);
		this.labelNodeEdges();
		this.labelIsolatedEdges(0, 1);
		this.labelIsolatedEdges(1, 0);
		this.updateIM(im);
		return im;
	},
	labelNodeEdges: function () {
		for (var ni = this._nodes.iterator(); ni.hasNext(); ) {
			var node = ni.next();
			node.getEdges().computeLabelling(this._arg);
		}
	},
	copyNodesAndLabels: function (argIndex) {
		for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {
			var graphNode = i.next();
			var newNode = this._nodes.addNode(graphNode.getCoordinate());
			newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
		}
	},
	labelIntersectionNodes: function (argIndex) {
		for (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {
			var e = i.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {
				var ei = eiIt.next();
				var n = this._nodes.find(ei.coord);
				if (n.getLabel().isNull(argIndex)) {
					if (eLoc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY) n.setLabelBoundary(argIndex); else n.setLabel(argIndex, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR);
				}
			}
		}
	},
	labelIsolatedNode: function (n, targetIndex) {
		var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
		n.getLabel().setAllLocations(targetIndex, loc);
	},
	computeIntersectionNodes: function (argIndex) {
		for (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {
			var e = i.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {
				var ei = eiIt.next();
				var n = this._nodes.addNode(ei.coord);
				if (eLoc === __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY) n.setLabelBoundary(argIndex); else {
					if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR);
				}
			}
		}
	},
	labelIsolatedNodes: function () {
		for (var ni = this._nodes.iterator(); ni.hasNext(); ) {
			var n = ni.next();
			var label = n.getLabel();
			__WEBPACK_IMPORTED_MODULE_9__util_Assert__["a" /* default */].isTrue(label.getGeometryCount() > 0, "node with empty label found");
			if (n.isIsolated()) {
				if (label.isNull(0)) this.labelIsolatedNode(n, 0); else this.labelIsolatedNode(n, 1);
			}
		}
	},
	updateIM: function (im) {
		for (var ei = this._isolatedEdges.iterator(); ei.hasNext(); ) {
			var e = ei.next();
			e.updateIM(im);
		}
		for (var ni = this._nodes.iterator(); ni.hasNext(); ) {
			var node = ni.next();
			node.updateIM(im);
			node.updateIMFromEdges(im);
		}
	},
	computeDisjointIM: function (im) {
		var ga = this._arg[0].getGeometry();
		if (!ga.isEmpty()) {
			im.set(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, ga.getDimension());
			im.set(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, ga.getBoundaryDimension());
		}
		var gb = this._arg[1].getGeometry();
		if (!gb.isEmpty()) {
			im.set(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].INTERIOR, gb.getDimension());
			im.set(__WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].EXTERIOR, __WEBPACK_IMPORTED_MODULE_1__geom_Location__["a" /* default */].BOUNDARY, gb.getBoundaryDimension());
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RelateComputer;
	}
});


/***/ }),
/* 343 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RectangleContains;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Point__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extend__ = __webpack_require__(0);





function RectangleContains() {
	this._rectEnv = null;
	let rectangle = arguments[0];
	this._rectEnv = rectangle.getEnvelopeInternal();
}
Object(__WEBPACK_IMPORTED_MODULE_4__extend__["a" /* default */])(RectangleContains.prototype, {
	isContainedInBoundary: function (geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Polygon__["a" /* default */]) return false;
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Point__["a" /* default */]) return this.isPointContainedInBoundary(geom);
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) return this.isLineStringContainedInBoundary(geom);
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var comp = geom.getGeometryN(i);
			if (!this.isContainedInBoundary(comp)) return false;
		}
		return true;
	},
	isLineSegmentContainedInBoundary: function (p0, p1) {
		if (p0.equals(p1)) return this.isPointContainedInBoundary(p0);
		if (p0.x === p1.x) {
			if (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;
		} else if (p0.y === p1.y) {
			if (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;
		}
		return false;
	},
	isLineStringContainedInBoundary: function (line) {
		var seq = line.getCoordinateSequence();
		var p0 = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]();
		var p1 = new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]();
		for (var i = 0; i < seq.size() - 1; i++) {
			seq.getCoordinate(i, p0);
			seq.getCoordinate(i + 1, p1);
			if (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;
		}
		return true;
	},
	isPointContainedInBoundary: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__geom_Point__["a" /* default */]) {
			let point = arguments[0];
			return this.isPointContainedInBoundary(point.getCoordinate());
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */]) {
			let pt = arguments[0];
			return pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();
		}
	},
	contains: function (geom) {
		if (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;
		if (this.isContainedInBoundary(geom)) return false;
		return true;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RectangleContains;
	}
});
RectangleContains.contains = function (rectangle, b) {
	var rc = new RectangleContains(rectangle);
	return rc.contains(b);
};


/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RectangleIntersects;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__algorithm_RectangleLineIntersector__ = __webpack_require__(345);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__ = __webpack_require__(346);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__algorithm_locate_SimplePointInAreaLocator__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_util_LinearComponentExtracter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__inherits__ = __webpack_require__(3);








function RectangleIntersects() {
	this._rectangle = null;
	this._rectEnv = null;
	let rectangle = arguments[0];
	this._rectangle = rectangle;
	this._rectEnv = rectangle.getEnvelopeInternal();
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(RectangleIntersects.prototype, {
	intersects: function (geom) {
		if (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;
		var visitor = new EnvelopeIntersectsVisitor(this._rectEnv);
		visitor.applyTo(geom);
		if (visitor.intersects()) return true;
		var ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);
		ecpVisitor.applyTo(geom);
		if (ecpVisitor.containsPoint()) return true;
		var riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);
		riVisitor.applyTo(geom);
		if (riVisitor.intersects()) return true;
		return false;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RectangleIntersects;
	}
});
RectangleIntersects.intersects = function (rectangle, b) {
	var rp = new RectangleIntersects(rectangle);
	return rp.intersects(b);
};
function EnvelopeIntersectsVisitor() {
	__WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__["a" /* default */].apply(this);
	this._rectEnv = null;
	this._intersects = false;
	let rectEnv = arguments[0];
	this._rectEnv = rectEnv;
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(EnvelopeIntersectsVisitor, __WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(EnvelopeIntersectsVisitor.prototype, {
	isDone: function () {
		return this._intersects === true;
	},
	visit: function (element) {
		var elementEnv = element.getEnvelopeInternal();
		if (!this._rectEnv.intersects(elementEnv)) {
			return null;
		}
		if (this._rectEnv.contains(elementEnv)) {
			this._intersects = true;
			return null;
		}
		if (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {
			this._intersects = true;
			return null;
		}
		if (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {
			this._intersects = true;
			return null;
		}
	},
	intersects: function () {
		return this._intersects;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return EnvelopeIntersectsVisitor;
	}
});
function GeometryContainsPointVisitor() {
	__WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__["a" /* default */].apply(this);
	this._rectSeq = null;
	this._rectEnv = null;
	this._containsPoint = false;
	let rectangle = arguments[0];
	this._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();
	this._rectEnv = rectangle.getEnvelopeInternal();
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(GeometryContainsPointVisitor, __WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(GeometryContainsPointVisitor.prototype, {
	isDone: function () {
		return this._containsPoint === true;
	},
	visit: function (geom) {
		if (!(geom instanceof __WEBPACK_IMPORTED_MODULE_1__geom_Polygon__["a" /* default */])) return null;
		var elementEnv = geom.getEnvelopeInternal();
		if (!this._rectEnv.intersects(elementEnv)) return null;
		var rectPt = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
		for (var i = 0; i < 4; i++) {
			this._rectSeq.getCoordinate(i, rectPt);
			if (!elementEnv.contains(rectPt)) continue;
			if (__WEBPACK_IMPORTED_MODULE_5__algorithm_locate_SimplePointInAreaLocator__["a" /* default */].containsPointInPolygon(rectPt, geom)) {
				this._containsPoint = true;
				return null;
			}
		}
	},
	containsPoint: function () {
		return this._containsPoint;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryContainsPointVisitor;
	}
});
function RectangleIntersectsSegmentVisitor() {
	__WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__["a" /* default */].apply(this);
	this._rectEnv = null;
	this._rectIntersector = null;
	this._hasIntersection = false;
	this._p0 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
	this._p1 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
	let rectangle = arguments[0];
	this._rectEnv = rectangle.getEnvelopeInternal();
	this._rectIntersector = new __WEBPACK_IMPORTED_MODULE_2__algorithm_RectangleLineIntersector__["a" /* default */](this._rectEnv);
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(RectangleIntersectsSegmentVisitor, __WEBPACK_IMPORTED_MODULE_4__geom_util_ShortCircuitedGeometryVisitor__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(RectangleIntersectsSegmentVisitor.prototype, {
	intersects: function () {
		return this._hasIntersection;
	},
	isDone: function () {
		return this._hasIntersection === true;
	},
	visit: function (geom) {
		var elementEnv = geom.getEnvelopeInternal();
		if (!this._rectEnv.intersects(elementEnv)) return null;
		var lines = __WEBPACK_IMPORTED_MODULE_6__geom_util_LinearComponentExtracter__["a" /* default */].getLines(geom);
		this.checkIntersectionWithLineStrings(lines);
	},
	checkIntersectionWithLineStrings: function (lines) {
		for (var i = lines.iterator(); i.hasNext(); ) {
			var testLine = i.next();
			this.checkIntersectionWithSegments(testLine);
			if (this._hasIntersection) return null;
		}
	},
	checkIntersectionWithSegments: function (testLine) {
		var seq1 = testLine.getCoordinateSequence();
		for (var j = 1; j < seq1.size(); j++) {
			seq1.getCoordinate(j - 1, this._p0);
			seq1.getCoordinate(j, this._p1);
			if (this._rectIntersector.intersects(this._p0, this._p1)) {
				this._hasIntersection = true;
				return null;
			}
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RectangleIntersectsSegmentVisitor;
	}
});


/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RectangleLineIntersector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RobustLineIntersector__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Envelope__ = __webpack_require__(7);




function RectangleLineIntersector() {
	this._li = new __WEBPACK_IMPORTED_MODULE_2__RobustLineIntersector__["a" /* default */]();
	this._rectEnv = null;
	this._diagUp0 = null;
	this._diagUp1 = null;
	this._diagDown0 = null;
	this._diagDown1 = null;
	let rectEnv = arguments[0];
	this._rectEnv = rectEnv;
	this._diagUp0 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](rectEnv.getMinX(), rectEnv.getMinY());
	this._diagUp1 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](rectEnv.getMaxX(), rectEnv.getMaxY());
	this._diagDown0 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](rectEnv.getMinX(), rectEnv.getMaxY());
	this._diagDown1 = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](rectEnv.getMaxX(), rectEnv.getMinY());
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(RectangleLineIntersector.prototype, {
	intersects: function (p0, p1) {
		var segEnv = new __WEBPACK_IMPORTED_MODULE_3__geom_Envelope__["a" /* default */](p0, p1);
		if (!this._rectEnv.intersects(segEnv)) return false;
		if (this._rectEnv.intersects(p0)) return true;
		if (this._rectEnv.intersects(p1)) return true;
		if (p0.compareTo(p1) > 0) {
			var tmp = p0;
			p0 = p1;
			p1 = tmp;
		}
		var isSegUpwards = false;
		if (p1.y > p0.y) isSegUpwards = true;
		if (isSegUpwards) {
			this._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);
		} else {
			this._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);
		}
		if (this._li.hasIntersection()) return true;
		return false;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return RectangleLineIntersector;
	}
});


/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ShortCircuitedGeometryVisitor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__GeometryCollection__ = __webpack_require__(13);


function ShortCircuitedGeometryVisitor() {
	this._isDone = false;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(ShortCircuitedGeometryVisitor.prototype, {
	applyTo: function (geom) {
		for (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {
			var element = geom.getGeometryN(i);
			if (!(element instanceof __WEBPACK_IMPORTED_MODULE_1__GeometryCollection__["a" /* default */])) {
				this.visit(element);
				if (this.isDone()) {
					this._isDone = true;
					return null;
				}
			} else this.applyTo(element);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ShortCircuitedGeometryVisitor;
	}
});


/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__union_CascadedPolygonUnion__ = __webpack_require__(161);
/* unused harmony reexport CascadedPolygonUnion */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__union_PointGeometryUnion__ = __webpack_require__(162);
/* unused harmony reexport PointGeometryUnion */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__union_UnaryUnionOp__ = __webpack_require__(348);
/* unused harmony reexport UnaryUnionOp */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__union_UnionInteracting__ = __webpack_require__(350);
/* unused harmony reexport UnionInteracting */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__union_UnionOp__ = __webpack_require__(351);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_4__union_UnionOp__["a"]; });






/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PointGeometryUnion__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__overlay_snap_SnapIfNeededOverlayOp__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_util_GeometryExtracter__ = __webpack_require__(349);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__overlay_OverlayOp__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__CascadedPolygonUnion__ = __webpack_require__(161);










function UnaryUnionOp() {
	this._polygons = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._lines = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._points = new __WEBPACK_IMPORTED_MODULE_6__java_util_ArrayList__["a" /* default */]();
	this._geomFact = null;
	if (arguments.length === 1) {
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let geoms = arguments[0];
			this.extract(geoms);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			this.extract(geom);
		}
	} else if (arguments.length === 2) {
		let geoms = arguments[0], geomFact = arguments[1];
		this._geomFact = geomFact;
		this.extract(geoms);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(UnaryUnionOp.prototype, {
	unionNoOpt: function (g0) {
		var empty = this._geomFact.createPoint();
		return __WEBPACK_IMPORTED_MODULE_4__overlay_snap_SnapIfNeededOverlayOp__["a" /* default */].overlayOp(g0, empty, __WEBPACK_IMPORTED_MODULE_8__overlay_OverlayOp__["a" /* default */].UNION);
	},
	unionWithNull: function (g0, g1) {
		if (g0 === null && g1 === null) return null;
		if (g1 === null) return g0;
		if (g0 === null) return g1;
		return g0.union(g1);
	},
	extract: function () {
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let geoms = arguments[0];
			for (var i = geoms.iterator(); i.hasNext(); ) {
				var geom = i.next();
				this.extract(geom);
			}
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			if (this._geomFact === null) this._geomFact = geom.getFactory();
			__WEBPACK_IMPORTED_MODULE_7__geom_util_GeometryExtracter__["a" /* default */].extract(geom, __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */].SORTINDEX_POLYGON, this._polygons);
			__WEBPACK_IMPORTED_MODULE_7__geom_util_GeometryExtracter__["a" /* default */].extract(geom, __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */].SORTINDEX_LINESTRING, this._lines);
			__WEBPACK_IMPORTED_MODULE_7__geom_util_GeometryExtracter__["a" /* default */].extract(geom, __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */].SORTINDEX_POINT, this._points);
		}
	},
	union: function () {
		if (this._geomFact === null) {
			return null;
		}
		var unionPoints = null;
		if (this._points.size() > 0) {
			var ptGeom = this._geomFact.buildGeometry(this._points);
			unionPoints = this.unionNoOpt(ptGeom);
		}
		var unionLines = null;
		if (this._lines.size() > 0) {
			var lineGeom = this._geomFact.buildGeometry(this._lines);
			unionLines = this.unionNoOpt(lineGeom);
		}
		var unionPolygons = null;
		if (this._polygons.size() > 0) {
			unionPolygons = __WEBPACK_IMPORTED_MODULE_9__CascadedPolygonUnion__["a" /* default */].union(this._polygons);
		}
		var unionLA = this.unionWithNull(unionLines, unionPolygons);
		var union = null;
		if (unionPoints === null) union = unionLA; else if (unionLA === null) union = unionPoints; else union = __WEBPACK_IMPORTED_MODULE_1__PointGeometryUnion__["a" /* default */].union(unionPoints, unionLA);
		if (union === null) return this._geomFact.createGeometryCollection();
		return union;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return UnaryUnionOp;
	}
});
UnaryUnionOp.union = function () {
	if (arguments.length === 1) {
		if (Object(__WEBPACK_IMPORTED_MODULE_2__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let geoms = arguments[0];
			var op = new UnaryUnionOp(geoms);
			return op.union();
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			var op = new UnaryUnionOp(geom);
			return op.union();
		}
	} else if (arguments.length === 2) {
		let geoms = arguments[0], geomFact = arguments[1];
		var op = new UnaryUnionOp(geoms, geomFact);
		return op.union();
	}
};


/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = GeometryExtracter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__GeometryCollection__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__GeometryFilter__ = __webpack_require__(39);




function GeometryExtracter() {
	this._sortIndex = -1;
	this._comps = null;
	let sortIndex = arguments[0], comps = arguments[1];
	this._sortIndex = sortIndex;
	this._comps = comps;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(GeometryExtracter.prototype, {
	filter: function (geom) {
		if (this._sortIndex === -1 || geom.getSortIndex() === this._sortIndex) this._comps.add(geom);
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_3__GeometryFilter__["a" /* default */]];
	},
	getClass: function () {
		return GeometryExtracter;
	}
});
GeometryExtracter.extract = function () {
	if (arguments.length === 2) {
		let geom = arguments[0], sortIndex = arguments[1];
		return GeometryExtracter.extract(geom, sortIndex, new __WEBPACK_IMPORTED_MODULE_2__java_util_ArrayList__["a" /* default */]());
	} else if (arguments.length === 3) {
		let geom = arguments[0], sortIndex = arguments[1], list = arguments[2];
		if (geom.getSortIndex() === sortIndex) {
			list.add(geom);
		} else if (geom instanceof __WEBPACK_IMPORTED_MODULE_1__GeometryCollection__["a" /* default */]) {
			geom.apply(new GeometryExtracter(sortIndex, list));
		}
		return list;
	}
};


/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryCombiner__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);




function UnionInteracting() {
	this._geomFactory = null;
	this._g0 = null;
	this._g1 = null;
	this._interacts0 = null;
	this._interacts1 = null;
	let g0 = arguments[0], g1 = arguments[1];
	this._g0 = g0;
	this._g1 = g1;
	this._geomFactory = g0.getFactory();
	this._interacts0 = new Array(g0.getNumGeometries()).fill(null);
	this._interacts1 = new Array(g1.getNumGeometries()).fill(null);
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(UnionInteracting.prototype, {
	extractElements: function (geom, interacts, isInteracting) {
		var extractedGeoms = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elem = geom.getGeometryN(i);
			if (interacts[i] === isInteracting) extractedGeoms.add(elem);
		}
		return this._geomFactory.buildGeometry(extractedGeoms);
	},
	computeInteracting: function () {
		if (arguments.length === 0) {
			for (var i = 0; i < this._g0.getNumGeometries(); i++) {
				var elem = this._g0.getGeometryN(i);
				this._interacts0[i] = this.computeInteracting(elem);
			}
		} else if (arguments.length === 1) {
			let elem0 = arguments[0];
			var interactsWithAny = false;
			for (var i = 0; i < this._g1.getNumGeometries(); i++) {
				var elem1 = this._g1.getGeometryN(i);
				var interacts = elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());
				if (interacts) this._interacts1[i] = true;
				if (interacts) interactsWithAny = true;
			}
			return interactsWithAny;
		}
	},
	union: function () {
		this.computeInteracting();
		var int0 = this.extractElements(this._g0, this._interacts0, true);
		var int1 = this.extractElements(this._g1, this._interacts1, true);
		if (int0.isEmpty() || int1.isEmpty()) {
			__WEBPACK_IMPORTED_MODULE_2__java_lang_System__["a" /* default */].out.println("found empty!");
		}
		var union = int0.union(int1);
		var disjoint0 = this.extractElements(this._g0, this._interacts0, false);
		var disjoint1 = this.extractElements(this._g1, this._interacts1, false);
		var overallUnion = __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryCombiner__["a" /* default */].combine(union, disjoint0, disjoint1);
		return overallUnion;
	},
	bufferUnion: function (g0, g1) {
		var factory = g0.getFactory();
		var gColl = factory.createGeometryCollection([g0, g1]);
		var unionAll = gColl.buffer(0.0);
		return unionAll;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return UnionInteracting;
	}
});
UnionInteracting.union = function (g0, g1) {
	var uue = new UnionInteracting(g0, g1);
	return uue.union();
};


/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = UnionOp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overlay_snap_SnapIfNeededOverlayOp__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__overlay_OverlayOp__ = __webpack_require__(42);



function UnionOp() {}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(UnionOp.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return UnionOp;
	}
});
UnionOp.union = function (g, other) {
	if (g.isEmpty() || other.isEmpty()) {
		if (g.isEmpty() && other.isEmpty()) return __WEBPACK_IMPORTED_MODULE_2__overlay_OverlayOp__["a" /* default */].createEmptyResult(__WEBPACK_IMPORTED_MODULE_2__overlay_OverlayOp__["a" /* default */].UNION, g, other, g.getFactory());
		if (g.isEmpty()) return other.copy();
		if (other.isEmpty()) return g.copy();
	}
	g.checkNotGeometryCollection(g);
	g.checkNotGeometryCollection(other);
	return __WEBPACK_IMPORTED_MODULE_0__overlay_snap_SnapIfNeededOverlayOp__["a" /* default */].overlayOp(g, other, __WEBPACK_IMPORTED_MODULE_2__overlay_OverlayOp__["a" /* default */].UNION);
};


/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__valid_IsValidOp__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__valid_ConsistentAreaTester__ = __webpack_require__(158);
/* unused harmony reexport IsValidOp */
/* unused harmony reexport ConsistentAreaTester */






/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__precision_GeometryPrecisionReducer__ = __webpack_require__(354);
/* unused harmony reexport GeometryPrecisionReducer */





/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryEditor__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_Polygonal__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__PrecisionReducerCoordinateOperation__ = __webpack_require__(355);






function GeometryPrecisionReducer() {
	this._targetPM = null;
	this._removeCollapsed = true;
	this._changePrecisionModel = false;
	this._isPointwise = false;
	let pm = arguments[0];
	this._targetPM = pm;
}
Object(__WEBPACK_IMPORTED_MODULE_3__extend__["a" /* default */])(GeometryPrecisionReducer.prototype, {
	fixPolygonalTopology: function (geom) {
		var geomToBuffer = geom;
		if (!this._changePrecisionModel) {
			geomToBuffer = this.changePM(geom, this._targetPM);
		}
		var bufGeom = geomToBuffer.buffer(0);
		var finalGeom = bufGeom;
		if (!this._changePrecisionModel) {
			finalGeom = this.changePM(bufGeom, geom.getPrecisionModel());
		}
		return finalGeom;
	},
	reducePointwise: function (geom) {
		var geomEdit = null;
		if (this._changePrecisionModel) {
			var newFactory = this.createFactory(geom.getFactory(), this._targetPM);
			geomEdit = new __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryEditor__["a" /* default */](newFactory);
		} else geomEdit = new __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryEditor__["a" /* default */]();
		var finalRemoveCollapsed = this._removeCollapsed;
		if (geom.getDimension() >= 2) finalRemoveCollapsed = true;
		var reduceGeom = geomEdit.edit(geom, new __WEBPACK_IMPORTED_MODULE_5__PrecisionReducerCoordinateOperation__["a" /* default */](this._targetPM, finalRemoveCollapsed));
		return reduceGeom;
	},
	changePM: function (geom, newPM) {
		var geomEditor = this.createEditor(geom.getFactory(), newPM);
		return geomEditor.edit(geom, new __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryEditor__["a" /* default */].NoOpGeometryOperation());
	},
	setRemoveCollapsedComponents: function (removeCollapsed) {
		this._removeCollapsed = removeCollapsed;
	},
	createFactory: function (inputFactory, pm) {
		var newFactory = new __WEBPACK_IMPORTED_MODULE_1__geom_GeometryFactory__["a" /* default */](pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());
		return newFactory;
	},
	setChangePrecisionModel: function (changePrecisionModel) {
		this._changePrecisionModel = changePrecisionModel;
	},
	reduce: function (geom) {
		var reducePW = this.reducePointwise(geom);
		if (this._isPointwise) return reducePW;
		if (!Object(__WEBPACK_IMPORTED_MODULE_0__hasInterface__["a" /* default */])(reducePW, __WEBPACK_IMPORTED_MODULE_4__geom_Polygonal__["a" /* default */])) return reducePW;
		if (reducePW.isValid()) return reducePW;
		return this.fixPolygonalTopology(reducePW);
	},
	setPointwise: function (isPointwise) {
		this._isPointwise = isPointwise;
	},
	createEditor: function (geomFactory, newPM) {
		if (geomFactory.getPrecisionModel() === newPM) return new __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryEditor__["a" /* default */]();
		var newFactory = this.createFactory(geomFactory, newPM);
		var geomEdit = new __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryEditor__["a" /* default */](newFactory);
		return geomEdit;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return GeometryPrecisionReducer;
	}
});
GeometryPrecisionReducer.reduce = function (g, precModel) {
	var reducer = new GeometryPrecisionReducer(precModel);
	return reducer.reduce(g);
};
GeometryPrecisionReducer.reducePointwise = function (g, precModel) {
	var reducer = new GeometryPrecisionReducer(precModel);
	reducer.setPointwise(true);
	return reducer.reduce(g);
};


/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PrecisionReducerCoordinateOperation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_util_GeometryEditor__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__inherits__ = __webpack_require__(3);







function PrecisionReducerCoordinateOperation() {
	__WEBPACK_IMPORTED_MODULE_3__geom_util_GeometryEditor__["a" /* default */].CoordinateOperation.apply(this);
	this._targetPM = null;
	this._removeCollapsed = true;
	let targetPM = arguments[0], removeCollapsed = arguments[1];
	this._targetPM = targetPM;
	this._removeCollapsed = removeCollapsed;
}
Object(__WEBPACK_IMPORTED_MODULE_6__inherits__["a" /* default */])(PrecisionReducerCoordinateOperation, __WEBPACK_IMPORTED_MODULE_3__geom_util_GeometryEditor__["a" /* default */].CoordinateOperation);
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(PrecisionReducerCoordinateOperation.prototype, {
	editCoordinates: function (coordinates, geom) {
		if (coordinates.length === 0) return null;
		var reducedCoords = new Array(coordinates.length).fill(null);
		for (var i = 0; i < coordinates.length; i++) {
			var coord = new __WEBPACK_IMPORTED_MODULE_2__geom_Coordinate__["a" /* default */](coordinates[i]);
			this._targetPM.makePrecise(coord);
			reducedCoords[i] = coord;
		}
		var noRepeatedCoordList = new __WEBPACK_IMPORTED_MODULE_1__geom_CoordinateList__["a" /* default */](reducedCoords, false);
		var noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();
		var minLength = 0;
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) minLength = 2;
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_4__geom_LinearRing__["a" /* default */]) minLength = 4;
		var collapsedCoords = reducedCoords;
		if (this._removeCollapsed) collapsedCoords = null;
		if (noRepeatedCoords.length < minLength) {
			return collapsedCoords;
		}
		return noRepeatedCoords;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return PrecisionReducerCoordinateOperation;
	}
});


/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__simplify_DouglasPeuckerSimplifier__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__simplify_TopologyPreservingSimplifier__ = __webpack_require__(359);
/* unused harmony reexport DouglasPeuckerSimplifier */
/* unused harmony reexport TopologyPreservingSimplifier */






/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__DouglasPeuckerLineSimplifier__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Polygon__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_LinearRing__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_MultiPolygon__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__inherits__ = __webpack_require__(3);








function DouglasPeuckerSimplifier() {
	this._inputGeom = null;
	this._distanceTolerance = null;
	this._isEnsureValidTopology = true;
	let inputGeom = arguments[0];
	this._inputGeom = inputGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(DouglasPeuckerSimplifier.prototype, {
	setEnsureValid: function (isEnsureValidTopology) {
		this._isEnsureValidTopology = isEnsureValidTopology;
	},
	getResultGeometry: function () {
		if (this._inputGeom.isEmpty()) return this._inputGeom.copy();
		return new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);
	},
	setDistanceTolerance: function (distanceTolerance) {
		if (distanceTolerance < 0.0) throw new __WEBPACK_IMPORTED_MODULE_2__java_lang_IllegalArgumentException__["a" /* default */]("Tolerance must be non-negative");
		this._distanceTolerance = distanceTolerance;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DouglasPeuckerSimplifier;
	}
});
DouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {
	var tss = new DouglasPeuckerSimplifier(geom);
	tss.setDistanceTolerance(distanceTolerance);
	return tss.getResultGeometry();
};
function DPTransformer() {
	__WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */].apply(this);
	this._isEnsureValidTopology = true;
	this._distanceTolerance = null;
	let isEnsureValidTopology = arguments[0], distanceTolerance = arguments[1];
	this._isEnsureValidTopology = isEnsureValidTopology;
	this._distanceTolerance = distanceTolerance;
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(DPTransformer, __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(DPTransformer.prototype, {
	transformPolygon: function (geom, parent) {
		if (geom.isEmpty()) return null;
		var rawGeom = __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */].prototype.transformPolygon.call(this, geom, parent);
		if (parent instanceof __WEBPACK_IMPORTED_MODULE_6__geom_MultiPolygon__["a" /* default */]) {
			return rawGeom;
		}
		return this.createValidArea(rawGeom);
	},
	createValidArea: function (rawAreaGeom) {
		if (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);
		return rawAreaGeom;
	},
	transformCoordinates: function (coords, parent) {
		var inputPts = coords.toCoordinateArray();
		var newPts = null;
		if (inputPts.length === 0) {
			newPts = new Array(0).fill(null);
		} else {
			newPts = __WEBPACK_IMPORTED_MODULE_0__DouglasPeuckerLineSimplifier__["a" /* default */].simplify(inputPts, this._distanceTolerance);
		}
		return this._factory.getCoordinateSequenceFactory().create(newPts);
	},
	transformMultiPolygon: function (geom, parent) {
		var rawGeom = __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */].prototype.transformMultiPolygon.call(this, geom, parent);
		return this.createValidArea(rawGeom);
	},
	transformLinearRing: function (geom, parent) {
		var removeDegenerateRings = parent instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Polygon__["a" /* default */];
		var simpResult = __WEBPACK_IMPORTED_MODULE_1__geom_util_GeometryTransformer__["a" /* default */].prototype.transformLinearRing.call(this, geom, parent);
		if (removeDegenerateRings && !(simpResult instanceof __WEBPACK_IMPORTED_MODULE_4__geom_LinearRing__["a" /* default */])) return null;
		;
		return simpResult;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DPTransformer;
	}
});
DouglasPeuckerSimplifier.DPTransformer = DPTransformer;


/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DouglasPeuckerLineSimplifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__ = __webpack_require__(14);




function DouglasPeuckerLineSimplifier() {
	this._pts = null;
	this._usePt = null;
	this._distanceTolerance = null;
	this._seg = new __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__["a" /* default */]();
	let pts = arguments[0];
	this._pts = pts;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(DouglasPeuckerLineSimplifier.prototype, {
	simplifySection: function (i, j) {
		if (i + 1 === j) {
			return null;
		}
		this._seg.p0 = this._pts[i];
		this._seg.p1 = this._pts[j];
		var maxDistance = -1.0;
		var maxIndex = i;
		for (var k = i + 1; k < j; k++) {
			var distance = this._seg.distance(this._pts[k]);
			if (distance > maxDistance) {
				maxDistance = distance;
				maxIndex = k;
			}
		}
		if (maxDistance <= this._distanceTolerance) {
			for (var k = i + 1; k < j; k++) {
				this._usePt[k] = false;
			}
		} else {
			this.simplifySection(i, maxIndex);
			this.simplifySection(maxIndex, j);
		}
	},
	setDistanceTolerance: function (distanceTolerance) {
		this._distanceTolerance = distanceTolerance;
	},
	simplify: function () {
		this._usePt = new Array(this._pts.length).fill(null);
		for (var i = 0; i < this._pts.length; i++) {
			this._usePt[i] = true;
		}
		this.simplifySection(0, this._pts.length - 1);
		var coordList = new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */]();
		for (var i = 0; i < this._pts.length; i++) {
			if (this._usePt[i]) coordList.add(new __WEBPACK_IMPORTED_MODULE_1__geom_Coordinate__["a" /* default */](this._pts[i]));
		}
		return coordList.toCoordinateArray();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return DouglasPeuckerLineSimplifier;
	}
});
DouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {
	var simp = new DouglasPeuckerLineSimplifier(pts);
	simp.setDistanceTolerance(distanceTolerance);
	return simp.simplify();
};


/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_LineString__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_util_HashMap__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__TaggedLinesSimplifier__ = __webpack_require__(360);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_IllegalArgumentException__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_GeometryComponentFilter__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__TaggedLineString__ = __webpack_require__(164);









function TopologyPreservingSimplifier() {
	this._inputGeom = null;
	this._lineSimplifier = new __WEBPACK_IMPORTED_MODULE_3__TaggedLinesSimplifier__["a" /* default */]();
	this._linestringMap = null;
	let inputGeom = arguments[0];
	this._inputGeom = inputGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(TopologyPreservingSimplifier.prototype, {
	getResultGeometry: function () {
		if (this._inputGeom.isEmpty()) return this._inputGeom.copy();
		this._linestringMap = new __WEBPACK_IMPORTED_MODULE_1__java_util_HashMap__["a" /* default */]();
		this._inputGeom.apply(new LineStringMapBuilderFilter(this));
		this._lineSimplifier.simplify(this._linestringMap.values());
		var result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);
		return result;
	},
	setDistanceTolerance: function (distanceTolerance) {
		if (distanceTolerance < 0.0) throw new __WEBPACK_IMPORTED_MODULE_4__java_lang_IllegalArgumentException__["a" /* default */]("Tolerance must be non-negative");
		this._lineSimplifier.setDistanceTolerance(distanceTolerance);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TopologyPreservingSimplifier;
	}
});
TopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {
	var tss = new TopologyPreservingSimplifier(geom);
	tss.setDistanceTolerance(distanceTolerance);
	return tss.getResultGeometry();
};
function LineStringTransformer() {
	__WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */].apply(this);
	this._linestringMap = null;
	let linestringMap = arguments[0];
	this._linestringMap = linestringMap;
}
Object(__WEBPACK_IMPORTED_MODULE_7__inherits__["a" /* default */])(LineStringTransformer, __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(LineStringTransformer.prototype, {
	transformCoordinates: function (coords, parent) {
		if (coords.size() === 0) return null;
		if (parent instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
			var taggedLine = this._linestringMap.get(parent);
			return this.createCoordinateSequence(taggedLine.getResultCoordinates());
		}
		return __WEBPACK_IMPORTED_MODULE_2__geom_util_GeometryTransformer__["a" /* default */].prototype.transformCoordinates.call(this, coords, parent);
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LineStringTransformer;
	}
});
function LineStringMapBuilderFilter() {
	this.tps = null;
	let tps = arguments[0];
	this.tps = tps;
}
Object(__WEBPACK_IMPORTED_MODULE_5__extend__["a" /* default */])(LineStringMapBuilderFilter.prototype, {
	filter: function (geom) {
		if (geom instanceof __WEBPACK_IMPORTED_MODULE_0__geom_LineString__["a" /* default */]) {
			var line = geom;
			if (line.isEmpty()) return null;
			var minSize = line.isClosed() ? 4 : 2;
			var taggedLine = new __WEBPACK_IMPORTED_MODULE_8__TaggedLineString__["a" /* default */](line, minSize);
			this.tps._linestringMap.put(line, taggedLine);
		}
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_6__geom_GeometryComponentFilter__["a" /* default */]];
	},
	getClass: function () {
		return LineStringMapBuilderFilter;
	}
});
TopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;
TopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;


/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TaggedLinesSimplifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__TaggedLineStringSimplifier__ = __webpack_require__(361);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LineSegmentIndex__ = __webpack_require__(163);



function TaggedLinesSimplifier() {
	this._inputIndex = new __WEBPACK_IMPORTED_MODULE_2__LineSegmentIndex__["a" /* default */]();
	this._outputIndex = new __WEBPACK_IMPORTED_MODULE_2__LineSegmentIndex__["a" /* default */]();
	this._distanceTolerance = 0.0;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(TaggedLinesSimplifier.prototype, {
	setDistanceTolerance: function (distanceTolerance) {
		this._distanceTolerance = distanceTolerance;
	},
	simplify: function (taggedLines) {
		for (var i = taggedLines.iterator(); i.hasNext(); ) {
			this._inputIndex.add(i.next());
		}
		for (var i = taggedLines.iterator(); i.hasNext(); ) {
			var tlss = new __WEBPACK_IMPORTED_MODULE_1__TaggedLineStringSimplifier__["a" /* default */](this._inputIndex, this._outputIndex);
			tlss.setDistanceTolerance(this._distanceTolerance);
			tlss.simplify(i.next());
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TaggedLinesSimplifier;
	}
});


/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TaggedLineStringSimplifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LineSegmentIndex__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__algorithm_RobustLineIntersector__ = __webpack_require__(22);




function TaggedLineStringSimplifier() {
	this._li = new __WEBPACK_IMPORTED_MODULE_3__algorithm_RobustLineIntersector__["a" /* default */]();
	this._inputIndex = new __WEBPACK_IMPORTED_MODULE_2__LineSegmentIndex__["a" /* default */]();
	this._outputIndex = new __WEBPACK_IMPORTED_MODULE_2__LineSegmentIndex__["a" /* default */]();
	this._line = null;
	this._linePts = null;
	this._distanceTolerance = 0.0;
	let inputIndex = arguments[0], outputIndex = arguments[1];
	this._inputIndex = inputIndex;
	this._outputIndex = outputIndex;
}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(TaggedLineStringSimplifier.prototype, {
	flatten: function (start, end) {
		var p0 = this._linePts[start];
		var p1 = this._linePts[end];
		var newSeg = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */](p0, p1);
		this.remove(this._line, start, end);
		this._outputIndex.add(newSeg);
		return newSeg;
	},
	hasBadIntersection: function (parentLine, sectionIndex, candidateSeg) {
		if (this.hasBadOutputIntersection(candidateSeg)) return true;
		if (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;
		return false;
	},
	setDistanceTolerance: function (distanceTolerance) {
		this._distanceTolerance = distanceTolerance;
	},
	simplifySection: function (i, j, depth) {
		depth += 1;
		var sectionIndex = new Array(2).fill(null);
		if (i + 1 === j) {
			var newSeg = this._line.getSegment(i);
			this._line.addToResult(newSeg);
			return null;
		}
		var isValidToSimplify = true;
		if (this._line.getResultSize() < this._line.getMinimumSize()) {
			var worstCaseSize = depth + 1;
			if (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;
		}
		var distance = new Array(1).fill(null);
		var furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);
		if (distance[0] > this._distanceTolerance) isValidToSimplify = false;
		var candidateSeg = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]();
		candidateSeg.p0 = this._linePts[i];
		candidateSeg.p1 = this._linePts[j];
		sectionIndex[0] = i;
		sectionIndex[1] = j;
		if (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;
		if (isValidToSimplify) {
			var newSeg = this.flatten(i, j);
			this._line.addToResult(newSeg);
			return null;
		}
		this.simplifySection(i, furthestPtIndex, depth);
		this.simplifySection(furthestPtIndex, j, depth);
	},
	hasBadOutputIntersection: function (candidateSeg) {
		var querySegs = this._outputIndex.query(candidateSeg);
		for (var i = querySegs.iterator(); i.hasNext(); ) {
			var querySeg = i.next();
			if (this.hasInteriorIntersection(querySeg, candidateSeg)) {
				return true;
			}
		}
		return false;
	},
	findFurthestPoint: function (pts, i, j, maxDistance) {
		var seg = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]();
		seg.p0 = pts[i];
		seg.p1 = pts[j];
		var maxDist = -1.0;
		var maxIndex = i;
		for (var k = i + 1; k < j; k++) {
			var midPt = pts[k];
			var distance = seg.distance(midPt);
			if (distance > maxDist) {
				maxDist = distance;
				maxIndex = k;
			}
		}
		maxDistance[0] = maxDist;
		return maxIndex;
	},
	simplify: function (line) {
		this._line = line;
		this._linePts = line.getParentCoordinates();
		this.simplifySection(0, this._linePts.length - 1, 0);
	},
	remove: function (line, start, end) {
		for (var i = start; i < end; i++) {
			var seg = line.getSegment(i);
			this._inputIndex.remove(seg);
		}
	},
	hasInteriorIntersection: function (seg0, seg1) {
		this._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);
		return this._li.isInteriorIntersection();
	},
	hasBadInputIntersection: function (parentLine, sectionIndex, candidateSeg) {
		var querySegs = this._inputIndex.query(candidateSeg);
		for (var i = querySegs.iterator(); i.hasNext(); ) {
			var querySeg = i.next();
			if (this.hasInteriorIntersection(querySeg, candidateSeg)) {
				if (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;
				return true;
			}
		}
		return false;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TaggedLineStringSimplifier;
	}
});
TaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {
	if (seg.getParent() !== line.getParent()) return false;
	var segIndex = seg.getIndex();
	if (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;
	return false;
};


/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TaggedLineSegment;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inherits__ = __webpack_require__(3);



function TaggedLineSegment() {
	this._parent = null;
	this._index = null;
	if (arguments.length === 2) {
		let p0 = arguments[0], p1 = arguments[1];
		TaggedLineSegment.call(this, p0, p1, null, -1);
	} else if (arguments.length === 4) {
		let p0 = arguments[0], p1 = arguments[1], parent = arguments[2], index = arguments[3];
		__WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */].call(this, p0, p1);
		this._parent = parent;
		this._index = index;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__inherits__["a" /* default */])(TaggedLineSegment, __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(TaggedLineSegment.prototype, {
	getIndex: function () {
		return this._index;
	},
	getParent: function () {
		return this._parent;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TaggedLineSegment;
	}
});


/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__triangulate_ConformingDelaunayTriangulationBuilder__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__triangulate_DelaunayTriangulationBuilder__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__triangulate_VoronoiDiagramBuilder__ = __webpack_require__(376);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__triangulate_quadedge__ = __webpack_require__(377);
/* unused harmony reexport ConformingDelaunayTriangulationBuilder */
/* unused harmony reexport DelaunayTriangulationBuilder */
/* unused harmony reexport VoronoiDiagramBuilder */
/* unused harmony reexport quadedge */








/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ConformingDelaunayTriangulator__ = __webpack_require__(365);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ConstraintVertex__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__DelaunayTriangulationBuilder__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Segment__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_util_LinearComponentExtracter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__java_util_TreeMap__ = __webpack_require__(35);








function ConformingDelaunayTriangulationBuilder() {
	this._siteCoords = null;
	this._constraintLines = null;
	this._tolerance = 0.0;
	this._subdiv = null;
	this._constraintVertexMap = new __WEBPACK_IMPORTED_MODULE_7__java_util_TreeMap__["a" /* default */]();
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(ConformingDelaunayTriangulationBuilder.prototype, {
	createSiteVertices: function (coords) {
		var verts = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
		for (var i = coords.iterator(); i.hasNext(); ) {
			var coord = i.next();
			if (this._constraintVertexMap.containsKey(coord)) continue;
			verts.add(new __WEBPACK_IMPORTED_MODULE_1__ConstraintVertex__["a" /* default */](coord));
		}
		return verts;
	},
	create: function () {
		if (this._subdiv !== null) return null;
		var siteEnv = __WEBPACK_IMPORTED_MODULE_3__DelaunayTriangulationBuilder__["a" /* default */].envelope(this._siteCoords);
		var segments = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
		if (this._constraintLines !== null) {
			siteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());
			this.createVertices(this._constraintLines);
			segments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);
		}
		var sites = this.createSiteVertices(this._siteCoords);
		var cdt = new __WEBPACK_IMPORTED_MODULE_0__ConformingDelaunayTriangulator__["a" /* default */](sites, this._tolerance);
		cdt.setConstraints(segments, new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */](this._constraintVertexMap.values()));
		cdt.formInitialDelaunay();
		cdt.enforceConstraints();
		this._subdiv = cdt.getSubdivision();
	},
	setTolerance: function (tolerance) {
		this._tolerance = tolerance;
	},
	setConstraints: function (constraintLines) {
		this._constraintLines = constraintLines;
	},
	setSites: function (geom) {
		this._siteCoords = __WEBPACK_IMPORTED_MODULE_3__DelaunayTriangulationBuilder__["a" /* default */].extractUniqueCoordinates(geom);
	},
	getEdges: function (geomFact) {
		this.create();
		return this._subdiv.getEdges(geomFact);
	},
	getSubdivision: function () {
		this.create();
		return this._subdiv;
	},
	getTriangles: function (geomFact) {
		this.create();
		return this._subdiv.getTriangles(geomFact);
	},
	createVertices: function (geom) {
		var coords = geom.getCoordinates();
		for (var i = 0; i < coords.length; i++) {
			var v = new __WEBPACK_IMPORTED_MODULE_1__ConstraintVertex__["a" /* default */](coords[i]);
			this._constraintVertexMap.put(coords[i], v);
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConformingDelaunayTriangulationBuilder;
	}
});
ConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {
	if (arguments.length === 1) {
		let geom = arguments[0];
		var lines = __WEBPACK_IMPORTED_MODULE_6__geom_util_LinearComponentExtracter__["a" /* default */].getLines(geom);
		var constraintSegs = new __WEBPACK_IMPORTED_MODULE_5__java_util_ArrayList__["a" /* default */]();
		for (var i = lines.iterator(); i.hasNext(); ) {
			var line = i.next();
			ConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);
		}
		return constraintSegs;
	} else if (arguments.length === 2) {
		let line = arguments[0], constraintSegs = arguments[1];
		var coords = line.getCoordinates();
		for (var i = 1; i < coords.length; i++) {
			constraintSegs.add(new __WEBPACK_IMPORTED_MODULE_4__Segment__["a" /* default */](coords[i - 1], coords[i]));
		}
	}
};


/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConformingDelaunayTriangulator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__NonEncroachingSplitPointFinder__ = __webpack_require__(366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ConstraintVertex__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__IncrementalDelaunayTriangulator__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__quadedge_QuadEdgeSubdivision__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__quadedge_LastFoundQuadEdgeLocator__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Segment__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__algorithm_ConvexHull__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__index_kdtree_KdTree__ = __webpack_require__(373);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__ = __webpack_require__(7);














function ConformingDelaunayTriangulator() {
	this._initialVertices = null;
	this._segVertices = null;
	this._segments = new __WEBPACK_IMPORTED_MODULE_12__java_util_ArrayList__["a" /* default */]();
	this._subdiv = null;
	this._incDel = null;
	this._convexHull = null;
	this._splitFinder = new __WEBPACK_IMPORTED_MODULE_1__NonEncroachingSplitPointFinder__["a" /* default */]();
	this._kdt = null;
	this._vertexFactory = null;
	this._computeAreaEnv = null;
	this._splitPt = null;
	this._tolerance = null;
	let initialVertices = arguments[0], tolerance = arguments[1];
	this._initialVertices = new __WEBPACK_IMPORTED_MODULE_12__java_util_ArrayList__["a" /* default */](initialVertices);
	this._tolerance = tolerance;
	this._kdt = new __WEBPACK_IMPORTED_MODULE_11__index_kdtree_KdTree__["a" /* default */](tolerance);
}
Object(__WEBPACK_IMPORTED_MODULE_7__extend__["a" /* default */])(ConformingDelaunayTriangulator.prototype, {
	getInitialVertices: function () {
		return this._initialVertices;
	},
	getKDT: function () {
		return this._kdt;
	},
	enforceConstraints: function () {
		this.addConstraintVertices();
		var count = 0;
		var splits = 0;
		do {
			splits = this.enforceGabriel(this._segments);
			count++;
		} while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);
	},
	insertSites: function (vertices) {
		for (var i = vertices.iterator(); i.hasNext(); ) {
			var v = i.next();
			this.insertSite(v);
		}
	},
	getVertexFactory: function () {
		return this._vertexFactory;
	},
	getPointArray: function () {
		var pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);
		var index = 0;
		for (var i = this._initialVertices.iterator(); i.hasNext(); ) {
			var v = i.next();
			pts[index++] = v.getCoordinate();
		}
		for (var i2 = this._segVertices.iterator(); i2.hasNext(); ) {
			var v = i2.next();
			pts[index++] = v.getCoordinate();
		}
		return pts;
	},
	setConstraints: function (segments, segVertices) {
		this._segments = segments;
		this._segVertices = segVertices;
	},
	computeConvexHull: function () {
		var fact = new __WEBPACK_IMPORTED_MODULE_0__geom_GeometryFactory__["a" /* default */]();
		var coords = this.getPointArray();
		var hull = new __WEBPACK_IMPORTED_MODULE_10__algorithm_ConvexHull__["a" /* default */](coords, fact);
		this._convexHull = hull.getConvexHull();
	},
	addConstraintVertices: function () {
		this.computeConvexHull();
		this.insertSites(this._segVertices);
	},
	findNonGabrielPoint: function (seg) {
		var p = seg.getStart();
		var q = seg.getEnd();
		var midPt = new __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);
		var segRadius = p.distance(midPt);
		var env = new __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__["a" /* default */](midPt);
		env.expandBy(segRadius);
		var result = this._kdt.query(env);
		var closestNonGabriel = null;
		var minDist = __WEBPACK_IMPORTED_MODULE_6__java_lang_Double__["a" /* default */].MAX_VALUE;
		for (var i = result.iterator(); i.hasNext(); ) {
			var nextNode = i.next();
			var testPt = nextNode.getCoordinate();
			if (testPt.equals2D(p) || testPt.equals2D(q)) continue;
			var testRadius = midPt.distance(testPt);
			if (testRadius < segRadius) {
				var testDist = testRadius;
				if (closestNonGabriel === null || testDist < minDist) {
					closestNonGabriel = testPt;
					minDist = testDist;
				}
			}
		}
		return closestNonGabriel;
	},
	getConstraintSegments: function () {
		return this._segments;
	},
	setSplitPointFinder: function (splitFinder) {
		this._splitFinder = splitFinder;
	},
	getConvexHull: function () {
		return this._convexHull;
	},
	getTolerance: function () {
		return this._tolerance;
	},
	enforceGabriel: function (segsToInsert) {
		var newSegments = new __WEBPACK_IMPORTED_MODULE_12__java_util_ArrayList__["a" /* default */]();
		var splits = 0;
		var segsToRemove = new __WEBPACK_IMPORTED_MODULE_12__java_util_ArrayList__["a" /* default */]();
		for (var i = segsToInsert.iterator(); i.hasNext(); ) {
			var seg = i.next();
			var encroachPt = this.findNonGabrielPoint(seg);
			if (encroachPt === null) continue;
			this._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);
			var splitVertex = this.createVertex(this._splitPt, seg);
			var insertedVertex = this.insertSite(splitVertex);
			var s1 = new __WEBPACK_IMPORTED_MODULE_9__Segment__["a" /* default */](seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());
			var s2 = new __WEBPACK_IMPORTED_MODULE_9__Segment__["a" /* default */](splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());
			newSegments.add(s1);
			newSegments.add(s2);
			segsToRemove.add(seg);
			splits = splits + 1;
		}
		segsToInsert.removeAll(segsToRemove);
		segsToInsert.addAll(newSegments);
		return splits;
	},
	createVertex: function () {
		if (arguments.length === 1) {
			let p = arguments[0];
			var v = null;
			if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null); else v = new __WEBPACK_IMPORTED_MODULE_2__ConstraintVertex__["a" /* default */](p);
			return v;
		} else if (arguments.length === 2) {
			let p = arguments[0], seg = arguments[1];
			var v = null;
			if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, seg); else v = new __WEBPACK_IMPORTED_MODULE_2__ConstraintVertex__["a" /* default */](p);
			v.setOnConstraint(true);
			return v;
		}
	},
	getSubdivision: function () {
		return this._subdiv;
	},
	computeBoundingBox: function () {
		var vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);
		var segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);
		var allPointsEnv = new __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__["a" /* default */](vertexEnv);
		allPointsEnv.expandToInclude(segEnv);
		var deltaX = allPointsEnv.getWidth() * 0.2;
		var deltaY = allPointsEnv.getHeight() * 0.2;
		var delta = Math.max(deltaX, deltaY);
		this._computeAreaEnv = new __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__["a" /* default */](allPointsEnv);
		this._computeAreaEnv.expandBy(delta);
	},
	setVertexFactory: function (vertexFactory) {
		this._vertexFactory = vertexFactory;
	},
	formInitialDelaunay: function () {
		this.computeBoundingBox();
		this._subdiv = new __WEBPACK_IMPORTED_MODULE_5__quadedge_QuadEdgeSubdivision__["a" /* default */](this._computeAreaEnv, this._tolerance);
		this._subdiv.setLocator(new __WEBPACK_IMPORTED_MODULE_8__quadedge_LastFoundQuadEdgeLocator__["a" /* default */](this._subdiv));
		this._incDel = new __WEBPACK_IMPORTED_MODULE_4__IncrementalDelaunayTriangulator__["a" /* default */](this._subdiv);
		this.insertSites(this._initialVertices);
	},
	insertSite: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_2__ConstraintVertex__["a" /* default */]) {
			let v = arguments[0];
			var kdnode = this._kdt.insert(v.getCoordinate(), v);
			if (!kdnode.isRepeated()) {
				this._incDel.insertSite(v);
			} else {
				var snappedV = kdnode.getData();
				snappedV.merge(v);
				return snappedV;
			}
			return v;
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_3__geom_Coordinate__["a" /* default */]) {
			let p = arguments[0];
			this.insertSite(this.createVertex(p));
		}
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConformingDelaunayTriangulator;
	}
});
ConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {
	var env = new __WEBPACK_IMPORTED_MODULE_13__geom_Envelope__["a" /* default */]();
	for (var i = vertices.iterator(); i.hasNext(); ) {
		var v = i.next();
		env.expandToInclude(v.getCoordinate());
	}
	return env;
};
ConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;


/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NonEncroachingSplitPointFinder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SplitSegment__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ConstraintSplitPointFinder__ = __webpack_require__(368);



function NonEncroachingSplitPointFinder() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(NonEncroachingSplitPointFinder.prototype, {
	findSplitPoint: function (seg, encroachPt) {
		var lineSeg = seg.getLineSegment();
		var segLen = lineSeg.getLength();
		var midPtLen = segLen / 2;
		var splitSeg = new __WEBPACK_IMPORTED_MODULE_1__SplitSegment__["a" /* default */](lineSeg);
		var projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);
		var nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;
		var maxSplitLen = nonEncroachDiam;
		if (maxSplitLen > midPtLen) {
			maxSplitLen = midPtLen;
		}
		splitSeg.setMinimumLength(maxSplitLen);
		splitSeg.splitAt(projPt);
		return splitSeg.getSplitPoint();
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_2__ConstraintSplitPointFinder__["a" /* default */]];
	},
	getClass: function () {
		return NonEncroachingSplitPointFinder;
	}
});
NonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {
	var lineSeg = seg.getLineSegment();
	var projPt = lineSeg.project(encroachPt);
	return projPt;
};


/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SplitSegment;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function SplitSegment() {
	this._seg = null;
	this._segLen = null;
	this._splitPt = null;
	this._minimumLen = 0.0;
	let seg = arguments[0];
	this._seg = seg;
	this._segLen = seg.getLength();
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(SplitSegment.prototype, {
	splitAt: function () {
		if (arguments.length === 1) {
			let pt = arguments[0];
			var minFrac = this._minimumLen / this._segLen;
			if (pt.distance(this._seg.p0) < this._minimumLen) {
				this._splitPt = this._seg.pointAlong(minFrac);
				return null;
			}
			if (pt.distance(this._seg.p1) < this._minimumLen) {
				this._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);
				return null;
			}
			this._splitPt = pt;
		} else if (arguments.length === 2) {
			let length = arguments[0], endPt = arguments[1];
			var actualLen = this.getConstrainedLength(length);
			var frac = actualLen / this._segLen;
			if (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac); else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);
		}
	},
	setMinimumLength: function (minLen) {
		this._minimumLen = minLen;
	},
	getConstrainedLength: function (len) {
		if (len < this._minimumLen) return this._minimumLen;
		return len;
	},
	getSplitPoint: function () {
		return this._splitPt;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return SplitSegment;
	}
});
SplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {
	var coord = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */]();
	coord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);
	coord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);
	return coord;
};


/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ConstraintSplitPointFinder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function ConstraintSplitPointFinder() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(ConstraintSplitPointFinder.prototype, {
	findSplitPoint: function (seg, encroachPt) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return ConstraintSplitPointFinder;
	}
});


/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TrianglePredicate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_impl_CoordinateArraySequence__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_DD__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__java_lang_System__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Triangle__ = __webpack_require__(79);






function TrianglePredicate() {}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(TrianglePredicate.prototype, {
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TrianglePredicate;
	}
});
TrianglePredicate.triArea = function (a, b, c) {
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
};
TrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {
	var adx = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(a.x).selfSubtract(p.x);
	var ady = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(a.y).selfSubtract(p.y);
	var bdx = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(b.x).selfSubtract(p.x);
	var bdy = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(b.y).selfSubtract(p.y);
	var cdx = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(c.x).selfSubtract(p.x);
	var cdy = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(c.y).selfSubtract(p.y);
	var abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));
	var bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));
	var cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));
	var alift = adx.multiply(adx).selfAdd(ady.multiply(ady));
	var blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));
	var clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));
	var sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));
	var isInCircle = sum.doubleValue() > 0;
	return isInCircle;
};
TrianglePredicate.checkRobustInCircle = function (a, b, c, p) {
	var nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);
	var isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);
	var isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);
	var circumCentre = __WEBPACK_IMPORTED_MODULE_5__geom_Triangle__["a" /* default */].circumcentre(a, b, c);
	__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println("p radius diff a = " + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));
	if (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println("inCircle robustness failure (double result = " + nonRobustInCircle + ", DD result = " + isInCircleDD + ", CC result = " + isInCircleCC + ")");
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println(__WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toLineString(new __WEBPACK_IMPORTED_MODULE_1__geom_impl_CoordinateArraySequence__["a" /* default */]([a, b, c, p])));
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println("Circumcentre = " + __WEBPACK_IMPORTED_MODULE_0__io_WKTWriter__["a" /* default */].toPoint(circumCentre) + " radius = " + a.distance(circumCentre));
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println("p radius diff a = " + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println("p radius diff b = " + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println("p radius diff c = " + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));
		__WEBPACK_IMPORTED_MODULE_4__java_lang_System__["a" /* default */].out.println();
	}
};
TrianglePredicate.isInCircleDDFast = function (a, b, c, p) {
	var aTerm = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(a.x).selfAdd(__WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));
	var bTerm = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(b.x).selfAdd(__WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));
	var cTerm = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(c.x).selfAdd(__WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));
	var pTerm = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(p.x).selfAdd(__WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));
	var sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);
	var isInCircle = sum.doubleValue() > 0;
	return isInCircle;
};
TrianglePredicate.isInCircleCC = function (a, b, c, p) {
	var cc = __WEBPACK_IMPORTED_MODULE_5__geom_Triangle__["a" /* default */].circumcentre(a, b, c);
	var ccRadius = a.distance(cc);
	var pRadiusDiff = p.distance(cc) - ccRadius;
	return pRadiusDiff <= 0;
};
TrianglePredicate.isInCircleNormalized = function (a, b, c, p) {
	var adx = a.x - p.x;
	var ady = a.y - p.y;
	var bdx = b.x - p.x;
	var bdy = b.y - p.y;
	var cdx = c.x - p.x;
	var cdy = c.y - p.y;
	var abdet = adx * bdy - bdx * ady;
	var bcdet = bdx * cdy - cdx * bdy;
	var cadet = cdx * ady - adx * cdy;
	var alift = adx * adx + ady * ady;
	var blift = bdx * bdx + bdy * bdy;
	var clift = cdx * cdx + cdy * cdy;
	var disc = alift * bcdet + blift * cadet + clift * abdet;
	return disc > 0;
};
TrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {
	var px = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(p.x);
	var py = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(p.y);
	var ax = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(a.x);
	var ay = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(a.y);
	var bx = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(b.x);
	var by = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(b.y);
	var cx = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(c.x);
	var cy = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(c.y);
	var aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));
	var bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));
	var cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));
	var pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));
	var sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);
	var isInCircle = sum.doubleValue() > 0;
	return isInCircle;
};
TrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {
	var isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;
	return isInCircle;
};
TrianglePredicate.isInCircleRobust = function (a, b, c, p) {
	return TrianglePredicate.isInCircleNormalized(a, b, c, p);
};
TrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {
	return bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));
};
TrianglePredicate.triAreaDDFast = function (a, b, c) {
	var t1 = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(b.x).selfSubtract(a.x).selfMultiply(__WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(c.y).selfSubtract(a.y));
	var t2 = __WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(b.y).selfSubtract(a.y).selfMultiply(__WEBPACK_IMPORTED_MODULE_3__math_DD__["a" /* default */].valueOf(c.x).selfSubtract(a.x));
	return t1.selfSubtract(t2);
};


/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = QuadEdgeLocator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function QuadEdgeLocator() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(QuadEdgeLocator.prototype, {
	locate: function (v) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return QuadEdgeLocator;
	}
});


/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LocateFailureException;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inherits__ = __webpack_require__(3);




function LocateFailureException() {
	this._seg = null;
	if (arguments.length === 1) {
		if (typeof arguments[0] === "string") {
			let msg = arguments[0];
			__WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */].call(this, msg);
		} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */]) {
			let seg = arguments[0];
			__WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */].call(this, "Locate failed to converge (at edge: " + seg + ").  Possible causes include invalid Subdivision topology or very close sites");
			this._seg = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */](seg);
		}
	} else if (arguments.length === 2) {
		let msg = arguments[0], seg = arguments[1];
		__WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */].call(this, LocateFailureException.msgWithSpatial(msg, seg));
		this._seg = new __WEBPACK_IMPORTED_MODULE_1__geom_LineSegment__["a" /* default */](seg);
	}
}
Object(__WEBPACK_IMPORTED_MODULE_3__inherits__["a" /* default */])(LocateFailureException, __WEBPACK_IMPORTED_MODULE_2__java_lang_RuntimeException__["a" /* default */]);
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(LocateFailureException.prototype, {
	getSegment: function () {
		return this._seg;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LocateFailureException;
	}
});
LocateFailureException.msgWithSpatial = function (msg, seg) {
	if (seg !== null) return msg + " [ " + seg + " ]";
	return msg;
};


/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TriangleVisitor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function TriangleVisitor() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(TriangleVisitor.prototype, {
	visit: function (triEdges) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return TriangleVisitor;
	}
});


/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = KdTree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__KdNodeVisitor__ = __webpack_require__(374);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__java_util_List__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__KdNode__ = __webpack_require__(375);








function KdTree() {
	this._root = null;
	this._numberOfNodes = null;
	this._tolerance = null;
	if (arguments.length === 0) {
		KdTree.call(this, 0.0);
	} else if (arguments.length === 1) {
		let tolerance = arguments[0];
		this._tolerance = tolerance;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(KdTree.prototype, {
	insert: function () {
		if (arguments.length === 1) {
			let p = arguments[0];
			return this.insert(p, null);
		} else if (arguments.length === 2) {
			let p = arguments[0], data = arguments[1];
			if (this._root === null) {
				this._root = new __WEBPACK_IMPORTED_MODULE_7__KdNode__["a" /* default */](p, data);
				return this._root;
			}
			if (this._tolerance > 0) {
				var matchNode = this.findBestMatchNode(p);
				if (matchNode !== null) {
					matchNode.increment();
					return matchNode;
				}
			}
			return this.insertExact(p, data);
		}
	},
	query: function () {
		if (arguments.length === 1) {
			let queryEnv = arguments[0];
			var result = new __WEBPACK_IMPORTED_MODULE_3__java_util_ArrayList__["a" /* default */]();
			this.query(queryEnv, result);
			return result;
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */] && Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_6__java_util_List__["a" /* default */])) {
				let queryEnv = arguments[0], result = arguments[1];
				this.queryNode(this._root, queryEnv, true, {
					interfaces_: function () {
						return [__WEBPACK_IMPORTED_MODULE_4__KdNodeVisitor__["a" /* default */]];
					},
					visit: function (node) {
						result.add(node);
					}
				});
			} else if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */] && Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[1], __WEBPACK_IMPORTED_MODULE_4__KdNodeVisitor__["a" /* default */])) {
				let queryEnv = arguments[0], visitor = arguments[1];
				this.queryNode(this._root, queryEnv, true, visitor);
			}
		}
	},
	queryNode: function (currentNode, queryEnv, odd, visitor) {
		if (currentNode === null) return null;
		var min = null;
		var max = null;
		var discriminant = null;
		if (odd) {
			min = queryEnv.getMinX();
			max = queryEnv.getMaxX();
			discriminant = currentNode.getX();
		} else {
			min = queryEnv.getMinY();
			max = queryEnv.getMaxY();
			discriminant = currentNode.getY();
		}
		var searchLeft = min < discriminant;
		var searchRight = discriminant <= max;
		if (searchLeft) {
			this.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);
		}
		if (queryEnv.contains(currentNode.getCoordinate())) {
			visitor.visit(currentNode);
		}
		if (searchRight) {
			this.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);
		}
	},
	findBestMatchNode: function (p) {
		var visitor = new BestMatchVisitor(p, this._tolerance);
		this.query(visitor.queryEnvelope(), visitor);
		return visitor.getNode();
	},
	isEmpty: function () {
		if (this._root === null) return true;
		return false;
	},
	insertExact: function (p, data) {
		var currentNode = this._root;
		var leafNode = this._root;
		var isOddLevel = true;
		var isLessThan = true;
		while (currentNode !== null) {
			if (currentNode !== null) {
				var isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;
				if (isInTolerance) {
					currentNode.increment();
					return currentNode;
				}
			}
			if (isOddLevel) {
				isLessThan = p.x < currentNode.getX();
			} else {
				isLessThan = p.y < currentNode.getY();
			}
			leafNode = currentNode;
			if (isLessThan) {
				currentNode = currentNode.getLeft();
			} else {
				currentNode = currentNode.getRight();
			}
			isOddLevel = !isOddLevel;
		}
		this._numberOfNodes = this._numberOfNodes + 1;
		var node = new __WEBPACK_IMPORTED_MODULE_7__KdNode__["a" /* default */](p, data);
		if (isLessThan) {
			leafNode.setLeft(node);
		} else {
			leafNode.setRight(node);
		}
		return node;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return KdTree;
	}
});
KdTree.toCoordinates = function () {
	if (arguments.length === 1) {
		let kdnodes = arguments[0];
		return KdTree.toCoordinates(kdnodes, false);
	} else if (arguments.length === 2) {
		let kdnodes = arguments[0], includeRepeated = arguments[1];
		var coord = new __WEBPACK_IMPORTED_MODULE_0__geom_CoordinateList__["a" /* default */]();
		for (var it = kdnodes.iterator(); it.hasNext(); ) {
			var node = it.next();
			var count = includeRepeated ? node.getCount() : 1;
			for (var i = 0; i < count; i++) {
				coord.add(node.getCoordinate(), true);
			}
		}
		return coord.toCoordinateArray();
	}
};
function BestMatchVisitor() {
	this._tolerance = null;
	this._matchNode = null;
	this._matchDist = 0.0;
	this._p = null;
	let p = arguments[0], tolerance = arguments[1];
	this._p = p;
	this._tolerance = tolerance;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(BestMatchVisitor.prototype, {
	visit: function (node) {
		var dist = this._p.distance(node.getCoordinate());
		var isInTolerance = dist <= this._tolerance;
		if (!isInTolerance) return null;
		var update = false;
		if (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;
		if (update) {
			this._matchNode = node;
			this._matchDist = dist;
		}
	},
	queryEnvelope: function () {
		var queryEnv = new __WEBPACK_IMPORTED_MODULE_5__geom_Envelope__["a" /* default */](this._p);
		queryEnv.expandBy(this._tolerance);
		return queryEnv;
	},
	getNode: function () {
		return this._matchNode;
	},
	interfaces_: function () {
		return [__WEBPACK_IMPORTED_MODULE_4__KdNodeVisitor__["a" /* default */]];
	},
	getClass: function () {
		return BestMatchVisitor;
	}
});
KdTree.BestMatchVisitor = BestMatchVisitor;


/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = KdNodeVisitor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extend__ = __webpack_require__(0);

function KdNodeVisitor() {}
Object(__WEBPACK_IMPORTED_MODULE_0__extend__["a" /* default */])(KdNodeVisitor.prototype, {
	visit: function (node) {},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return KdNodeVisitor;
	}
});


/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = KdNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);


function KdNode() {
	this._p = null;
	this._data = null;
	this._left = null;
	this._right = null;
	this._count = null;
	if (arguments.length === 2) {
		let p = arguments[0], data = arguments[1];
		this._p = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](p);
		this._left = null;
		this._right = null;
		this._count = 1;
		this._data = data;
	} else if (arguments.length === 3) {
		let _x = arguments[0], _y = arguments[1], data = arguments[2];
		this._p = new __WEBPACK_IMPORTED_MODULE_0__geom_Coordinate__["a" /* default */](_x, _y);
		this._left = null;
		this._right = null;
		this._count = 1;
		this._data = data;
	}
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(KdNode.prototype, {
	isRepeated: function () {
		return this._count > 1;
	},
	getRight: function () {
		return this._right;
	},
	getCoordinate: function () {
		return this._p;
	},
	setLeft: function (_left) {
		this._left = _left;
	},
	getX: function () {
		return this._p.x;
	},
	getData: function () {
		return this._data;
	},
	getCount: function () {
		return this._count;
	},
	getLeft: function () {
		return this._left;
	},
	getY: function () {
		return this._p.y;
	},
	increment: function () {
		this._count = this._count + 1;
	},
	setRight: function (_right) {
		this._right = _right;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return KdNode;
	}
});


/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasInterface__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_GeometryFactory__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__IncrementalDelaunayTriangulator__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__quadedge_QuadEdgeSubdivision__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__DelaunayTriangulationBuilder__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_CoordinateArrays__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__java_util_ArrayList__ = __webpack_require__(1);










function VoronoiDiagramBuilder() {
	this._siteCoords = null;
	this._tolerance = 0.0;
	this._subdiv = null;
	this._clipEnv = null;
	this._diagramEnv = null;
}
Object(__WEBPACK_IMPORTED_MODULE_6__extend__["a" /* default */])(VoronoiDiagramBuilder.prototype, {
	create: function () {
		if (this._subdiv !== null) return null;
		var siteEnv = __WEBPACK_IMPORTED_MODULE_7__DelaunayTriangulationBuilder__["a" /* default */].envelope(this._siteCoords);
		this._diagramEnv = siteEnv;
		var expandBy = Math.max(this._diagramEnv.getWidth(), this._diagramEnv.getHeight());
		this._diagramEnv.expandBy(expandBy);
		if (this._clipEnv !== null) this._diagramEnv.expandToInclude(this._clipEnv);
		var vertices = __WEBPACK_IMPORTED_MODULE_7__DelaunayTriangulationBuilder__["a" /* default */].toVertices(this._siteCoords);
		this._subdiv = new __WEBPACK_IMPORTED_MODULE_5__quadedge_QuadEdgeSubdivision__["a" /* default */](siteEnv, this._tolerance);
		var triangulator = new __WEBPACK_IMPORTED_MODULE_4__IncrementalDelaunayTriangulator__["a" /* default */](this._subdiv);
		triangulator.insertSites(vertices);
	},
	getDiagram: function (geomFact) {
		this.create();
		var polys = this._subdiv.getVoronoiDiagram(geomFact);
		return VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);
	},
	setTolerance: function (tolerance) {
		this._tolerance = tolerance;
	},
	setSites: function () {
		if (arguments[0] instanceof __WEBPACK_IMPORTED_MODULE_0__geom_Geometry__["a" /* default */]) {
			let geom = arguments[0];
			this._siteCoords = __WEBPACK_IMPORTED_MODULE_7__DelaunayTriangulationBuilder__["a" /* default */].extractUniqueCoordinates(geom);
		} else if (Object(__WEBPACK_IMPORTED_MODULE_1__hasInterface__["a" /* default */])(arguments[0], __WEBPACK_IMPORTED_MODULE_3__java_util_Collection__["a" /* default */])) {
			let coords = arguments[0];
			this._siteCoords = __WEBPACK_IMPORTED_MODULE_7__DelaunayTriangulationBuilder__["a" /* default */].unique(__WEBPACK_IMPORTED_MODULE_8__geom_CoordinateArrays__["a" /* default */].toCoordinateArray(coords));
		}
	},
	setClipEnvelope: function (clipEnv) {
		this._clipEnv = clipEnv;
	},
	getSubdivision: function () {
		this.create();
		return this._subdiv;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return VoronoiDiagramBuilder;
	}
});
VoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {
	var clipPoly = geom.getFactory().toGeometry(clipEnv);
	var clipped = new __WEBPACK_IMPORTED_MODULE_9__java_util_ArrayList__["a" /* default */]();
	for (var i = 0; i < geom.getNumGeometries(); i++) {
		var g = geom.getGeometryN(i);
		var result = null;
		if (clipEnv.contains(g.getEnvelopeInternal())) result = g; else if (clipEnv.intersects(g.getEnvelopeInternal())) {
			result = clipPoly.intersection(g);
			result.setUserData(g.getUserData());
		}
		if (result !== null && !result.isEmpty()) {
			clipped.add(result);
		}
	}
	return geom.getFactory().createGeometryCollection(__WEBPACK_IMPORTED_MODULE_2__geom_GeometryFactory__["a" /* default */].toGeometryArray(clipped));
};


/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__quadedge_Vertex__ = __webpack_require__(84);
/* unused harmony reexport Vertex */





/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__linearref_LengthIndexedLine__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linearref_LengthLocationMap__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__linearref_LinearGeometryBuilder__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__linearref_LinearIterator__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__linearref_LinearLocation__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__linearref_LocationIndexedLine__ = __webpack_require__(169);
/* unused harmony reexport LengthIndexedLine */
/* unused harmony reexport LengthLocationMap */
/* unused harmony reexport LinearGeometryBuilder */
/* unused harmony reexport LinearIterator */
/* unused harmony reexport LinearLocation */
/* unused harmony reexport LocationIndexedLine */










/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LocationIndexedLine__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LengthIndexOfPoint__ = __webpack_require__(380);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LocationIndexOfLine__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ExtractLineByLocation__ = __webpack_require__(172);






function LengthIndexedLine() {
	this._linearGeom = null;
	let linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(LengthIndexedLine.prototype, {
	clampIndex: function (index) {
		var posIndex = this.positiveIndex(index);
		var startIndex = this.getStartIndex();
		if (posIndex < startIndex) return startIndex;
		var endIndex = this.getEndIndex();
		if (posIndex > endIndex) return endIndex;
		return posIndex;
	},
	locationOf: function () {
		if (arguments.length === 1) {
			let index = arguments[0];
			return __WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__["a" /* default */].getLocation(this._linearGeom, index);
		} else if (arguments.length === 2) {
			let index = arguments[0], resolveLower = arguments[1];
			return __WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__["a" /* default */].getLocation(this._linearGeom, index, resolveLower);
		}
	},
	project: function (pt) {
		return __WEBPACK_IMPORTED_MODULE_2__LengthIndexOfPoint__["a" /* default */].indexOf(this._linearGeom, pt);
	},
	positiveIndex: function (index) {
		if (index >= 0.0) return index;
		return this._linearGeom.getLength() + index;
	},
	extractPoint: function () {
		if (arguments.length === 1) {
			let index = arguments[0];
			var loc = __WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__["a" /* default */].getLocation(this._linearGeom, index);
			return loc.getCoordinate(this._linearGeom);
		} else if (arguments.length === 2) {
			let index = arguments[0], offsetDistance = arguments[1];
			var loc = __WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__["a" /* default */].getLocation(this._linearGeom, index);
			var locLow = loc.toLowest(this._linearGeom);
			return locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);
		}
	},
	isValidIndex: function (index) {
		return index >= this.getStartIndex() && index <= this.getEndIndex();
	},
	getEndIndex: function () {
		return this._linearGeom.getLength();
	},
	getStartIndex: function () {
		return 0.0;
	},
	indexOfAfter: function (pt, minIndex) {
		return __WEBPACK_IMPORTED_MODULE_2__LengthIndexOfPoint__["a" /* default */].indexOfAfter(this._linearGeom, pt, minIndex);
	},
	extractLine: function (startIndex, endIndex) {
		var lil = new __WEBPACK_IMPORTED_MODULE_0__LocationIndexedLine__["a" /* default */](this._linearGeom);
		var startIndex2 = this.clampIndex(startIndex);
		var endIndex2 = this.clampIndex(endIndex);
		var resolveStartLower = startIndex2 === endIndex2;
		var startLoc = this.locationOf(startIndex2, resolveStartLower);
		var endLoc = this.locationOf(endIndex2);
		return __WEBPACK_IMPORTED_MODULE_5__ExtractLineByLocation__["a" /* default */].extract(this._linearGeom, startLoc, endLoc);
	},
	indexOf: function (pt) {
		return __WEBPACK_IMPORTED_MODULE_2__LengthIndexOfPoint__["a" /* default */].indexOf(this._linearGeom, pt);
	},
	indicesOf: function (subLine) {
		var locIndex = __WEBPACK_IMPORTED_MODULE_3__LocationIndexOfLine__["a" /* default */].indicesOf(this._linearGeom, subLine);
		var index = [__WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__["a" /* default */].getLength(this._linearGeom, locIndex[0]), __WEBPACK_IMPORTED_MODULE_4__LengthLocationMap__["a" /* default */].getLength(this._linearGeom, locIndex[1])];
		return index;
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LengthIndexedLine;
	}
});


/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = LengthIndexOfPoint;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LinearIterator__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extend__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Assert__ = __webpack_require__(4);





function LengthIndexOfPoint() {
	this._linearGeom = null;
	let linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
Object(__WEBPACK_IMPORTED_MODULE_2__extend__["a" /* default */])(LengthIndexOfPoint.prototype, {
	indexOf: function (inputPt) {
		return this.indexOfFromStart(inputPt, -1.0);
	},
	indexOfFromStart: function (inputPt, minIndex) {
		var minDistance = __WEBPACK_IMPORTED_MODULE_1__java_lang_Double__["a" /* default */].MAX_VALUE;
		var ptMeasure = minIndex;
		var segmentStartMeasure = 0.0;
		var seg = new __WEBPACK_IMPORTED_MODULE_3__geom_LineSegment__["a" /* default */]();
		var it = new __WEBPACK_IMPORTED_MODULE_0__LinearIterator__["a" /* default */](this._linearGeom);
		while (it.hasNext()) {
			if (!it.isEndOfLine()) {
				seg.p0 = it.getSegmentStart();
				seg.p1 = it.getSegmentEnd();
				var segDistance = seg.distance(inputPt);
				var segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);
				if (segDistance < minDistance && segMeasureToPt > minIndex) {
					ptMeasure = segMeasureToPt;
					minDistance = segDistance;
				}
				segmentStartMeasure += seg.getLength();
			}
			it.next();
		}
		return ptMeasure;
	},
	indexOfAfter: function (inputPt, minIndex) {
		if (minIndex < 0.0) return this.indexOf(inputPt);
		var endIndex = this._linearGeom.getLength();
		if (endIndex < minIndex) return endIndex;
		var closestAfter = this.indexOfFromStart(inputPt, minIndex);
		__WEBPACK_IMPORTED_MODULE_4__util_Assert__["a" /* default */].isTrue(closestAfter >= minIndex, "computed index is before specified minimum index");
		return closestAfter;
	},
	segmentNearestMeasure: function (seg, inputPt, segmentStartMeasure) {
		var projFactor = seg.projectionFactor(inputPt);
		if (projFactor <= 0.0) return segmentStartMeasure;
		if (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();
		return segmentStartMeasure + seg.getLength();
	},
	interfaces_: function () {
		return [];
	},
	getClass: function () {
		return LengthIndexOfPoint;
	}
});
LengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {
	var locater = new LengthIndexOfPoint(linearGeom);
	return locater.indexOf(inputPt);
};
LengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {
	var locater = new LengthIndexOfPoint(linearGeom);
	return locater.indexOfAfter(inputPt, minIndex);
};


/***/ }),
/* 381 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_invariant__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_helpers__ = __webpack_require__(70);



/**
 * Returns true if a point is on a line. Accepts a optional parameter to ignore the start and end vertices of the linestring.
 *
 * @name booleanPointOnLine
 * @param {Coord} pt GeoJSON Point
 * @param {Feature<LineString>} line GeoJSON LineString
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.
 * @returns {boolean} true/false
 * @example
 * var pt = turf.point([0, 0]);
 * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
 * var isPointOnLine = turf.booleanPointOnLine(pt, line);
 * //=true
 */
function booleanPointOnLine(pt, line, options) {
    // Optional parameters
    options = options || {};
    var ignoreEndVertices = options.ignoreEndVertices;
    if (!Object(__WEBPACK_IMPORTED_MODULE_1__turf_helpers__["isObject"])(options)) throw new Error('invalid options');

    // Validate input
    if (!pt) throw new Error('pt is required');
    if (!line) throw new Error('line is required');

    // Normalize inputs
    var ptCoords = Object(__WEBPACK_IMPORTED_MODULE_0__turf_invariant__["a" /* getCoord */])(pt);
    var lineCoords = Object(__WEBPACK_IMPORTED_MODULE_0__turf_invariant__["b" /* getCoords */])(line);

    // Main
    for (var i = 0; i < lineCoords.length - 1; i++) {
        var ignoreBoundary = false;
        if (ignoreEndVertices) {
            if (i === 0) ignoreBoundary = 'start';
            if (i === lineCoords.length - 2) ignoreBoundary = 'end';
            if (i === 0 && i + 1 === lineCoords.length - 1) ignoreBoundary = 'both';
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) return true;
    }
    return false;
}

// See http://stackoverflow.com/a/4833823/1979085
/**
 * @private
 * @param {Array<number>} lineSegmentStart coord pair of start of line
 * @param {Array<number>} lineSegmentEnd coord pair of end of line
 * @param {Array<number>} pt coord pair of point to check
 * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends. If true which end to ignore.
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {
    var x = pt[0];
    var y = pt[1];
    var x1 = lineSegmentStart[0];
    var y1 = lineSegmentStart[1];
    var x2 = lineSegmentEnd[0];
    var y2 = lineSegmentEnd[1];
    var dxc = pt[0] - x1;
    var dyc = pt[1] - y1;
    var dxl = x2 - x1;
    var dyl = y2 - y1;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    } else if (excludeBoundary === 'start') {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    } else if (excludeBoundary === 'end') {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    } else if (excludeBoundary === 'both') {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (booleanPointOnLine);


/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getCoord;
/* harmony export (immutable) */ __webpack_exports__["b"] = getCoords;
/* unused harmony export containsNumber */
/* unused harmony export geojsonType */
/* unused harmony export featureOf */
/* unused harmony export collectionOf */
/* unused harmony export getGeom */
/* unused harmony export getGeomType */
/* unused harmony export getType */
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(obj) {
    if (!obj) throw new Error('obj is required');

    var coordinates = getCoords(obj);

    // getCoord() must contain at least two numbers (Point)
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return coordinates;
    } else {
        throw new Error('Coordinate is not a valid Point');
    }
}

/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers
 *
 * @name getCoords
 * @param {Array<number>|Geometry|Feature} obj Object
 * @returns {Array<number>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coord = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(obj) {
    if (!obj) throw new Error('obj is required');
    var coordinates;

    // Array of numbers
    if (obj.length) {
        coordinates = obj;

    // Geometry Object
    } else if (obj.coordinates) {
        coordinates = obj.coordinates;

    // Feature
    } else if (obj.geometry && obj.geometry.coordinates) {
        coordinates = obj.geometry.coordinates;
    }
    // Checks if coordinates contains a number
    if (coordinates) {
        containsNumber(coordinates);
        return coordinates;
    }
    throw new Error('No valid coordinates');
}

/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return true;
    }

    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error('coordinates must only contain numbers');
}

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) throw new Error('No feature passed');
    if (!name) throw new Error('.featureOf() requires a name');
    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) throw new Error('No featureCollection passed');
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < featureCollection.features.length; i++) {
        var feature = featureCollection.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (!geojson) throw new Error('geojson is required');
    if (geojson.geometry !== undefined) return geojson.geometry;
    if (geojson.coordinates || geojson.geometries) return geojson;
    throw new Error('geojson must be a valid Feature or Geometry Object');
}

/**
 * Get Geometry Type from Feature or Geometry Object
 *
 * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType
 */
function getGeomType() {
    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');
}

/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name] name of the variable to display in error message
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, name) {
    if (!geojson) throw new Error((name || 'geojson') + ' is required');
    // GeoJSON Feature & GeometryCollection
    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;
    // GeoJSON Geometry & FeatureCollection
    if (geojson.type) return geojson.type;
    throw new Error((name || 'geojson') + ' is invalid');
}


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Packaging/modules magic dance.
(function (factory) {
    var L;
    if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(110)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        L = require('leaflet');
        module.exports = factory(L);
    } else {
        // Browser globals
        if (typeof window.L === 'undefined')
            throw 'Leaflet must be loaded first';
        factory(window.L);
    }
}(function (L) {
"use strict";

L.Polyline._flat = L.Polyline._flat || function (latlngs) {
    // true if it's a flat array of latlngs; false if nested
    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};

/**
 * @fileOverview Leaflet Geometry utilities for distances and linear referencing.
 * @name L.GeometryUtil
 */

L.GeometryUtil = L.extend(L.GeometryUtil || {}, {

    /**
        Shortcut function for planar distance between two {L.LatLng} at current zoom.

        @tutorial distance-length

        @param {L.Map} map Leaflet map to be used for this method
        @param {L.LatLng} latlngA geographical point A
        @param {L.LatLng} latlngB geographical point B
        @returns {Number} planar distance
     */
    distance: function (map, latlngA, latlngB) {
        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));
    },

    /**
        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).
        @param {L.Map} map Leaflet map to be used for this method
        @param {L.LatLng} latlng - The position to search
        @param {L.LatLng} latlngA geographical point A of the segment
        @param {L.LatLng} latlngB geographical point B of the segment
        @returns {Number} planar distance
    */
    distanceSegment: function (map, latlng, latlngA, latlngB) {
        var p = map.latLngToLayerPoint(latlng),
           p1 = map.latLngToLayerPoint(latlngA),
           p2 = map.latLngToLayerPoint(latlngB);
        return L.LineUtil.pointToSegmentDistance(p, p1, p2);
    },

    /**
        Shortcut function for converting distance to readable distance.
        @param {Number} distance distance to be converted
        @param {String} unit 'metric' or 'imperial'
        @returns {String} in yard or miles
    */
    readableDistance: function (distance, unit) {
        var isMetric = (unit !== 'imperial'),
            distanceStr;
        if (isMetric) {
            // show metres when distance is < 1km, then show km
            if (distance > 1000) {
                distanceStr = (distance  / 1000).toFixed(2) + ' km';
            }
            else {
                distanceStr = Math.ceil(distance) + ' m';
            }
        }
        else {
            distance *= 1.09361;
            if (distance > 1760) {
                distanceStr = (distance / 1760).toFixed(2) + ' miles';
            }
            else {
                distanceStr = Math.ceil(distance) + ' yd';
            }
        }
        return distanceStr;
    },

    /**
        Returns true if the latlng belongs to segment A-B
        @param {L.LatLng} latlng - The position to search
        @param {L.LatLng} latlngA geographical point A of the segment
        @param {L.LatLng} latlngB geographical point B of the segment
        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really
        @returns {boolean}
     */
    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {
        tolerance = tolerance === undefined ? 0.2 : tolerance;
        var hypotenuse = latlngA.distanceTo(latlngB),
            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;
        return delta/hypotenuse < tolerance;
    },

    /**
     * Returns total length of line
     * @tutorial distance-length
     *
     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates
     * @returns {Number} Total length (pixels for Point, meters for LatLng)
     */
    length: function (coords) {
        var accumulated = L.GeometryUtil.accumulatedLengths(coords);
        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;
    },

    /**
     * Returns a list of accumulated length along a line.
     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates
     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)
     */
    accumulatedLengths: function (coords) {
        if (typeof coords.getLatLngs == 'function') {
            coords = coords.getLatLngs();
        }
        if (coords.length === 0)
            return [];
        var total = 0,
            lengths = [0];
        for (var i = 0, n = coords.length - 1; i< n; i++) {
            total += coords[i].distanceTo(coords[i+1]);
            lengths.push(total);
        }
        return lengths;
    },

    /**
        Returns the closest point of a {L.LatLng} on the segment (A-B)

        @tutorial closest

        @param {L.Map} map Leaflet map to be used for this method
        @param {L.LatLng} latlng - The position to search
        @param {L.LatLng} latlngA geographical point A of the segment
        @param {L.LatLng} latlngB geographical point B of the segment
        @returns {L.LatLng} Closest geographical point
    */
    closestOnSegment: function (map, latlng, latlngA, latlngB) {
        var maxzoom = map.getMaxZoom();
        if (maxzoom === Infinity)
            maxzoom = map.getZoom();
        var p = map.project(latlng, maxzoom),
           p1 = map.project(latlngA, maxzoom),
           p2 = map.project(latlngB, maxzoom),
           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);
        return map.unproject(closest, maxzoom);
    },

    /**
        Returns the closest latlng on layer.

        Accept nested arrays

        @tutorial closest

        @param {L.Map} map Leaflet map to be used for this method
        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result
        @param {L.LatLng} latlng - The position to search
        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.
        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect
    */
    closest: function (map, layer, latlng, vertices) {

        var latlngs,
            mindist = Infinity,
            result = null,
            i, n, distance;

        if (layer instanceof Array) {
            // if layer is Array<Array<T>>
            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {
                // if we have nested arrays, we calc the closest for each array
                // recursive
                for (var i = 0; i < layer.length; i++) {
                    var subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);
                    if (subResult.distance < mindist) {
                        mindist = subResult.distance;
                        result = subResult;
                    }
                }
                return result;
            } else if (layer[0] instanceof L.LatLng
                        || typeof layer[0][0] === 'number'
                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}
                layer = L.polyline(layer);
            } else {
                return result;
            }
        }

        // if we don't have here a Polyline, that means layer is incorrect
        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23
        if (! ( layer instanceof L.Polyline ) )
            return result;

        // deep copy of latlngs
        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));

        // add the last segment for L.Polygon
        if (layer instanceof L.Polygon) {
            // add the last segment for each child that is a nested array
            var addLastSegment = function(latlngs) {
                if (L.Polyline._flat(latlngs)) {
                    latlngs.push(latlngs[0]);
                } else {
                    for (var i = 0; i < latlngs.length; i++) {
                        addLastSegment(latlngs[i]);
                    }
                }
            }
            addLastSegment(latlngs);
        }

        // we have a multi polygon / multi polyline / polygon with holes
        // use recursive to explore and return the good result
        if ( ! L.Polyline._flat(latlngs) ) {

            for (var i = 0; i < latlngs.length; i++) {
                // if we are at the lower level, and if we have a L.Polygon, we add the last segment
                var subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);
                if (subResult.distance < mindist) {
                    mindist = subResult.distance;
                    result = subResult;
                }
            }
            return result;

        } else {

            // Lookup vertices
            if (vertices) {
                for(i = 0, n = latlngs.length; i < n; i++) {
                    var ll = latlngs[i];
                    distance = L.GeometryUtil.distance(map, latlng, ll);
                    if (distance < mindist) {
                        mindist = distance;
                        result = ll;
                        result.distance = distance;
                    }
                }
                return result;
            }

            // Keep the closest point of all segments
            for (i = 0, n = latlngs.length; i < n-1; i++) {
                var latlngA = latlngs[i],
                    latlngB = latlngs[i+1];
                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);
                if (distance <= mindist) {
                    mindist = distance;
                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);
                    result.distance = distance;
                }
            }
            return result;
        }

    },

    /**
        Returns the closest layer to latlng among a list of layers.

        @tutorial closest

        @param {L.Map} map Leaflet map to be used for this method
        @param {Array<L.ILayer>} layers Set of layers
        @param {L.LatLng} latlng - The position to search
        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;
    */
    closestLayer: function (map, layers, latlng) {
        var mindist = Infinity,
            result = null,
            ll = null,
            distance = Infinity;

        for (var i = 0, n = layers.length; i < n; i++) {
            var layer = layers[i];
            if (layer instanceof L.LayerGroup) {
                // recursive
                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);
                if (subResult.distance < mindist) {
                    mindist = subResult.distance;
                    result = subResult;
                }
            } else {
                // Single dimension, snap on points, else snap on closest
                if (typeof layer.getLatLng == 'function') {
                    ll = layer.getLatLng();
                    distance = L.GeometryUtil.distance(map, latlng, ll);
                }
                else {
                    ll = L.GeometryUtil.closest(map, layer, latlng);
                    if (ll) distance = ll.distance;  // Can return null if layer has no points.
                }
                if (distance < mindist) {
                    mindist = distance;
                    result = {layer: layer, latlng: ll, distance: distance};
                }
            }
        }
        return result;
    },

    /**
        Returns the n closest layers to latlng among a list of input layers.

        @param {L.Map} map - Leaflet map to be used for this method
        @param {Array<L.ILayer>} layers - Set of layers
        @param {L.LatLng} latlng - The position to search
        @param {?Number} [n=layers.length] - the expected number of output layers.
        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)
    */
    nClosestLayers: function (map, layers, latlng, n) {
        n = typeof n === 'number' ? n : layers.length;

        if (n < 1 || layers.length < 1) {
            return null;
        }

        var results = [];
        var distance, ll;

        for (var i = 0, m = layers.length; i < m; i++) {
            var layer = layers[i];
            if (layer instanceof L.LayerGroup) {
                // recursive
                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);
                results.push(subResult)
            } else {
                // Single dimension, snap on points, else snap on closest
                if (typeof layer.getLatLng == 'function') {
                    ll = layer.getLatLng();
                    distance = L.GeometryUtil.distance(map, latlng, ll);
                }
                else {
                    ll = L.GeometryUtil.closest(map, layer, latlng);
                    if (ll) distance = ll.distance;  // Can return null if layer has no points.
                }
                results.push({layer: layer, latlng: ll, distance: distance})
            }
        }

        results.sort(function(a, b) {
            return a.distance - b.distance;
        });

        if (results.length > n) {
            return results.slice(0, n);
        } else  {
            return results;
        }
    },

    /**
     * Returns all layers within a radius of the given position, in an ascending order of distance.
       @param {L.Map} map Leaflet map to be used for this method
       @param {Array<ILayer>} layers - A list of layers.
       @param {L.LatLng} latlng - The position to search
       @param {?Number} [radius=Infinity] - Search radius in pixels
       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance
     */
    layersWithin: function(map, layers, latlng, radius) {
      radius = typeof radius == 'number' ? radius : Infinity;

      var results = [];
      var ll = null;
      var distance = 0;

      for (var i = 0, n = layers.length; i < n; i++) {
        var layer = layers[i];

        if (typeof layer.getLatLng == 'function') {
            ll = layer.getLatLng();
            distance = L.GeometryUtil.distance(map, latlng, ll);
        }
        else {
            ll = L.GeometryUtil.closest(map, layer, latlng);
            if (ll) distance = ll.distance;  // Can return null if layer has no points.
        }

        if (ll && distance < radius) {
            results.push({layer: layer, latlng: ll, distance: distance});
        }
      }

      var sortedResults = results.sort(function(a, b) {
          return a.distance - b.distance;
      });

      return sortedResults;
    },

    /**
        Returns the closest position from specified {LatLng} among specified layers,
        with a maximum tolerance in pixels, providing snapping behaviour.

        @tutorial closest

        @param {L.Map} map Leaflet map to be used for this method
        @param {Array<ILayer>} layers - A list of layers to snap on.
        @param {L.LatLng} latlng - The position to snap
        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.
        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)
        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.
    */
    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {
        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;
        withVertices = typeof withVertices == 'boolean' ? withVertices : true;

        var result = L.GeometryUtil.closestLayer(map, layers, latlng);
        if (!result || result.distance > tolerance)
            return null;

        // If snapped layer is linear, try to snap on vertices (extremities and middle points)
        if (withVertices && typeof result.layer.getLatLngs == 'function') {
            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);
            if (closest.distance < tolerance) {
                result.latlng = closest;
                result.distance = L.GeometryUtil.distance(map, closest, latlng);
            }
        }
        return result;
    },

    /**
        Returns the Point located on a segment at the specified ratio of the segment length.
        @param {L.Point} pA coordinates of point A
        @param {L.Point} pB coordinates of point B
        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.
        @returns {L.Point} the interpolated point.
    */
    interpolateOnPointSegment: function (pA, pB, ratio) {
        return L.point(
            (pA.x * (1 - ratio)) + (ratio * pB.x),
            (pA.y * (1 - ratio)) + (ratio * pB.y)
        );
    },

    /**
        Returns the coordinate of the point located on a line at the specified ratio of the line length.
        @param {L.Map} map Leaflet map to be used for this method
        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points
        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive
        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline
        (-1 if the interpolated point is the first vertex)
    */
    interpolateOnLine: function (map, latLngs, ratio) {
        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;
        var n = latLngs.length;
        if (n < 2) {
            return null;
        }

        // ensure the ratio is between 0 and 1;
        ratio = Math.max(Math.min(ratio, 1), 0);

        if (ratio === 0) {
            return {
                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),
                predecessor: -1
            };
        }
        if (ratio == 1) {
            return {
                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),
                predecessor: latLngs.length - 2
            };
        }

        // project the LatLngs as Points,
        // and compute total planar length of the line at max precision
        var maxzoom = map.getMaxZoom();
        if (maxzoom === Infinity)
            maxzoom = map.getZoom();
        var pts = [];
        var lineLength = 0;
        for(var i = 0; i < n; i++) {
            pts[i] = map.project(latLngs[i], maxzoom);
            if(i > 0)
              lineLength += pts[i-1].distanceTo(pts[i]);
        }

        var ratioDist = lineLength * ratio;
        var a = pts[0],
            b = pts[1],
            distA = 0,
            distB = a.distanceTo(b);
        // follow the line segments [ab], adding lengths,
        // until we find the segment where the points should lie on
        var index = 1;
        for (; index < n && distB < ratioDist; index++) {
            a = b;
            distA = distB;
            b = pts[index];
            distB += a.distanceTo(b);
        }
        // compute the ratio relative to the segment [ab]
        var segmentRatio = ((distB - distA) !== 0) ? ((ratioDist - distA) / (distB - distA)) : 0;
        var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(a, b, segmentRatio);
        return {
            latLng: map.unproject(interpolatedPoint, maxzoom),
            predecessor: index-2
        };
    },

    /**
        Returns a float between 0 and 1 representing the location of the
        closest point on polyline to the given latlng, as a fraction of total line length.
        (opposite of L.GeometryUtil.interpolateOnLine())
        @param {L.Map} map Leaflet map to be used for this method
        @param {L.PolyLine} polyline Polyline on which the latlng will be search
        @param {L.LatLng} latlng The position to search
        @returns {Number} Float between 0 and 1
    */
    locateOnLine: function (map, polyline, latlng) {
        var latlngs = polyline.getLatLngs();
        if (latlng.equals(latlngs[0]))
            return 0.0;
        if (latlng.equals(latlngs[latlngs.length-1]))
            return 1.0;

        var point = L.GeometryUtil.closest(map, polyline, latlng, false),
            lengths = L.GeometryUtil.accumulatedLengths(latlngs),
            total_length = lengths[lengths.length-1],
            portion = 0,
            found = false;
        for (var i=0, n = latlngs.length-1; i < n; i++) {
            var l1 = latlngs[i],
                l2 = latlngs[i+1];
            portion = lengths[i];
            if (L.GeometryUtil.belongsSegment(point, l1, l2)) {
                portion += l1.distanceTo(point);
                found = true;
                break;
            }
        }
        if (!found) {
            throw "Could not interpolate " + latlng.toString() + " within " + polyline.toString();
        }
        return portion / total_length;
    },

    /**
        Returns a clone with reversed coordinates.
        @param {L.PolyLine} polyline polyline to reverse
        @returns {L.PolyLine} polyline reversed
    */
    reverse: function (polyline) {
        return L.polyline(polyline.getLatLngs().slice(0).reverse());
    },

    /**
        Returns a sub-part of the polyline, from start to end.
        If start is superior to end, returns extraction from inverted line.
        @param {L.Map} map Leaflet map to be used for this method
        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part
        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive
        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive
        @returns {Array<L.LatLng>} new polyline
     */
    extract: function (map, polyline, start, end) {
        if (start > end) {
            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);
        }

        // Bound start and end to [0-1]
        start = Math.max(Math.min(start, 1), 0);
        end = Math.max(Math.min(end, 1), 0);

        var latlngs = polyline.getLatLngs(),
            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),
            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);
        // Return single point if start == end
        if (start == end) {
            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);
            return [point.latLng];
        }
        // Array.slice() works indexes at 0
        if (startpoint.predecessor == -1)
            startpoint.predecessor = 0;
        if (endpoint.predecessor == -1)
            endpoint.predecessor = 0;
        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);
        result.unshift(startpoint.latLng);
        result.push(endpoint.latLng);
        return result;
    },

    /**
        Returns true if first polyline ends where other second starts.
        @param {L.PolyLine} polyline First polyline
        @param {L.PolyLine} other Second polyline
        @returns {bool}
    */
    isBefore: function (polyline, other) {
        if (!other) return false;
        var lla = polyline.getLatLngs(),
            llb = other.getLatLngs();
        return (lla[lla.length-1]).equals(llb[0]);
    },

    /**
        Returns true if first polyline starts where second ends.
        @param {L.PolyLine} polyline First polyline
        @param {L.PolyLine} other Second polyline
        @returns {bool}
    */
    isAfter: function (polyline, other) {
        if (!other) return false;
        var lla = polyline.getLatLngs(),
            llb = other.getLatLngs();
        return (lla[0]).equals(llb[llb.length-1]);
    },

    /**
        Returns true if first polyline starts where second ends or start.
        @param {L.PolyLine} polyline First polyline
        @param {L.PolyLine} other Second polyline
        @returns {bool}
    */
    startsAtExtremity: function (polyline, other) {
        if (!other) return false;
        var lla = polyline.getLatLngs(),
            llb = other.getLatLngs(),
            start = lla[0];
        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);
    },

    /**
        Returns horizontal angle in degres between two points.
        @param {L.Point} a Coordinates of point A
        @param {L.Point} b Coordinates of point B
        @returns {Number} horizontal angle
     */
    computeAngle: function(a, b) {
        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);
    },

    /**
       Returns slope (Ax+B) between two points.
        @param {L.Point} a Coordinates of point A
        @param {L.Point} b Coordinates of point B
        @returns {Object} with ``a`` and ``b`` properties.
     */
    computeSlope: function(a, b) {
        var s = (b.y - a.y) / (b.x - a.x),
            o = a.y - (s * a.x);
        return {'a': s, 'b': o};
    },

    /**
       Returns LatLng of rotated point around specified LatLng center.
        @param {L.LatLng} latlngPoint: point to rotate
        @param {double} angleDeg: angle to rotate in degrees
        @param {L.LatLng} latlngCenter: center of rotation
        @returns {L.LatLng} rotated point
     */
    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {
        var maxzoom = map.getMaxZoom();
        if (maxzoom === Infinity)
            maxzoom = map.getZoom();
        var angleRad = angleDeg*Math.PI/180,
            pPoint = map.project(latlngPoint, maxzoom),
            pCenter = map.project(latlngCenter, maxzoom),
            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,
            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;
        return map.unproject(new L.Point(x2,y2), maxzoom);
    },

    /**
       Returns the bearing in degrees clockwise from north (0 degrees)
       from the first L.LatLng to the second, at the first LatLng
       @param {L.LatLng} latlng1: origin point of the bearing
       @param {L.LatLng} latlng2: destination point of the bearing
       @returns {float} degrees clockwise from north.
    */
    bearing: function(latlng1, latlng2) {
        var rad = Math.PI / 180,
            lat1 = latlng1.lat * rad,
            lat2 = latlng2.lat * rad,
            lon1 = latlng1.lng * rad,
            lon2 = latlng2.lng * rad,
            y = Math.sin(lon2 - lon1) * Math.cos(lat2),
            x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
        return bearing >= 180 ? bearing-360 : bearing;
    },

    /**
       Returns the point that is a distance and heading away from
       the given origin point.
       @param {L.LatLng} latlng: origin point
       @param {float}: heading in degrees, clockwise from 0 degrees north.
       @param {float}: distance in meters
       @returns {L.latLng} the destination point.
       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html
       for a great reference and examples.
    */
    destination: function(latlng, heading, distance) {
        heading = (heading + 360) % 360;
        var rad = Math.PI / 180,
            radInv = 180 / Math.PI,
            R = 6378137, // approximation of Earth's radius
            lon1 = latlng.lng * rad,
            lat1 = latlng.lat * rad,
            rheading = heading * rad,
            sinLat1 = Math.sin(lat1),
            cosLat1 = Math.cos(lat1),
            cosDistR = Math.cos(distance / R),
            sinDistR = Math.sin(distance / R),
            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *
                sinDistR * Math.cos(rheading)),
            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *
                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));
        lon2 = lon2 * radInv;
        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;
        return L.latLng([lat2 * radInv, lon2]);
    }
});

return L.GeometryUtil;

}));


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

var turf, turfFlip;

turf = __webpack_require__(70);

turfFlip = __webpack_require__(385);

L.Polygon.include({
  toTurfFeature: function() {
    var coords, multi, ring0;
    if (this.isEmpty() || !this._latlngs) {
      return;
    }
    multi = !L.LineUtil.isFlat(this._latlngs[0]);
    ring0 = multi ? this._latlngs[0][0] : this._latlngs[0];
    coords = L.GeoJSON.latLngsToCoords(ring0, 0, true);
    return turf.polygon([coords]);
  },
  outerRingAsTurfLineString: function() {
    var coords, multi, ring0;
    multi = !L.LineUtil.isFlat(this._latlngs[0]);
    ring0 = multi ? this._latlngs[0][0] : this._latlngs[0];
    coords = L.GeoJSON.latLngsToCoords(ring0, 0, true);
    return turf.lineString(coords);
  }
});

L.LatLng.prototype.toTurfFeature = function() {
  var coords;
  coords = L.GeoJSON.latLngToCoords(this);
  return turf.point(coords);
};

L.Polyline.include({
  merge: function(polyline) {
    var i, latLng, latLngs, len, results;
    latLngs = polyline.getLatLngs();
    if (!latLngs.length) {
      return;
    }
    results = [];
    for (i = 0, len = latLngs.length; i < len; i++) {
      latLng = latLngs[i];
      results.push(this.addLatLng(latLng));
    }
    return results;
  },
  toTurfFeature: function() {
    var coords;
    if (this.isEmpty() || !this._latlngs) {
      return;
    }
    coords = L.GeoJSON.latLngsToCoords(this._latlngs, 0);
    return turf.lineString(coords);
  },
  fromTurfFeature: function(feature) {
    return this.setLatLngs(turfFlip(feature).geometry.coordinates);
  }
});


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

var coordEach = __webpack_require__(386).coordEach;

/**
 * Takes input features and flips all of their coordinates from `[x, y]` to `[y, x]`.
 *
 * @name flip
 * @param {FeatureCollection|Feature<any>} geojson input features
 * @param {boolean} [mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {FeatureCollection|Feature<any>} a feature or set of features of the same type as `input` with flipped coordinates
 * @example
 * var serbia = turf.point([20.566406, 43.421008]);
 *
 * var saudiArabia = turf.flip(serbia);
 *
 * //addToMap
 * var addToMap = [serbia, saudiArabia];
 */
module.exports = function (geojson, mutate) {
    if (!geojson) throw new Error('geojson is required');
    // ensure that we don't modify features in-place and changes to the
    // output do not change the previous feature, including changes to nested
    // properties.
    if (mutate === false || mutate === undefined) geojson = JSON.parse(JSON.stringify(geojson));

    coordEach(geojson, function (coord) {
        var x = coord[0];
        var y = coord[1];
        coord[0] = y;
        coord[1] = x;
    });
    return geojson;
};


/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["feature"] = feature;
/* harmony export (immutable) */ __webpack_exports__["lineString"] = lineString;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/**
 * GeoJSON BBox
 *
 * @private
 * @typedef {[number, number, number, number]} BBox
 */

/**
 * GeoJSON Id
 *
 * @private
 * @typedef {(number|string)} Id
 */

/**
 * GeoJSON FeatureCollection
 *
 * @private
 * @typedef {Object} FeatureCollection
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {Feature[]} features
 */

/**
 * GeoJSON Feature
 *
 * @private
 * @typedef {Object} Feature
 * @property {string} type
 * @property {?Id} id
 * @property {?BBox} bbox
 * @property {*} properties
 * @property {Geometry} geometry
 */

/**
 * GeoJSON Geometry
 *
 * @private
 * @typedef {Object} Geometry
 * @property {string} type
 * @property {any[]} coordinates
 */

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
            var featureSubIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                callback(coords, coordIndex, featureIndex, featureSubIndex);
                coordIndex++;
                featureSubIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                    coordIndex++;
                    if (geomType === 'MultiPoint') featureSubIndex++;
                }
                if (geomType === 'LineString') featureSubIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') featureSubIndex++;
                }
                if (geomType === 'Polygon') featureSubIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                        }
                    featureSubIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the feature being processed.
 * @param {number} featureSubIndex The current subIndex of the feature being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            callback(geojson.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current geometry being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} currentProperties The current feature properties being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        geometryProperties,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                callback(null, featureIndex, geometryProperties);
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                callback(geometry, featureIndex, geometryProperties);
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], featureIndex, geometryProperties);
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {Object} currentProperties The current feature properties being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=currentProperties
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            callback(feature(geometry, properties), featureIndex, 0);
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            callback(feature(geom, properties), featureIndex, featureSubIndex);
        });

    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureSubIndex The subindex of the current element being processed in the
 * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=featureSubIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        coordReduce(feature, function (previousCoords, currentCoord) {
            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);
            segmentIndex++;
            return currentCoord;
        });
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} [currentSegment] The current segment being processed.
 * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.
 * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.
 * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= featureSubIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Create Feature
 *
 * @private
 * @param {Geometry} geometry GeoJSON Geometry
 * @param {Object} properties Properties
 * @returns {Feature} GeoJSON Feature
 */
function feature(geometry, properties) {
    if (geometry === undefined) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Create LineString
 *
 * @private
 * @param {Array<Array<number>>} coordinates Line Coordinates
 * @param {Object} properties Properties
 * @returns {Feature<LineString>} GeoJSON LineString Feature
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: {
            type: 'LineString',
            coordinates: coordinates
        }
    };
}


/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
 * @example
 * var mtLn = turf.multiLineString([
 *   turf.lineString([[26, 37], [35, 45]]),
 *   turf.lineString([[36, 53], [38, 50], [41, 55]])
 * ]);
 *
 * turf.lineEach(mtLn, function (currentLine, lineIndex) {
 *   //=currentLine
 *   //=lineIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');
    var type = geojson.geometry ? geojson.geometry.type : geojson.type;
    if (!type) throw new Error('invalid geojson');
    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
    if (!coordinates) throw new Error('geojson must contain coordinates');

    switch (type) {
    case 'LineString':
        callback(coordinates, 0, 0);
        return;
    case 'Polygon':
    case 'MultiLineString':
        var subIndex = 0;
        for (var line = 0; line < coordinates.length; line++) {
            if (type === 'MultiLineString') subIndex = line;
            callback(coordinates[line], line, subIndex);
        }
        return;
    case 'MultiPolygon':
        for (var multi = 0; multi < coordinates.length; multi++) {
            for (var ring = 0; ring < coordinates[multi].length; ring++) {
                callback(coordinates[multi][ring], ring, multi);
            }
        }
        return;
    default:
        throw new Error(type + ' geometry not supported');
    }
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} lineIndex The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var mtp = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=lineIndex
 *   //=lineSubIndex
 *   return currentLine
 * }, 2);
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
    });
    return previousValue;
}


/***/ }),
/* 387 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);